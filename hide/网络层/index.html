

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="lhy">
  <meta name="keywords" content="">
  
    <meta name="description" content="网路层的几个重要概念   网络层的设计思路：由于计算机有很强的纠错能力（而电话没有），因此网络层要尽量简单，向上层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。不提供服务质量的承诺。 这样不仅方便，成本也低。    网络层的两个方面   路由器之间传送的有两种 转发源主机和目的主机之间要传送的数据。 传送路由信息来建立路由表。   两个层面   数据层面 将收到的数据查找自己独立的转发表">
<meta property="og:type" content="article">
<meta property="og:title" content="网络层">
<meta property="og:url" content="https://lhish.github.io/project/hide/%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="lhish&#39;s blog">
<meta property="og:description" content="网路层的几个重要概念   网络层的设计思路：由于计算机有很强的纠错能力（而电话没有），因此网络层要尽量简单，向上层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。不提供服务质量的承诺。 这样不仅方便，成本也低。    网络层的两个方面   路由器之间传送的有两种 转发源主机和目的主机之间要传送的数据。 传送路由信息来建立路由表。   两个层面   数据层面 将收到的数据查找自己独立的转发表">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%201.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%202.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%203.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%204.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%205.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%206.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%207.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%208.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%209.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2010.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2011.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2012.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2013.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2014.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2015.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2016.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2017.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2018.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2019.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2020.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2021.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2022.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2023.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2024.png">
<meta property="og:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2025.png">
<meta property="article:published_time" content="2025-08-15T16:11:49.993Z">
<meta property="article:modified_time" content="2025-08-15T16:11:49.993Z">
<meta property="article:author" content="lhy">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lhish.github.io/image/%E7%BD%91%E7%BB%9C%E5%B1%82image.png">
  
  
  
  <title>网络层 - lhish&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lhish.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"FRE6onbifjN6EZHDhQU1JNHi-gzGzoHsz","app_key":"3Vcbojuu7Fs8YXYGfaCXxvfs","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>lhish&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="网络层"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-16 00:11" pubdate>
          2025年8月16日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          78 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">网络层</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="网路层的几个重要概念">网路层的几个重要概念</h2>
<ol>
<li>
<p>网络层的设计思路：由于计算机有很强的纠错能力（而电话没有），因此网络层要尽量简单，向上层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。不提供服务质量的承诺。</p>
<p>这样不仅方便，成本也低。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>网络层的两个方面</p>
<ol>
<li>
<p>路由器之间传送的有两种</p>
<p>转发源主机和目的主机之间要传送的数据。</p>
<p>传送路由信息来建立路由表。</p>
</li>
<li>
<p>两个层面</p>
<ol>
<li>
<p>数据层面</p>
<p>将收到的数据查找自己独立的转发表并将数据转发除去（以纳秒为单位）</p>
</li>
<li>
<p>控制层面</p>
<p>跟其他路由器合作，创建路由表。（以秒为单位）</p>
</li>
</ol>
</li>
<li>
<p>软件定义网络SDN</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%201.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>将控制放在远程，本地只进行转发，这样效率会提高。</p>
</li>
</ol>
</li>
</ol>
<h2 id="网际协议IP">网际协议IP</h2>
<ol>
<li>
<p>网络层除了IP本身，还有ARP，ICMP，IGMP，IP使用ARP，ICMP和IGMP使用IP。</p>
</li>
<li>
<p>虚拟互连网络</p>
<p>由于用户的需求和资源是各种各样的，因此没有一种网络可以适应所有用户的需求。</p>
<p>在物理层（转发器）和数据链路层（网桥，交换机）上，仅仅算是把网络扩大了。而网关（网络层）基本不适用。因此所谓的把网络互相连接起来的中间设备是路由器（网络层）。</p>
<p>连接起来后，整个互联的网络都使用IP（这个是很统一的），也就成为了一个虚拟互联网络（IP网），使得他们在表面上就好像是一个统一的网络，也就透明了，通信时就好像在单个网络上通信一样。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%202.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>直接交付：在信息传输的时候，如果直接连接着，中间没有由任何路由器中转。</p>
<p>间接交付：中间经过了路由器。</p>
<p>对于一次传输，将每一次转发都称为一”跳“，而转发到下面一个路由器或主机称为”下一条”。</p>
<p>而只有最后一条是直接交付，其他都是间接交付。</p>
</li>
<li>
<p>IP地址：每一台主机或者路由器的每一个接口，唯一的32位标识符，由互联网名字和数字分配机构ICANN分配</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%203.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>IP地址不仅代表了主机，还有其连接到的网络。前n为就代表了其连接到的网络，网络号相同的就在同一个网络中。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%204.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>
<p>分类的IP地址</p>
<table>
<thead>
<tr>
<th>A</th>
<th>n=8</th>
<th>2^31</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>n=16</td>
<td>2^30</td>
</tr>
<tr>
<td>C</td>
<td>n=24</td>
<td>2^29</td>
</tr>
<tr>
<td>D</td>
<td>多播</td>
<td>2^28</td>
</tr>
<tr>
<td>E</td>
<td>以后使用</td>
<td>2^28</td>
</tr>
</tbody>
</table>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%205.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>特殊地址：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>0</th>
<th>本网络</th>
<th>主机号为0表示自身，其他只是对应本网络的主机，全1表示本网络上的所有主机</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>127</td>
<td>环回测试</td>
<td>本主机进程之间的通信，不会上网络</td>
</tr>
<tr>
<td>B</td>
<td>255</td>
<td>在本网络广播</td>
<td>必须主机号也为全1</td>
</tr>
<tr>
<td>?</td>
<td>Y</td>
<td>在Y网络广播</td>
<td>必须主机号也为全1</td>
</tr>
</tbody>
</table>
<p>由于每个IP类型的全0和全1的主机号一般不适应(用来表示自身或者本网络上所有的主机），因此每一类网络可容纳的最大主机数为2^(32-n)-2个。</p>
<p>但这样的每一类的主机容量数量的差距还是太大了，比如说300就是一个很尴尬的数字，要分配65536个，很浪费。</p>
</li>
<li>
<p>无分类域间路由选择CIDR</p>
<p>网络号被改为网络前缀，可以为任意长，而非像之前分类一样定长。使用斜线计数法，斜线后面表示网络前缀的位数。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%206.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%207.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>CIDR地址块：网络前缀都相同的所有连续IP</p>
<p>当然，可支配地址数，即主机数仍然要-2，去掉全0全1。</p>
<p>对于一个CIDR地址，如果不指定前缀长度，则这个IP就是不确定的。因为网络前缀可以是任意长的。如果主机号全0，既可以表示主机号全0的地址，也可表示这个地址块的所有主机。</p>
<p>地址掩码：十进制的网络前缀长度对计算机很不友好，于是就由网络前缀长度个1+(32-n)个0来表示这个。在使用的时候直接与IP进行与运算，即可得出网络地址。</p>
<p>特殊地址块：</p>
<ol>
<li>n=32，这就是一个IP地址，用于主机路由。</li>
<li>n=31，用于点对点链路。</li>
<li>n=0，且IP全0，用于默认路由。</li>
</ol>
<p>路由聚合：一般一个比较大的地址块中都包含很多较小的地址块，如果要写这一个一个小的地址块的路由的话会很长，不如直接用一个大的地址块来替代。</p>
</li>
<li>
<p>IP地址的特点</p>
<p>优点：由于是分等级的地址结构，IP地址管理机构只需要分配网络前缀即可。并且还可以减少查找转发所花的时间。并且，能让一台主机有多个接口。</p>
<p>路由器有至少两个IP地址，因为他至少连接着两个网络。</p>
<p>而路由器与路由器相连的这条线路，实际上也是一个网络（无编号网络/匿名网络），是一个只包含这两个路由器本身的网络，即点对点链路，n=31。</p>
</li>
</ol>
</li>
<li>
<p>IP地址与MAC地址</p>
<p>对于每一个转发的路由器，在接收到数据的时候，上一段数据链路已经结束了（MAC只针对每一条链路），但本次IP传输（而IP是整一次传输）还没有结束，因此路由器所干的事情就是，把收到的MAC帧的MAC帧头删掉，根据里面的IP查询下一段链路对应的源MAC和目的MAC。</p>
<p>因此在整一次传输中，MAC源和目的一直在变，而IP则没有。</p>
</li>
<li>
<p>地址解析协议ARP（解决本局域网上的IP对应的MAC，不只是主机发送，路由器转发的时候也要用）</p>
<p>在转发的时候，路由器需要知道IP对应的下一条的MAC地址，解决方法就是使用一个ARP高速缓存存储IP地址到MAC地址的映射表，且这个表一致在更新（当一条信息的生命周期到了就会被删除）。</p>
<p>在查表时如果查到了，就直接转发。否则</p>
<ol>
<li>在局域网上广播发送ARP请求分组（广播）（其中包括本机IP，MAC和请求IP）</li>
<li>若接受者IP符合，就向A发送响应分组（单播）（包括自身的MAC）</li>
<li>接收并写入</li>
</ol>
<p>如果是不同局域网的话，就不是问目的IP了，而是要经过的转发路由器的IP，这个应该由本机请求路由器的IP，或者一个路由器根据转发表去请求转发的路由器。</p>
<p>要通过一步IP和MAC地址的转换的原因是，MAC地址并不是统一的，因此MAC地址的转化非常复杂，不如通过统一的IP地址的转换。</p>
</li>
<li>
<p>IP数据报的格式</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>0.5</th>
<th>协议IP的版本，IPV4就是4，6就是6</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>首部长度</td>
<td>0.5</td>
<td>单位为4字节长，因此总长度最多60字节，且可选部分必须整除4字节，不够的用填充字段填充</td>
<td></td>
</tr>
<tr>
<td>区分服务</td>
<td>1</td>
<td>用来获得更好的服务，但一般不使用</td>
<td></td>
</tr>
<tr>
<td>总长度</td>
<td>2</td>
<td>IP数据报的长度，单位为字节，最大为65536字节</td>
<td>总长度不是越大越好，小的数据报转发快，并且，并不是所有的主机都接收长的数据报，只要求≤576(512更上层交下来的长度+60首部字节+4余量)的数据报必须能接收</td>
</tr>
<tr>
<td>标示</td>
<td>2</td>
<td>每生产一个数据报，标示就+1，用于IP数据报被分片后，在重组的时候标示这是同一个数据报</td>
<td>当一个IP数据报要被数据链路层分片时，一种是数据链路层提供重组服务，一种是要求IP数据报自己先分片，保证到数据链路层不会再分片。</td>
</tr>
<tr>
<td>标志</td>
<td>3/8</td>
<td>最低为MF，为1标示后面还有分片，接收者再等等，为0标示这是最后一个；中间一位为DF，当DF为0时允许分片。</td>
<td></td>
</tr>
<tr>
<td>片偏移</td>
<td>13/8</td>
<td>指出数据报在切片之前的位置，单位为8字节</td>
<td>除了最后一个数据报，其他数据报的长度一定是8的倍数</td>
</tr>
<tr>
<td>生存时间TTL</td>
<td>1</td>
<td>指出数据报的寿命，避免无限留在互联网上</td>
<td>一开始单位是秒；后来更改为跳数限制，每一跳就减1。为0时丢弃。</td>
</tr>
<tr>
<td>协议</td>
<td>1</td>
<td>指出携带的数据是什么协议，以便交给上方处理</td>
<td>如下图</td>
</tr>
<tr>
<td>首部检验和</td>
<td>2</td>
<td>只用来检验数据报首部，每经过一个路由器都都要重新计算一下首部检验和</td>
<td>一开始这一部分的值就是将所有首部按16位字划分，然后反码运算求和的结果，再求一次反，在检验的时候，同样将所有反码求和，但还要再加上这个检验和，并再求一次反码，若每出错，则为0。</td>
</tr>
<tr>
<td>源地址</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>目的地址</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>可变+填充部分</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%208.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ol>
<h2 id="IP转发分组的过程">IP转发分组的过程</h2>
<ol>
<li>
<p>基于终点的转发</p>
<p>虽说转发是基于IP数据报中的目的IP地址的转发，但是实际上并不是查找目的IP地址，这样转发表就太大了，因此只是查找其网络前缀，最后在网络内再交付。</p>
<p>而对于一个路由表来说，当要匹配的时候，就是从上往下进行与运算，最长的匹配就是目标方向，也就是下一跳。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%209.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>最长前缀匹配</p>
<p>在查找路由表的时候，总是寻找最长的匹配，因此为了速度，一般把前缀长的放在路由表的前面，匹配后就不用再往下了（与运算）</p>
<p>路由表有的时候还会有两种特定路由。</p>
<ol>
<li>主机路由(特定主机路由)：前缀为a.b.c.d/32，并非一个网络号，而是一个IP地址，只与这个IP匹配，用于控制和测试网络。</li>
<li>默认路由：前缀为0.0.0.0/0，能与所有IP匹配，相当于else一样。</li>
</ol>
<p>如果没有匹配到，则报告转发分组出错。</p>
</li>
<li>
<p>使用二叉线索查找转发表</p>
<p>边就是0或者1，实体节点就是一条路由表项。最终建立出一棵二叉搜索树，也就很方便进行查找。而为了提高速度，还使用了各种压缩技术，当一条路径没有很分叉的时候，就可以把他压缩层一条边。</p>
</li>
</ol>
<h2 id="网际控制报文协议ICMP">网际控制报文协议ICMP</h2>
<p>ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告。虽然ICMP是封装在IP数据报的数据部分的，但是，ICMP不是高层协议，而是IP层的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>1</th>
<th>标示ICMP类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码</td>
<td>1</td>
<td>用于区分一种类型的不同情况</td>
</tr>
<tr>
<td>检验和</td>
<td>2</td>
<td>检验整个ICMP报文，因为IP数据报并不提供对数据部分的检验</td>
</tr>
<tr>
<td>取决于ICMP的报文的类型</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>数据</td>
<td>取决于类型</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>ICMP报文的种类
<ol>
<li>
<p>ICMP差错报告报文</p>
<table>
<thead>
<tr>
<th>终点不可达</th>
<th>3</th>
<th>路由器或者主机无法交付</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间超过</td>
<td>11</td>
<td>TTL过了，当路由器收到TTL0，或者终点超过时间了还没收到，就要发送</td>
</tr>
<tr>
<td>参数问题</td>
<td>12</td>
<td>参数错误，就丢弃并发送</td>
</tr>
<tr>
<td>改变路由</td>
<td>5</td>
<td>告诉主机下次切换发送的路由（更好的路由）</td>
</tr>
</tbody>
</table>
<p>改变路由：因为一个主机也有可能有多个IP，也就是和多个路由器相连，在发送的时候也要根据其自身的转发表进行转发。而由于主机太多了，因此，其不和路由器直接交换信息，而是在一开始随便选择一个路由发送，而路由器在发现对这个主机更好的路由后就可以发送这个数据报更改其默认路由，也就是更新转发表。</p>
<p>格式：ICMP的首部，IP数据报的首部（差错报文一般都是针对另一个IP数据报的）和数据字段的前8个字节（帮助TCP和UDP）。</p>
<p>但当是对一个ICMP数据报，非首个分片，多播地址的数据报，具有特殊地址的数据报，不发送。</p>
</li>
<li>
<p>ICMP询问报文</p>
<ol>
<li>回送请求/回答：向特定的主机或者路由器发送询问，接受者必须回送回答报文，用于测试是否可达或者了解状态。</li>
<li>时间戳请求/回答：向对方询问接收到的时间，计算RTT</li>
</ol>
</li>
</ol>
</li>
<li>应用
<ol>
<li>
<p>PING（Packet InterNet Groper）</p>
<p>通过时间戳请求来判断可达和RTT。</p>
</li>
<li>
<p>traceroute</p>
<p>通过从TTL为1开始，不断增加(2,3,…)来发送非法的UDP数据报，途中的路由器就需要向源主机发送ICMP终点不可达差错报文，也就知道中间的每一个路由器的IP了，也就知道路径了。</p>
<blockquote>
<p>但是现在很多路由器都直接不理会这样的数据报了，导致很多都返回不知道。</p>
</blockquote>
<p>经过的路由器数量并不和时间呈正比。</p>
</li>
</ol>
</li>
</ol>
<h2 id="IPv6">IPv6</h2>
<p>IPv4的数量要耗尽了，因此就开始使用IPv6。</p>
<p>与IPv4的区别：地址空间扩大2^96倍；首部提供更多功能，并且首部长度固定，扩展部分在扩展首部；8直接对齐；可灵活调整扩充。</p>
<ol>
<li>
<p>IPv6的基本结构</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>0.5</th>
<th>与IPv4一样，这里是6</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信量类</td>
<td>1</td>
<td>区分IPv6的类别和优先级，仍然在测试</td>
</tr>
<tr>
<td>流标号</td>
<td>2.5</td>
<td>对普通的信息无用，置0，而对流（从特定源点到终点的一系列数据报，途径的路由器保证质量）特别有用，如实时音频/视频，一个流的所有包的流标号相同</td>
</tr>
<tr>
<td>有效载荷长度</td>
<td>2</td>
<td>有效荷载的长度，单位：字节</td>
</tr>
<tr>
<td>下一个首部</td>
<td>1</td>
<td>当不是最后一个首部的时候，值代表下一个扩展首部的类型，否则是数据内容是高层的什么协议</td>
</tr>
<tr>
<td>跳数限制</td>
<td>1</td>
<td>TTL，最大255</td>
</tr>
<tr>
<td>源地址</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>目的地址</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>扩展首部*n</td>
<td>和下面总体≤65536</td>
<td>原本IPv4要全部进行扫描看扩展是否与本路由器相关，很慢，现在通过在首部指出就能很快的处理</td>
</tr>
<tr>
<td>数据部分</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>IPv6的地址</p>
<p>目的地址类型：单播，多播，任播（一组计算机中的任意一个）。</p>
<p>冒号十六进制记法：将每16位的值用十六进制表示，用：分隔。对于数字前的前缀0，可以省略。对于连续的0，可以用：：省略，但最多出现一个：：，因为出现多个就不知道每一个：：省略了几个0。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2010.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>仍然使用CIDR斜线表示法，但取消了子网掩码。</p>
<p>常用地址：</p>
<table>
<thead>
<tr>
<th>未指明地址</th>
<th>::/128</th>
<th>当一台主机没有配置到一个IP的时候，他的IP就是这个</th>
</tr>
</thead>
<tbody>
<tr>
<td>环回地址</td>
<td>::1/128</td>
<td>本主机进程之间的通信，不会上网络</td>
</tr>
<tr>
<td>多播地址</td>
<td>FF00::/8</td>
<td></td>
</tr>
<tr>
<td>唯一本地单播地址</td>
<td>FC00::/7</td>
<td>当不接入互联网时，可以使用唯一本地单播地址来在局域网互相通信</td>
</tr>
<tr>
<td>本地链路单播地址</td>
<td>FE80::/10</td>
<td>当不接入互联网时，可以使用本地链路单播地址来在同一链路（不经过网关或者路由器）互相通信</td>
</tr>
<tr>
<td>全球单播地址</td>
<td>2000::/3</td>
<td>占1/8，全球单播，划分很灵活</td>
</tr>
</tbody>
</table>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2011.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>从IPv4向IPv6过度</p>
<p>很显然转化不可能一蹴而就，因此只能逐步演进</p>
<ol>
<li>
<p>双协议栈</p>
<p>主机同时支持IPv4和IPv6，通过查询DNS来判断目标主机是IPv4还是IPv6来选择协议，但付出的代价太大了。</p>
</li>
<li>
<p>隧道技术</p>
<p>当IPV6要进入IPv4网络时，就把它封装为IPv4的数据部分，协议字段需要设置为41，当离开的时候就将其数据报再交还给IPv6协议。</p>
</li>
</ol>
</li>
<li>
<p>ICMPv6</p>
<p>将IPv4的ARP和IGMP都合并到了ICMPv6中。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2012.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ol>
<h2 id="互联网的路由选择协议">互联网的路由选择协议</h2>
<ol>
<li>
<p>有关路由选择协议的几个基本概念</p>
<p>理想的路由算法应该包括以下几个方面：正确且完整，计算简单，能适应通信量和网络拓扑的变化，稳定性，公平（对每个用户），最佳（在特定要求下较为合理的）</p>
<p>通过能否适应变化可以将路由算法划分为静态路由选择策略和动态路由选择策略。</p>
<p>由于互联网的规模很大且需要一些隐私（保密），因此选择了分层次的路由选择算法。</p>
<p>每一个自治系统内部使用一套，即内部网关协议IGP（路由选择叫域内路由选择），自治系统之间也有一套，即外部网关协议EGP（路由选择叫域间路由选择）</p>
</li>
<li>
<p>内部网关协议RIP：分布式的基于距离向量的路由选择协议（实现简单开销小但范围小）</p>
<p>RIP中的每一个路由器都需要知道自己到目的网络的距离（即跳数）。但RIP只允许一条路径最多15个网络，否则不可达，因此只适用于小网络。</p>
<p>RIP仅仅会选择跳数最小的，而不管其他的因素，很死板，也仅和相邻路由器按固定时间交换自己的路由表，但收敛速度较快。</p>
<p>方法（Bellman-fold）：当收到X发来的路由表时，先将下一跳更改为X并距离+1。如果本路由表中没有，则增加，如有且路由器地址相同，则替换（因为路径可能在变化，更新的就是更正确的），否则只在更小的时候进行替换。</p>
<p>传输：作为UDP的数据部分传输，除去RIP报文的首部，路由部分要填入自治系统号ASN保证不会被其他自治系统的消息影响，还有目的网络地址，子网掩码，下一条路由器地址，和距离。最多包含25个路由，否则切片。</p>
<p>坏消息传的慢：当某个路由器c无法到达，直接连接的路由器a被赋值为16，但之前在没失联的时候，路由器b通过a获得了到c距离为2，因此在更新时将3传送给a，由于更新而且更小，于是失联的消息就被覆盖了，除非再慢慢增长到16，才会发现这一问题。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2013.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>开放最短路径优先OSPF</p>
<p>使用泛洪法每30分钟（收到其他路由器的信息后拷贝一份向所有输出端口发送，最终所有路由器都能获得）向AS中的所有路由器发送与本路由器响铃的所有路由器的链路状态（如连接状态和传输代价（可自行定义））。当掌握所有信息后（建立了链路状态数据库：一致的全网的拓扑结构图），用SPF（dijkstra）来计算最短路。收敛同样很快</p>
<p>通过将AS划分为更小的区域（用层次的逻辑，最上层的（主干区域）为0.0.0.0，下面的区域依次增加），主干区域通过其中的 自治系统边界路由器 负责与其他自治系统通信，区域边界路由器负责对其他区域来的信息进行概括，使得每个区域内部的通信量大大减少。</p>
<p>OSPF能随意定义代价，很灵活；也能找出所有的最短路径做负载均衡；交换的分组有鉴别功能；链路状态有时间戳以表明这是更新的信息方便更新。</p>
<p>作为IP数据报的数据部分来传送，长度较短，可以减少路由信息通信量。</p>
<p>保活：相邻数据库每隔10s交换一次问候分组，如果40秒没收到，则认为不可达</p>
<p>方法：一开始路由器与相邻路由器交换数据库描述分组，然后向对方发送链路状态请求分组，获取自己没有的，逐渐全网就有了。而当一个路由器发生变化，则通过可靠的洪泛法向全图发送链路状态更新分组，而在收到后要向发送链路状态更新的路由器发送链路状态确认分组，因此非常可靠。</p>
<p>保证一致性：30分钟刷新一次数据库的链路状态</p>
<p>不仅没有坏消息传的慢，而且并没有规模上的限制。</p>
<p>有的时候，当要更新的太多的时候，可能有n(n-1)的分组在网上跑。因此可以使用一个指定的路由器，先接收所有的路由器的信息，再代表所有人发送状态。</p>
</li>
<li>
<p>边界网关协议BGP（寻找路径的方式是两两间交换？）</p>
<ol>
<li>
<p>BGP只能通过路径向量路由选择协议选择一条能够到达目的网络。因为互联网的规模很大，且对代价的衡量标准不一，并且可能自治系统能否允许某些数据报通过会被网络以外的银烛，如经济，政治，安全等影响。</p>
</li>
<li>
<p>在边界路由之间的链路上，会建立半永久性连接（在交换完信息后仍然处于连接状态），为eBGP连接，用来告诉边界路由该如何达到某个AS中的节点。而AS内部，也需要在节点之间互相建立iBGP连接，用来共享AS获得的信息。虽然物理链路上并不是全连通的，但是他们之间建立了全连通的iBGP连接。</p>
<blockquote>
<p>如果管理员在边界路由上设定限制，则就可以拒绝某些路由且iBGP也不会进行转发。</p>
<p>iBGP和eBGP是同一个协议，他们都能在自己范围的对等路由器（建立了连接的路由器，有时为了减少传输量，会并不是全连接的状态）之间转发消息。</p>
</blockquote>
<p>传输的信息：[前缀(重点)，AS-PATH（路径，每经过一个AS，就将其ASN加入），NEXT-HOP]</p>
<p>而对于iBGP，对于接收到的下一跳(R1)不在AS中，于是更改路由为其对等端(R2)，接着查找自身到该对等端的最佳下一跳路由。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2014.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>共有三种AS：</p>
<ol>
<li>
<p>末梢AS：只接受或发送分组给其直接连接的AS，但不转发，也就是不允许信息穿越自己的AS。</p>
<p>多归属AS：超过1个AS连接到这个末梢AS上，能增加可靠性（即便一个寄了也能继续）</p>
</li>
<li>
<p>穿越AS：专门为别的AS有偿转发分组，拥有分号的高速通信干线</p>
</li>
<li>
<p>对等AS：经过事先协商的两个AS，保证相互发送或接受分组免费</p>
</li>
</ol>
<p>通过在AS-PATH中避免出现相同的AS，保证了不会出现兜圈子</p>
</li>
<li>
<p>路由选择</p>
<p>当有多个路由可以选择时：</p>
<ol>
<li>
<p>选择本地偏好值最高的路由：同一个AS下，偏好值最高的路由（会导致负载不均衡）</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2015.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>选择AS跳数最小的路由：即便实际经过的路由可能更多，但仅考虑AS跳数。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2016.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>热土豆路由选择算法：把要发送的当成烫手芋头，尽可能经过少的路由器离开AS</p>
</li>
<li>
<p>选择BGP标识符最小的路由：每个路由都有一个4字节的BGP标示</p>
</li>
</ol>
</li>
<li>
<p>四种报文</p>
<p>BGP在一开始对等端要交换整个BGP，后续只有变化时才更新。</p>
<table>
<thead>
<tr>
<th>OPEN</th>
<th>在两个路由器建立TCP连接的时候发送</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEEPALIVE</td>
<td>在收到OPEN信号时如果要接受就回送；TCP虽然保证质量，但其上层BGP不保证，因此每个路由器会有一个保持时间计时器，在一开始建立的时候商量保持时间（若不同，则选择双方中较小的），每1/3的保持时间就发送一次KEEPALIVE。如果保持时间为0表示永不发送，永远正常工作。</td>
</tr>
<tr>
<td>UPDATE</td>
<td>在增（一次一个）减（一次可多个）路由的时候发送</td>
</tr>
<tr>
<td>NOTIFICATION</td>
<td>发送检测到的差错</td>
</tr>
</tbody>
</table>
<p>作为TCP的数据部分，因为要半永久连接。</p>
</li>
</ol>
</li>
<li>
<p>路由器的构成</p>
<ol>
<li>
<p>结构</p>
<p>路由器是一种多个输入端口和多个输出端口的专用计算机，任务是转发分组</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2017.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>控制层面：负责根据路由选择协议来维护路由表。</p>
<p>数据层面：由一组输入端口，一组输出端口和一个交换结构组成</p>
<p>交换结构：根据转发表对分组进行处理，将输入端口的分组转发到输出端口，是一种在交换机中的网络。</p>
<p>转发表：与路由表不同，路由表涉及很多路由器，而转发则只涉及这个路由器。路由表一般只包括IP到下一跳的映射，而转发表则包含转发功能的全部信息。</p>
<p>对于输入端口，当输入的是路由信息分组，就送入控制，否则，就会根据输入端口的影子副本（一般为了处理速度将转发表复制一份放在输入端口的第三层）转发到输出。</p>
<p>但是转发本身也是需要处理时间的，因此转发前有一个队列进行等待，而传送过来的分组超过发送速率时，也需要在输出端口处有一个队列。而当超过上限的时候，就会丢失。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2018.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>交换结构</p>
<p>交换结构就是根据转发表将分组从输入端口复制到输出端口。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2019.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>通过存储器，在输入端口中将查找和复制到存储器完成。</li>
<li>通过总线，不需要路由选择处理机的干预，因为总线本身就具有传输(选择)的功能，但是总线在同时只能传输一个分组，转发宽带就会受到总线速率的限制。</li>
<li>通过横纵交换结构的互联网络，根据情况将对应的节点连接，即可创造链路，是无阻塞的，只要输出端口没有被别的分组占用，就可以转发到任何一个端口。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IP多播">IP多播</h2>
<ol>
<li>
<p>IP多播的基本概念</p>
<p>如果要对特定的一系列用户传输同一个数据报，可以传输n个数据报，随着传播而分流，但这样对互联网耗费的资源太多了。因此要使用多播，在发送的时候只发送一次，而在经过路由器的时候，如果有多条链路都要，就直接复制副本到对应的链路上（需要是多播路由器），而到局域网的时候，由于其有硬件多播的特性，就不用复制了。</p>
<p>IP多播：在互联网上的多播。</p>
<p>多播数据报通过在目的地址写入多播标识符（D类地址），使用网际组管理协议IGMP（协议号为2）尽最大努力交付数据报。且对多播数据报不产生ICMP差错报文，并让加入到多播组的主机的IP和这个多播标识符相关联。</p>
</li>
<li>
<p>在局域网上进行硬件多播（实际上就是直接广播+MAC层筛选）</p>
<p>在这里，并不能仅仅通过MAC地址就能判断哪些就能丢弃。MAC地址的第一字节的最低为为1代表多播，但是，前25位被管理者要求不变，只允许使用后23位。因此，32位的IP地址，前4为代表多播，中5不适用，后23直接与MAC完全对应，是多对一，也就是一个MAC地址对应多个IP地址，因此在上交到IP层后也仍然要进行一遍判断。</p>
</li>
<li>
<p>网际组管理协议IGMP和多播路由选择协议</p>
<p>IGMP协议：让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或推出了某个多播组。</p>
<p>多播路由选择协议：和其他多播路由器协同工作以最小代价送给所有组成员。</p>
<p>难点在于：组成员的变化也要更新（拓扑未变化）；不但要考虑目的地址，也要考虑源地址；并且数据报也可以由非多播组成员发出。</p>
<ol>
<li>
<p>IGMP（无人知道多播组的具体成员）</p>
<p>传输：作为IP数据报的数据部分，且为IP提供服务。</p>
<p>当新主机加入多播组时，主机要发送IGMP通知路由器，而路由器要通知其他多播路由器。</p>
<p>同时，要周期性地探询本局域网上的所有主机，只要有一个主机响应，就认为这个组还活跃（至少有一个成员在本地，因此要转发此处）</p>
<p>实现细节：</p>
<ol>
<li>所有通信使用IP多播，直接避免了不参加多播的主机或路由器的参与，且减少数据量。</li>
<li>探询组成员的时候，对多个组统一探查。</li>
<li>同一个网络连接多个多播路由器不会引起IGMP通信量增大（会只选择其中一个操作）</li>
<li>若一个主机参加了多个组，就以不同的时延来发送信号来表示自己参加的组</li>
<li>监听其他主机，在别人发了后自己开摆</li>
</ol>
</li>
<li>
<p>多播路由选择协议</p>
<p>多播路由选择协议就是要找出以源主机为根节点的多播转发树，而这颗转发树会因为不同的多播组，不同的原点而不同。</p>
<p>多播路由选择协议暂时并没有一个标准。主要有三种方法实现：</p>
<ol>
<li>
<p>洪泛和剪枝（范围较小）：首先先广播多播数据报，并使用反向路径广播RPB来避免兜圈子：对于每一个接受者，计算到源点的最短路径，判断送来数据的路由器是否是最短路径上的第一个点（保证自己是最短路）（这样做是因为每个都是一个个体，不知道他人的情况），是则向其他方向转发。而若有多个都是最短路径上的第一个点，选择IP最小的。</p>
<p>当发现到某个路由器为止，已经没有多播组的成员则停止。(剪除）</p>
</li>
<li>
<p>隧道技术（IP in IP）（地理位置分散）：若在转发的过程中要经过一段不支持多播的网络，那么就将多播数据报作为IP数据报的数据部分通过单播发向另一个支持多播的网络。</p>
<ol>
<li>基于核心的发现技术（范围较大）：选择一个核心路由器，并建立以这个路由器为源点的转发树。当一个属于这个组的数据报达到这个节点，就像所有节点广播一下。如果是加入，则调整自身的转发树。</li>
</ol>
</li>
</ol>
<p>现在有很多协议：DVMRP，CBT，MOSPF，PIM-SM，PIM-DM。</p>
</li>
</ol>
</li>
</ol>
<h2 id="虚拟专用网VPN和网络地址转换NAT">虚拟专用网VPN和网络地址转换NAT</h2>
<ol>
<li>
<p>虚拟专用网VPN</p>
<p>专用地址（可重用地址）：某些机构内部的网络不需要和互联网通信，他们仅需要一个仅在本机构有效的IP地址（本地地址）并且不在互联网上有效的IP（即在互联网上没有明确指代的地址）。路由器完全不会转发目的地址是专用地址的数据报。10.0.0.0/8（原本是阿帕网的），172.16.0.0/12，192.168.0.0/16</p>
<p>专用互联网（本地互联网）：采用专用地址的网络。</p>
<p>虚拟专用网：有的时候，专用网中的主机不是直接互相连接的，需要互联网的帮助进行互相通信。为了保密，当路由器发现目的网络必须通过互联网才能到达，就通过将内部数据报加密作为外部数据报的数据部分来进行传输。形成了内联VPN，表示其是同一个结构的。而外联VPN就是非同一机构的。</p>
<p>远程接入VPN：员工的主机通过VPN与公司内部网络进行通信。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2020.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>网络地址转换</p>
<p>NAT：对于使用本地地址的主机在和外界通信的时候，需要一个全球IP地址，但全球IP地址并不够多。因此，在经过路由器的时候，会根据路由器所拥有的全球IP地址，暂时分配一个给这一个主机并在本地记录，在接收到发送给这个全球IP的后，再将其转为本地地址。</p>
<p>NAPT网络地址与端口转换：只使用IP地址能同时通信的太少了，因此会就将运输层的端口也用上，根据记录在本地的NAPT地址转换表，进行转换。</p>
</li>
</ol>
<h2 id="多协议标签交换MPLS">多协议标签交换MPLS</h2>
<p>MPLS：通过让每个分组携带一个小整数标签，使其在转发的时候查找更加迅速。是一种给IP增强技术，只是面向连接的服务质量，能均衡网络负载，支持VPN。</p>
<ol>
<li>
<p>工作原理</p>
<p>彼此相邻的支持MPLS的标签路由器LSR就形成了MPLS域。当一个分组进入MPLS域时，会根据其IP首部甚至于运输层应用层的首部对这个分组进行分类，并给予他一个标签（这个标签就决定了其在MPLS域中的转发路径，即显式路由选择）。而内部在进行转发的时候，就根据已经通过标间分配协议LDP交换报文构造得出的转发表（形成标签交换路径LSP）进行转发，由于当前所携带的标签仅在两个LSR之间有效，因此在每个LSR处要做标签对换，即将入标签更换为出标签，并进行转发（是在第二层硬件转发的，因此更快）。当离开MPLS域时再把标签去掉。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2021.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2022.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>转发等价类FEC</p>
<p>FEC：路由器按照同样方式对待的IP数据报的集合，如源地址和目标地址相同的IP数据报等。</p>
<p>而对于FEC中的所有数据报，MPLS就会分配相同的标签，而通过在入口处根据数据报的情况来分配不同的标签，分配到不同的FEC中，就能更好的管理网络资源，实现负载均衡，即流量工程TE或通信量工程。</p>
</li>
<li>
<p>MPLS的首部</p>
<p>在IP数据报在被包装到MAC帧之前，会在IP数据报之前插入MPLS首部。并且，MAC帧的类型会更改，单播为0x8847，多播为0x8848.</p>
<table>
<thead>
<tr>
<th>标签值</th>
<th>2.5</th>
<th>表示标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>实验</td>
<td>3/8</td>
<td>用于时延</td>
</tr>
<tr>
<td>S</td>
<td>1/8</td>
<td>在有标签栈的时候使用</td>
</tr>
<tr>
<td>TTL</td>
<td>1</td>
<td>表示生存时间</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>段路由选择协议SR</p>
<p>由于MPLS的很多缺点，SR这个比较简单的协议开始被使用。在源节点就（通过SDN控制器）将要经过的路径转换为有序的段列表（MPLS标签栈），后续只需要进行转发即可。</p>
</li>
</ol>
<h2 id="软件定义网络SDN">软件定义网络SDN</h2>
<p>所有的计算都放到控制层面上做，而数据层面仅存储表。而之间的桥梁一般是OpenFlow协议。通过OpenFlow协议，在控制层面上看到的实际的网络就是统一规约的。</p>
<p>其还扩展了转发的定义，将其拆分为了两个部分，匹配和动作。这种广义的匹配能够匹配各个层级的首部，转发不仅可以转发还可以实现负载均衡等。</p>
<p>其在数据层面的表是流表，一个流就是穿过网络的一种分组序列，共享分组首部某些字段，即FEC的广义。</p>
<table>
<thead>
<tr>
<th>首部字段值</th>
<th>用来匹配分组的首部</th>
</tr>
</thead>
<tbody>
<tr>
<td>计数器</td>
<td>记录匹配的分组数量和上次更新到现在的时间</td>
</tr>
<tr>
<td>动作</td>
<td>动作</td>
</tr>
</tbody>
</table>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2023.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>能实现简单转发，负载均衡，防火墙等等。</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2024.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>四个关键特征：基于流的转发；数据与控制的分离；控制层面使用软件实现；可编程网络</p>
<p><img src="/image/%E7%BD%91%E7%BB%9C%E5%B1%82image%2025.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>SDN控制器：</p>
<ol>
<li>通信层：负责完成与受控的网络设备之间的通信。其与数据层面的接口的接口角南向API接口。</li>
<li>网络范围的状态管理层：保存的网络信息状态</li>
<li>网络控制应用程序层的接口：通过北接口，与网络控制应用程序交互</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>网络层</div>
      <div>https://lhish.github.io/project/hide/网络层/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>lhy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"FRE6onbifjN6EZHDhQU1JNHi-gzGzoHsz","appKey":"3Vcbojuu7Fs8YXYGfaCXxvfs","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LaTeX数学公式 </title>
    <link href="/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="LaTeX数学公式"><a href="#LaTeX数学公式" class="headerlink" title="LaTeX数学公式"></a>LaTeX数学公式</h1><p>$$<br>x_{2*1}^{21\cdot\sqrt{\theta\alpha}}\int_0^xb\mathrm{d(正)}b\sum_{i&#x3D;1}^{100}\overbrace{x\cdots x}^{i个}\prod_jj^2_1lim^{(k&#x3D;1,\ldots,n)}_{x \to\infty}\overline{0.1^x&#x2F;\vec{a}}\overleftarrow{AB}\frac{\overrightarrow{\beta d}^{\begin{vmatrix}\begin{bmatrix}\begin{pmatrix}1&amp;\cdots&amp;5\ \vdots&amp;\ddots&amp;\vdots \5&amp;\cdots&amp;7 \\end{pmatrix}\end{bmatrix}\end{vmatrix}}}{\bar{x}+\hat{x}-\tilde{x}\bmod1}<br>$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs latex">x<span class="hljs-built_in">_</span>&#123;2*1&#125;<span class="hljs-built_in">^</span>&#123;//<span class="hljs-built_in">_</span>下标，&#123;&#125;当内容为不止一个字符时，<span class="hljs-built_in">^</span>上标<br>21<span class="hljs-keyword">\cdot</span>//点×<br><span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\theta</span><span class="hljs-keyword">\alpha</span>&#125;//根号 <span class="hljs-keyword">\罗</span>马读音:罗马字<br>&#125;<br><br><span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>0<span class="hljs-built_in">^</span>xb<span class="hljs-keyword">\mathrm</span>&#123;d(正)&#125;b//int积分,mathrm正体<br><br><span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i=1&#125;<span class="hljs-built_in">^</span>&#123;100&#125; <span class="hljs-keyword">\overbrace</span>&#123;x<span class="hljs-keyword">\cdots</span> x&#125;<span class="hljs-built_in">^</span>&#123;i个&#125;//sum和 overbrace上括号 cdots横省略号<br><br><span class="hljs-keyword">\prod</span><span class="hljs-built_in">_</span>j j<span class="hljs-built_in">^</span>2<span class="hljs-built_in">_</span>1//prod×<br><br>lim<span class="hljs-built_in">^</span>&#123;<br>(k=1,<span class="hljs-keyword">\ldots</span>,n)//ldots底省略号<br>&#125;<span class="hljs-built_in">_</span>&#123;<br>x <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span>//to箭头，infty无限<br>&#125;<br><span class="hljs-keyword">\overline</span>&#123;//上划线<br>0.1<span class="hljs-built_in">^</span>x/<span class="hljs-keyword">\vec</span>&#123;a&#125;//vec向量<br>&#125;<br><span class="hljs-keyword">\overleftarrow</span>&#123;AB&#125;//overleftarrow上左箭头<br><br><span class="hljs-keyword">\frac</span>//frac分数<br>&#123;//上部<br><span class="hljs-keyword">\overrightarrow</span>&#123;//overrightarror上右箭头<br><span class="hljs-keyword">\beta</span> d<br>&#125;<span class="hljs-built_in">^</span><br>&#123;<span class="hljs-keyword">\begin</span>&#123;vmatrix&#125;//||<br><span class="hljs-keyword">\begin</span>&#123;bmatrix&#125;//[]<br><span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;//()<br>1<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\cdots</span><span class="hljs-built_in">&amp;</span>5<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\vdots</span><span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\ddots</span><span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\vdots</span><span class="hljs-keyword">\\</span>//vdots列省略号，ddots斜省略号<br>5<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\cdots</span><span class="hljs-built_in">&amp;</span>7 <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\end</span>&#123;pmatrix&#125;<br><span class="hljs-keyword">\end</span>&#123;bmatrix&#125;<br><span class="hljs-keyword">\end</span>&#123;vmatrix&#125;&#125;<br>&#125;<br>&#123;//下部<br><span class="hljs-keyword">\bar</span>&#123;x&#125;+<span class="hljs-keyword">\hat</span>&#123;x&#125;-<span class="hljs-keyword">\tilde</span>&#123;x&#125;<span class="hljs-keyword">\bmod</span>1<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\le \ge\  \equiv<br>$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\le</span> <span class="hljs-keyword">\ge</span><span class="hljs-keyword">\ </span> <span class="hljs-keyword">\equiv</span><br>(<span class="hljs-keyword">\ </span>)是空格<br></code></pre></td></tr></table></figure><p><a href="https://api.onedrive.com/v1.0/shares/s!At1YQCR5yNu4hkONFDhPfpnVY7lA/root/content">https://api.onedrive.com/v1.0/shares/s!At1YQCR5yNu4hkONFDhPfpnVY7lA&#x2F;root&#x2F;content</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>modern c++ </title>
    <link href="/modern%20c++/"/>
    <url>/modern%20c++/</url>
    
    <content type="html"><![CDATA[<h1 id="modern-c"><a href="#modern-c" class="headerlink" title="modern c++"></a>modern c++</h1><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>对于某一个函数，其默认参数可以通过多次声明来一起组成。只要保证当前声明的默认实参后的形参在该作用域之前的地方已经声明过默认实参即可，而总体的结果就是这些合并起来。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> <span class="hljs-title function_">C</span>(int a,int b=<span class="hljs-number">1</span>);<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">C</span>(int a=<span class="hljs-number">1</span>,int b);<br></code></pre></td></tr></table></figure><p>但是，默认实参不能被重定义，即便默认实参的值一致。</p><blockquote><p>对于类模板的成员函数，所有默认实参必须在成员函数的初始声明处提供。</p></blockquote><p>如果不是类模板，实际上是可以类内不声明默认实参，但是在类外定义的使用再加上默认实参。</p><p>[[?&#x2F;ide的问题?]]但是，如果是将定义写在.cpp中而将声明写在.h中，使用的时候就不知道有cpp中的默认实参的增加，也就链接不起来。</p><p>默认实参不能用非静态成员变量来赋值。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex </title>
    <link href="/LaTex/"/>
    <url>/LaTex/</url>
    
    <content type="html"><![CDATA[<h1 id="LaTex"><a href="#LaTex" class="headerlink" title="LaTex"></a>LaTex</h1><table><thead><tr><th>\</th><th>换行</th></tr></thead><tbody><tr><td>\newline</td><td>换行</td></tr><tr><td>两个Enter</td><td>换行</td></tr><tr><td>一个Enter</td><td>空格</td></tr><tr><td>多个空格</td><td>一个空格</td></tr><tr><td>\usepackage[option]{packname}</td><td>导入外部包</td></tr><tr><td>\newpage或\clearpage</td><td>换页</td></tr><tr><td>\documentclass{type}</td><td>指定整个文件的风格，用在开头，artical,report,book等等</td></tr><tr><td>\chapter[shorttitle]{title}</td><td>title为实际显示的，short title为目录和页眉页脚的，若[]前带*则无序号且无目录</td></tr><tr><td>\section</td><td></td></tr><tr><td>\subsection</td><td></td></tr><tr><td>\subsubsection</td><td></td></tr><tr><td>\paragraph</td><td></td></tr><tr><td>\subparagraph</td><td></td></tr></tbody></table><p><img src="/image/LaTexUntitled.png" alt="Untitled"></p><table><thead><tr><th>\tableofcontents</th><th>目录</th></tr></thead><tbody><tr><td>\addcontentsline{toc}{level}{title}</td><td>为用了*的标题生成目录，用于标题后</td></tr><tr><td>\title{}，\author{}，\date{}</td><td>设定基本信息</td></tr><tr><td>\and</td><td>用于在\author里连接人名</td></tr><tr><td>\maketitle</td><td>这才是真正生成一个标题页，只能用一次</td></tr><tr><td>\begin{verbatim}\end{verbatim</td><td>用于代码，但是不对tab起作用</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>problems </title>
    <link href="/problems/"/>
    <url>/problems/</url>
    
    <content type="html"><![CDATA[<h1 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h1><p>C2039和C3861这两个错误同时出现在标准库上</p><p>因为自己的工程里有一个math.h文件</p><p>重载解引用运算符识别不出来？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vim </title>
    <link href="/vim/"/>
    <url>/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>hjkl:←↓↑→</p><p>w:向后移动到单词头，将标点符号视为分割，不包括第一个字符</p><p>e:像后移动到单词尾，不将标点符号视为分割，包括最后一个字符</p><p>b:向前移动到单词头，将标点符号视为分割</p><p>B:向前移动到单词头，不将标点符号视为分割</p><p>$:向后移动到行尾，包括最后一个字符</p><p>x:删除当前所在字符</p><p>X:删除当前所在前一个字符</p><p>i:当前位置下开始insert</p><p>a:当前后面一个位置开始insert</p><p>A:从当前行行尾开始insert</p><p>dw:删除当前字符开始的一个word</p><p>d$:删除从当前字符到行尾</p><p>d?:删除从当前字符到?返回的那个字符这一串</p><p>d空:删除整行</p><p>通过在前面加数字可以repeat这么多次</p><p>0:向前移动到行首</p><p>dd:删除整行</p><p>u:undo，可以undo U</p><p>U:对于刚刚操作的这一行，撤销从到他对他开始操作的所有步骤</p><p>Crtl+R:redo</p><p>前面被d掉的东西会暂时存储在p中，可以通过p取出</p><p>r？：将当前这个字符替换为?</p><p>ce:将当前字符到这个word结尾全部删除，并进入insert mode</p><p>c实际就是d然后进入insert mode</p><p>gg:移动到开头</p><p>G:移动到结尾</p><p>行号G:移动到这一行</p><p>&#x2F;字符串：搜索这个字符串</p><p>n向前，N向相反方向</p><p>?与&#x2F;正好相反</p><p>Crtl+O:向后返回到上一个位置，这里的位置是指所有的进行更改的地方和跳转的地方</p><p>Crtl+I正好相反</p><p>%：跳转到对应的另一半括号，若是不在括号上，这跳转到它后面的第一个括号对应的括号处</p><p>((%),(#,#)s&#x2F;old&#x2F;new(&#x2F;g(c)):将这一行第一个old替换为new，&#x2F;g使它替换所有，c使其对于每一个进行询问，%表示全file，#,#表示几行到几行，#是数字</p><p>：！命令：暂时返回到shell执行命令，再返回</p><p>:w Filename:保存(另存为到Filename)</p><p>v:选择，以开始v的地方作为起点，cursor的位置为终点</p><p>在选择后保存会只保存选择的这一段文本</p><p>:r filename:将file中的内容插入到光标后</p><p>o:在当前行下方插入一行并开始insert</p><p>O:在当前行上方插入一行并开始insert</p><p>e与a一般一起用</p><p>R:从cursor开始替换，直到ESC</p><p>v与w,b,e都差不多都是选择</p><p>y可以copy当前选择的，因此可以yw等等</p><p>通过p可以paste</p><p>d包括了y</p><p>可以通过:set 命令来调整vim的设置</p><p>如ic是不管大小写</p><p>hls是高亮搜索</p><p>is是实时搜索</p><p>通过在前面加no可以反向设置</p><p>:help可以获取帮助文档，会在上方打开，通过Ctrl+W可以切换窗口</p><p>:help 文档名 可以打开对应的帮助文档</p><p>通过修改.vimrc可以调整vim的设置</p><p>在命令中可以用tab补全，或者用Crtl+D来显示所有待选项</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bitset </title>
    <link href="/hide/bitset/"/>
    <url>/hide/bitset/</url>
    
    <content type="html"><![CDATA[<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><p>bitset一般用来处理01字符串。除了下述操作还可以互相进行位运算。拥有非常高的常数级优化。</p><p><img src="/image/bitsetUntitled.png" alt="Untitled"></p><p><img src="/image/bitsetUntitled%201.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO库 </title>
    <link href="/hide/IO%E5%BA%93/"/>
    <url>/hide/IO%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><p>标准库定义了一些操纵符来修改流的格式状态。</p><p>由于流是一个对象，操纵符实际上是修改了流的状态，因此它是持久的，比如cout就是ostream的一个实例，因此会一直保持着这种改变，因此我们最好在改变流的状态后，使用完后再改回去，因此大部分操作符都是成双成对的。而一类的操作运算符，比如进制，后一个操作符的状态会覆盖前一个操作符的状态。</p><p>实际上这些操纵符是函数，参数是一个流，通过类似输出的方式调用这些函数来改变流的状态。</p><p><img src="/image/IO%E5%BA%93Untitled.png" alt="Untitled"></p><p><img src="/image/IO%E5%BA%93Untitled%201.png" alt="Untitled"></p><p>当需要控制小数精度的时候，可以使用cout.precision(x)或者cout&lt;&lt;setprecision(x)的方式。</p><h3 id="控制留白"><a href="#控制留白" class="headerlink" title="控制留白"></a>控制留白</h3><table><thead><tr><th>left</th><th>左对齐输出</th></tr></thead><tbody><tr><td>right</td><td>右对齐输出</td></tr><tr><td>internal</td><td>左对齐符号，右对齐值</td></tr></tbody></table><p><img src="/image/IO%E5%BA%93Untitled%202.png" alt="Untitled"></p><h3 id="未格式化的输入输出"><a href="#未格式化的输入输出" class="headerlink" title="未格式化的输入输出"></a>未格式化的输入输出</h3><p>上述的都是格式化的输入输出，也就是根据读取或写入的类型来格式化。而未格式化就是将其当做无意义的字符来处理。</p><p><img src="/image/IO%E5%BA%93Untitled%203.png" alt="Untitled"></p><p>时常我们需要读取一个字符才知道我们是否应该现在读取它，这可以通过后三个函数来实现。</p><p>但标准库并不保证能连续调用putback或unget。</p><p>另外，get和peek读取时读取的都是将其作为int读取（将char转换为unsigned char，最后再转为int），为了留出一些字符来表示文件尾，比如标准库用负值表示文件尾，而cstdio用EOF来表示文件尾。</p><p><img src="/image/IO%E5%BA%93Untitled%204.png" alt="Untitled"></p><p><img src="/image/IO%E5%BA%93Untitled%205.png" alt="Untitled"></p><p>如果在gcount前调用了peek、unget或putback，那么它的返回值为0。</p><blockquote><p>少使用这些底层函数，很容易出错。比如在一台char被实现为unsigned char的机器上，cin.get()读到的EOF就永远不再是EOF了，如果用char存储的话。</p></blockquote><h3 id="流的随机访问"><a href="#流的随机访问" class="headerlink" title="流的随机访问"></a>流的随机访问</h3><p>虽然std中所有的流都支持随机访问，但是一般只有文件流和字符串流是真正有效的。</p><p><img src="/image/IO%E5%BA%93Untitled%206.png" alt="Untitled"></p><p>不管在什么情况下，一个流中都只有一个标记，即便这个流有两个流在读，并且读和写共享同一个标记，因此时常需要seek来重置。</p><p>off可正可负表示方向。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>concept </title>
    <link href="/hide/concept/"/>
    <url>/hide/concept/</url>
    
    <content type="html"><![CDATA[<h1 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h1><p>concept实际上就是一种类型萃取，只不过更加便捷。在定义完一个concept后，任何一个concept<T>就是一个bool值，0就是不满足，1就是满足，而当将其作为模板类型参数的类型的时候，就会只允许满足的进行匹配这个T。</p><p>在定义的时候可以直接用以前的类型萃取来进行赋值，或者使用stl里面定义的一些concept，另外，还可以执行定义这个concept。</p><p>如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">template&lt;typename T&gt;<br>concept con=<span class="hljs-title function_">require</span>(<span class="hljs-params">param</span>)&#123;<br>some code<br>&#125;<br></code></pre></td></tr></table></figure><p>假如说这些code不会因为这个T而产生任何问题(我不知道这个问题是怎么个定义法，至少报错的肯定算是问题)，那么require就会为真，否则为假。</p><p>另外，concept之间还可以合取和析取。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>module </title>
    <link href="/hide/module/"/>
    <url>/hide/module/</url>
    
    <content type="html"><![CDATA[<h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>module是一个管理整体隔离和联系的概念。</p><p>当要引入系统库的时候，应该要使用import &lt;库&gt;;</p><p>如果使用include，那么需要写在全局模块之后，即module;后和私有模块之前。</p><p>后接私有模块module 模块名;</p><p>而模块名后面随便写就好了。</p><p>其中，为了让其他的模块能使用，首先需要将私有模块export并将其中想要export的部分export，可以通过export{…}来实现。</p><p>当要使用的时候，只需要import模块名即可。</p><p>另外，可以使用分区模块，即模块名:分区名。这个分出来的模块只能在模块名中的其他部分被import，但是可以在主模块import的时候export，这样当别的文件使用import主模块的时候就能使用这个分区的被export的函数了。</p><p>但是，最好还是不要这样通过多层传递进行操作，不但和模块的概念相违背，编译器未来也可能移除相关的方法。</p><p>并且，实际上相关标准的支持也挺有问题的，编译器不统一，另外，cmake也好像还在内测，我也不会写cmake。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tuple </title>
    <link href="/hide/tuple/"/>
    <url>/hide/tuple/</url>
    
    <content type="html"><![CDATA[<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p>tuple是类似pair的一种模板，只不过它可以包含任意多个变量，类似于结构体，不过这个结构体没名字，其中的每一个部分也没有名字。</p><p>不像pair不需要头文件，tuple必须include<tuple>。</p><p>tuple的成员的数目在定义的时候就固定了。</p><p><img src="/image/tupleUntitled.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>命名空间 </title>
    <link href="/hide/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/hide/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>每个库会定义大量的全局名字，而这不可避免的会发生冲突，放在全局命名空间中会造成命名空间污染。</p><p>而这时候就可以使用命名空间，来给每一个部分的名字加一个前缀来避免冲突。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用namespace name{}定义命名空间。可以定义于全局或者其他命名空间里，但不能再函数和类的内部。</p><p>每一个namespace就代表了一个作用域。</p><p>namespace可以被分开来几个部分定义，但只要声明了该namespace，相当于继续在这个namespace里定义，而不是新开一个。这种能够确保我们所需的函数和其他名字只定义一次。</p><p>一般在我们定义的namespace里include，因为这相当于将include里所有东西都放进这个namespace中。</p><p>对于一个在namespace中声明的成员，只能在namespace中或全局作用域中声明定义它，不能在不相关的作用域中定义它。</p><p>模板特例化的声明必须在原命名空间中，在此之后就可以在外面定义它了。</p><h3 id="特殊的命名空间"><a href="#特殊的命名空间" class="headerlink" title="特殊的命名空间"></a>特殊的命名空间</h3><p>全局命名空间，::variable。</p><p>对于嵌套的命名空间，内部的同名会隐藏外部的同名，因为命名空间就是作用域嘛，要访问就必须通过作用域符来限定。</p><p>内联命名空间，只能在第一次声明命名空间的时候进行声明，其中的名字可以被外层命名空间直接使用，一般用于版本控制，但是感觉直接using namespace也可以做到相同的事情。</p><p>未命名的命名空间，其作用域与该命名空间所在的命名空间一致，但很重要的一点是，它不能跨文件，而例如全局作用域可以通过extern来跨文件访问。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>通过namespace name1&#x3D;name2可以为非常长的命名空间声明别名。</p><p>using声明，一次引入一个命名空间的成员，using namespace::name;可以用于全局作用域，局部作用域，命名空间作用域及类作用域中，但在类作用域中时只能指向基类成员。相当于在声明的地方声明了这个名字，当引入的是一个函数时，会引入这个函数的所有重载版本。</p><p>using指示，一次引入一整个命名空间，using namespace name;可用于全局、局部和命名空间作用域中。相当于在声明处所在的命名空间前声明了所有名字。</p><p>因此using指示可能会造成二义性，并且只有在使用这个二义性的名字的时候才会报错，因此尽量少用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//相当于name1所有的名字在这里</span><br>fun&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> name1;<br><span class="hljs-comment">//相当于name2在这里。</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name2;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类、命名空间与作用域"><a href="#类、命名空间与作用域" class="headerlink" title="类、命名空间与作用域"></a>类、命名空间与作用域</h3><p>当调用一个作用域的函数时，不但会在调用处查找，还会在实参的命名空间查找，无论这个实参是引用还是指针，这样一些重载运算符才能找到对应的。</p><p>也正是因此，有的有形参的函数就能被查找到，而有的没有形参的就没能被查找到。</p><p>另外，由于move和forward都是只接受一个右值引用的，可以匹配任何类型，因此最容易引起冲突，因此最好都使用std::。</p><p>当声明一个友元的时候，实际上是将它声明在了最近的外层命名空间，和using指示一样，但是是隐式的，不与这个最近的外层命名空间发生关系，无法调用也不存在覆盖，只与内层的这个命名空间可能会产生覆盖关系。</p><h3 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h3><p>正如前面提到的，由于会检查实参的作用域，因此一些原本不可见的函数也会变得可见，因此这些函数也会加入函数待选列表中。</p><p>当使用using声明引入同名函数时，要么覆盖外层同参同名并扩充函数列表，要么与局部作用域的同名同参函数发生重定义的问题。</p><p>当使用using指示引入同名函数时，最多也只会发生二义性错误，因此使用时指定即可。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理 </title>
    <link href="/hide/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/hide/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>对于一个被throw出的异常，根据调用链一层层向外返回(栈展开)找处理代码，也就是寻找try对应的catch，并将控制权交予这个catch对应的处理代码。当找到最外层也未找到时，直接调用std::terminate()（执行的挺慢的）终止程序。</p><p>由于可能提早退出函数，函数中创建的局部存在的对象需要被销毁，而此时折构函数与其他等等会自动被调用，但如果涉及到了构造函数内部或者动态内存，则需要我们手动进行处理，以确保正确的销毁。</p><p>但如果折构函数本身抛出了异常，那么后续的销毁就不能正常的进行了，所以程序一般需要保证折构函数内部的异常要在折构函数内部处理完成。</p><h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p>实际上，当我们抛出一个异常表达式时，会通过这个异常抛出语句来拷贝初始化一个异常对象，这个异常对象会存在于编译器管理的空间中，在全局都能访问，并在异常被处理后被销毁。</p><p>由于要通过这个表达式进行初始化，因此表达式必须是完全类型的，类的话必须拥有可访问的折构函数和拷贝或移动构造函数。而函数和数组将会被转为指针类型。</p><p>另外，这个表达式不应该是指向局部的指针。且该表达式拷贝时的类型会根据静态编译时的类型而决定，不会因为指向派生类而变为派生类，所以可能会切掉派生部分。</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>catch就像一个函数一样，每次抛出异常，就像是调用catch这个函数，而最终选择哪一个catch来处理，则是根据catch的参数和调用时也就是抛出时表达式的类型。其像函数一样可以使左值引用。一切catch中的操作真的就可以完全当catch时一个函数，除了没有右值引用。</p><p>当进行“函数匹配”时，只允许三种转换，const，派生与基，数组与函数转为指针。</p><p>当catch匹配的类型中存在继承关系，则应该把最派生的类放前面，最基的类放后面。</p><p>catch(…)可以捕获所有异常。</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>有的时候，多个catch会一起用于处理一个错误，如派生类部分处理完交给基类继续处理。此时我们就可以通过throw;来重新抛出，为了能让在这个catch中处理的保留到下面一个catch中，应使用引用。</p><h3 id="初始化列表的try"><a href="#初始化列表的try" class="headerlink" title="初始化列表的try"></a>初始化列表的try</h3><p>由于初始化列表不是函数体内的东西，所有写这个构造函数的时候不能将其异常处理。</p><p>此时可以使用函数try语句块。</p><p>$$<br>returntype\ fun(…)try:初始化列表{}catch…<br>$$</p><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>我们可以使用noexcept来声明函数不会抛出异常，并且，一旦定义就必须在所有声明和定义处声明noexcept，也可以给函数指针声明。</p><p>即便声明了noexcept，编译器也不会去检查该函数是否真的不会抛出异常，因此，一旦一个声明noexcept的函数抛出了异常，程序就会立即终止。</p><p>因此一般用作确认函数不会抛出异常或者我们根本不知道该如何处理异常。</p><p>老版本还有throw()，与noexcept作用与用法一致。</p><p>实际上noexcept也有参数，可以以一个bool作为实参，默认为true。</p><p>可以与noexcept运算符联用，noexcept(函数)，当且仅当该函数里可能会调用的所有函数都被声明为noexcept的时候会返回为true，因此给某一个函数定义noexcept时可以使用noexcept(noexcept(g()))</p><p>当一个指针被声明为noexcept后只能指向noexcept的函数，若没有则都可以指向。</p><p>而若是一个虚函数声明了noexcept则所有的派生都必须noexcept，但派生可以在基类不noexcept的情况下声明为noexcept的。</p><p>拷贝控制函数在合成时也会自动生成一个异常说明，这会根据其所有成员和基类的操作是否承诺了是否不会抛出异常相关。</p><p>折构函数的异常标识和合成折构函数相同。</p><h3 id="异常类层次"><a href="#异常类层次" class="headerlink" title="异常类层次"></a>异常类层次</h3><p><img src="/image/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Untitled.png" alt="Untitled"></p><p>一般情况下我们都会继承这些异常类来实现自己的异常类。</p><p>标准库的异常类仅仅定义了拷贝构造函数、拷贝赋值运算符、徐折构函数和一个名为what的虚成员函数，what返回一个const char*(表示异常的一些信息，也就是throw的时候写的字符串)。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拷贝控制 </title>
    <link href="/hide/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/hide/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>拷贝：在使用一个已有的对象初始化一个新的对象，在初始化，参数传递，返回与列表初始化时会被使用，当且仅当右值的类型与左值相同时或者可以隐式转换时。</p><p>赋值：在使用一个已有的对象赋值一个已有的对象。</p><p>这两种操作分开的原因可能是因为拷贝会申请内存？</p><p>当拷贝控制操作没有定义时，编译器会自动合成。</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>当一个构造函数的形参时自身类类型的引用时，且额外参数有默认值，则是拷贝构造函数。</p><p>由于常常被隐式调用并且（会进行隐式类型转换），因此通常不应是explicit的。</p><p>与默认构造函数不同，即便声明了其他的构造函数，也会进行合成。</p><p>合成拷贝构造函数会将所有非static成员拷贝，拷贝时要么调用类的拷贝构造函数或直接拷贝，对于数组会逐一拷贝。</p><p>若是其不是引用类型，那么传入的过程也需要拷贝初始化，就套娃了，因此必须是引用。</p><p>拷贝初始化对右值要求隐式转换，而直接初始化是显式转换。</p><p>在编译过程中，编译器可能换将拷贝初始化改为直接初始化，但即便如此，拷贝&#x2F;移动构造函数也必须存在且可访问。</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>与拷贝构造函数不同，拷贝赋值运算符是对运算符&#x3D;的重载，一般返回一个左值引用。</p><p>但默认拷贝赋值运算符的内部与默认拷贝构造函数差不多。</p><h3 id="折构函数"><a href="#折构函数" class="headerlink" title="折构函数"></a>折构函数</h3><p>销毁对象的非static成员。</p><p>折构函数包含两部分，函数体与折构部分（销毁元素的部分），其顺序与构造函数完全相反，先执行函数体，再按照声明顺序逆序销毁对象。但折构部分是隐式的。其成员到底如何折构，取决于其类型。如内置类型没有折构函数，因此无需折构。</p><p>当一个引用或指针被销毁时，其对象不会被折构。但是智能指针不同。</p><p>合成的折构函数的函数体实际上就是空的。</p><h3 id="相互的关系"><a href="#相互的关系" class="headerlink" title="相互的关系"></a>相互的关系</h3><p>需要自定义折构函数的肯定需要两个拷贝函数。</p><p>需要自定义两个拷贝函数中的任何一个都一定会需要自定义另一个，但不一定需要自定义折构函数。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>通过&#x3D;default可以显式指定编译器合成函数，当在类内使用时，内联，因此一般在类外使用。</p><p>只有有合成版本的函数能使用default。</p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>由于有一些类中拷贝控制操作没有意义，为了保证不被使用，就需要阻止它。但是当不写的时候，会自动合成，因此必须显式阻止。</p><p>直接给函数加上&#x3D;delete即显式指定了删除。可以被使用于任何函数。</p><p>折构函数不能被删除，若是删除，该类型将不允许定义，但仍然可以动态分配该类型对象，但不能delete，主要针对private声明，const和引用。</p><p>虽然编译器会自动合成默认构造函数和拷贝控制函数，但是若是其数据成员不能默认构造，拷贝，复制或销毁，则合成的函数将被声明为delete。</p><p>在老标准下，通过将拷贝控制函数声明为private并且不进行定义作为删除。</p><h3 id="拷贝控制函数的实现"><a href="#拷贝控制函数的实现" class="headerlink" title="拷贝控制函数的实现"></a>拷贝控制函数的实现</h3><p>拷贝总共有两种语义：</p><p>若是数据成员用指针来存储指向，即使用动态内存的情况下</p><ol><li><p>行为像值，如vector，string等，不共享，各自为独立的个体</p><p> 当拷贝时，先保存右值的临时值，再释放左值内存，后将右值的临时值拷贝给左值，这样保证即便是将其赋给自身也不会出现异常，另外初始化时申请新的内存空间。</p><p> 另外，需要保证异常安全。</p></li><li><p>行为像指针，如shared_ptr，即共享</p><p> 可以使用shared_ptr之类的，或者自己实现引用计数。拷贝时递增右值计数，递减本对象计数，后赋值。并且在任何减计数的情况下，判断是否等于0，若等于0则折构。</p></li></ol><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>swap函数虽然不是必要的，但是却很常用。对于我们自己的类，可以使用std::swap来交换，其相当于是进行了3次拷贝。但是有时拷贝很费时间，因此我们可以自己编写swap交换指针来避免不必要的拷贝。</p><p>当存在类型匹配的swap时，调用swap会调用专用的swap而非标准库的。</p><p>swap可以用于赋值运算符。</p><p><img src="/image/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6Untitled.png" alt="Untitled"></p><p>在swap后，rhs指向原本的this指向的内存，而this指向rhs指向的内存，由于是值传递，因此在结束作用域后rhs将被销毁，其内存被释放。非常完美的执行了赋值操作。</p><p>而且这种方式自动就是异常安全的，且能正确处理自赋值。</p><h3 id="拷贝控制的使用场景"><a href="#拷贝控制的使用场景" class="headerlink" title="拷贝控制的使用场景"></a>拷贝控制的使用场景</h3><ol><li>分配资源的类需要拷贝控制。</li><li>拷贝控制操作中不止要进行拷贝。</li></ol><p>拷贝赋值运算符执行的动作常常在拷贝构造与折构函数中出现，这些公共的部分应该在private中模块化。</p><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>如在vector中，我们时常会将一块内存拷贝到另一块内存中并销毁原内存，这非常的效率低下，因此引入移动。</p><p>此外，由于如IO类与unique_ptr这种存在不能被共享的资源，不允许被拷贝，但是却允许移动（移动并没有创建拷贝。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用就是对右值的引用，使用&amp;&amp;来表示。</p><p>对于一个右值，要么用一个const左值引用要么用一个右值引用来绑定。</p><p>绑定的对象即将要被销毁且没有其他对象，因此可以只有接管其引用对象的资源。</p><p>即便是一个右值引用，也是一个变量，是左值，故不能将右值引用变量绑定到右值变量上。</p><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>返回给定左值对象的右值引用。</p><p>对于原本的左值对象，其原本的值已经被“舍弃”了，要么销毁它，要么给它赋一个新值。</p><p>move在utility中，虽然是标准库的函数，但一般不使用using，而是直接使用std::move来避免潜在的命名冲突。</p><blockquote><p>类似const使用的对函数的关键字noexcept，表示该函数不应该抛出异常。</p></blockquote><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>移动构造函数的形参是一个右值引用。必须保证这个右值引用在函数结束时是无害的，不再指向源对象的。</p><p>不抛出异常的移动构造函数与移动赋值运算符必须标记为noexcept。</p><p>由于移动构造函数若是在中途出现异常，其不能回滚（原有的内存已经被新的值填入了），因此类就会去采用拷贝构造函数（因为原有的元素仍然在内存空间之中）。因此必须使用noexcept来表明其可以安全使用，而不会出现这种问题。</p><h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><p>与拷贝赋值运算符一样，但是参数是右值引用，需要注意的是，与左值引用是const不同，右值引用不使用const。</p><p>必须保证自赋值，释放原有元素与右值引用的无害。</p><p>自赋值时需要特判，因为若是此时释放掉原有的空间，其值就不见了。</p><h3 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h3><p>移动操作必须保证源对象可析构且有效。</p><ol><li>可析构需要源对象不再指向拷贝完的内存。</li><li>有效需要源对象可以被安全的赋予新值，不依赖于源数据。</li></ol><p>当且仅当类没有定义任何拷贝控制成员时，且所有非static成员都可移动，才会自动合成移动操作。</p><p>只有移动操作被显式要求合成时，其才有可能出现delete的情况。</p><p>一种是拷贝函数被定义了而移动函数仅被声明了，第二种是拷贝函数没有被定义但是移动函数不能被生成，即其有成员不能被移动。</p><p>若是移动函数被定义了，那么合成的拷贝函数会被自动delete。</p><h3 id="拷贝与移动"><a href="#拷贝与移动" class="headerlink" title="拷贝与移动"></a>拷贝与移动</h3><p>具体是调用拷贝还是移动函数会根据传入参数时左值还是右值而定。</p><p>若是一个类没有定义移动函数，那么即便是右值引用也会被转换为左值引用并调用拷贝函数。</p><p>若是使用前面的拷贝并交换赋值运算符，在传入时使用拷贝初始化，此时就已经决定了移动或是拷贝，因此该赋值运算符可以既看做拷贝也可以看做是移动。</p><h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h3><p>一般来说，要么析构函数与拷贝函数都定义，要么再多定义移动函数。</p><h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>在大部分情况下，与算法配合使用迭代器都会使用拷贝的方法，因为解引用迭代器会获得一个左值。但是移动迭代器解引用将会生成一个右值引用，此时就会使用移动的方法。</p><p>但由于移动操作会使源对象的情况未定义，因此要谨慎使用move。虽然移动能大幅提升性能。</p><h3 id="移动与拷贝重载"><a href="#移动与拷贝重载" class="headerlink" title="移动与拷贝重载"></a>移动与拷贝重载</h3><p>除去使用在拷贝控制操作上，也可以在普通的函数使用这两种版本的重载，通过传入的参数来决定。</p><h3 id="限定函数的使用"><a href="#限定函数的使用" class="headerlink" title="限定函数的使用"></a>限定函数的使用</h3><p>有的时候对于成员函数，其this与所希望的不符，如赋值时this是右值等，此时可以如const一般在函数后增加&amp;或者&amp;&amp;来限定使用者是左值还是右值，当与const同时出现时，放在const后。</p><p>对于重载函数，若是其中有一个限定了，那么其他的所有的重载版本都要限定。</p><p>通过限定，我们可以通过this的不同而使用不同的函数，使其更加适合。</p><p><img src="/image/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6Untitled%201.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>标准库特殊设施 </title>
    <link href="/hide/%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/"/>
    <url>/hide/%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h1><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p><a href="https://lhish.github.io/hide/tuple">tuple</a></p><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p><a href="https://lhish.github.io/hide/bitset">bitset</a></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a href="https://lhish.github.io/hide/%E6%AD%A3%E5%88%99">正则</a></p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p><a href="https://lhish.github.io/hide/%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a></p><h2 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h2><p><a href="https://lhish.github.io/hide/IO%E5%BA%93">IO库</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则 </title>
    <link href="/hide/%E6%AD%A3%E5%88%99/"/>
    <url>/hide/%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><p>include<regex></p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled.png" alt="Untitled"></p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%201.png" alt="Untitled"></p><p>smatch和ssub_match一般传入regex_match和regex_search记录匹配到的东西。</p><p>使用的正则表达式语言是ECMAScript。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%202.png" alt="Untitled"></p><p>正则表达式在运行时也会出现错误，抛出异常。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%203.png" alt="Untitled"></p><p>另外，尽量避免少的创建或拷贝正则表达式，这很费时间。</p><p>根据输入序列类型的不同，需要使用不同正则表达式类。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%204.png" alt="Untitled"></p><p>可以通过迭代器来遍历所有找到的字符串。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%205.png" alt="Untitled"></p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%206.png" alt="Untitled"></p><p>一般用一个空的迭代器来表示正则迭代器的尾后迭代器。</p><p>每一个正则迭代器还有两个成员prefix()和suffix()来获取前后文。平常最好对前后文进行长度截断一下。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%207.png" alt="Untitled"></p><p>对于正则表达式中的每一个不确定匹配的部分，都会使用括号括起来，这这一部分就是子表达式。通过str(n)可以获取第n个子表达式，当n&#x3D;0时，就是获取整个表达式。</p><p>有时，我们对于每个子表达式的要求或者他们互相的关系并不能在正则表达式中表达出来，此时我们就需要进行自匹配操作来验证。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%208.png" alt="Untitled"></p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%209.png" alt="Untitled"></p><p>fmt就是一个表示替换规则的字符串。而mft是一个标志，表示方式，如下。</p><p><img src="/image/%E6%AD%A3%E5%88%99Untitled%2010.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模板与泛型编程 </title>
    <link href="/hide/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/hide/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>泛型编程是在编译时将类型确定，而OOP是在程序运行之前都不知道类型。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>有两种模板变量。</p><p>方式都是在函数前增加$template\ &lt;模板参数列表&gt;$。</p><p>类型参数。用typename来声明。template &lt;typename name1,typename name2,…&gt;</p><p>非类型参数。就是一个在模板中使用的常量。类型只能是整型或者引用或指针。定义与普通定义一样，除了在template中。</p><p>需要在调用函数的时候可以通过输入数据能够推断出模板参数或者直接显式声明模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> N,<span class="hljs-type">unsigned</span> M&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N],<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>inline和constexpr都是在template后的。</p><h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>由于模板函数只有在调用的时候才会生成实例，而此时编译器必须知道函数的定义是什么，因此一般模板类的声明和定义放在一起。</p><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>不像函数模板可以推断，必须显式声明。</p><p>类的每一个实例会生成一个独立的类。</p><p>但是只有当类型不同时才是不同的类，如果是相同的，会发现静态变量是通用的。</p><p>而对于成员函数，若是声明在外部，则由于其也有各自对应类型版本，因此前要加template，并且，由于已经是类的一个成员函数，而不同类型版本的类是不同的，因此也要指定类的版本，也就是class<T>.</p><p>但即便类模板已经被实例化了，其成员函数也只会在被使用时才会被实例化。</p><p>当在类模板中使用自身类型时，就无需再指定版本，也就是模板实参，也就是不用加<T>。</p><p>而当且仅当类名出现后，才进入了类模板的作用域，因此，返回类型必须提供类型实参。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在声明友元前必须声明类模板，仅需声明即可。</p><p>而若是希望两个模板类的友元关系一一对应，那么在声明友元的时候使用相同的模板实参即可，若是希望对应其所有的实例，即所有的版本，那么使用不同的模板实参即可。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以为模板类类型用using来声明别名，如果要使用T，那么同样需要前加上template…</p><h3 id="模板实参"><a href="#模板实参" class="headerlink" title="模板实参"></a>模板实参</h3><p>模板实参会隐藏外层同名，但不能复用，也不能在类内复用。</p><p>模板实参的名字并没有任何含义，在同一模板类中，成员函数定义时声明模板参数无需与类声明时相同，只需类型与个数相同即可。</p><p>模板实参也可以有默认实参，使用方法与普通的函数默认实参一致。</p><p>但即便模板实参全有默认参数，实例化时仍然要使用尖括号表示使用模板类，如class&lt;&gt; param.</p><p>由于模板类可能并没有实例，当访问类的static变量和类型成员时都使用的是作用域符，因此无法分辨。因此，c++默认访问的是变量，除非前面使用typename来修饰来表示这是类的类型成员。</p><h3 id="模板成员函数"><a href="#模板成员函数" class="headerlink" title="模板成员函数"></a>模板成员函数</h3><p>普通类和模板类中的成员函数都可以模板化。这里指的模板类中的成员函数模板化是指使用不同的模板实参，如在初始化时使用不同容器提供的实际上类型一致的迭代器。</p><p>在类外定义时，先template模板类，后template模板函数。</p><p>模板成员函数的模板实参会在调用的时候根据参数进行推断。</p><h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当一个模板类在多个文件中被实例化的时候，就会产生多个实例，而此时我们可以通过显式实例化的方式来控制这一点。</p><p>实例化声明：extern template declaration</p><p>实例化定义：template declaration</p><p>在某个特定的文件中使用实例化定义来实例化模板类的一个版本，后当我们需要在其他文件中使用这个实例化时实例化声明一下即可。需要注意的是，实例化定义只能有一个，不然实例化声明并不知道指向的是哪一个实例化。</p><p>显式实例化会实例化模板类的所有成员，而不像隐式实例化只当在使用的时候才实例化对应的。</p><h3 id="灵活与效率"><a href="#灵活与效率" class="headerlink" title="灵活与效率"></a>灵活与效率</h3><p>当某个函数作为参数传入时，调用时需要跳转，但对于编写者很灵活。</p><p>当某个函数作为可调用对象作为模板参数时，其将在实例化时就绑定了，虽不灵活，但效率更高。</p><h2 id="模板参数判断"><a href="#模板参数判断" class="headerlink" title="模板参数判断"></a>模板参数判断</h2><p>除了一般的是什么类型就判断为什么类型以外，一部分还可以进行隐式类型转换。</p><ol><li>const转换：忽略顶层const或转为const</li><li>在非引用的情况下将数组转为指针</li></ol><p>当使用多模板实参的时候，若都用相同的形参，对实参的要求就有点高了，所以可以在多模板实参的时候使用不同的形参。</p><p>当模板形参与普通形参同时出现时，普通形参仍遵循原来的规则(如类型转换)。</p><h3 id="显式化指定"><a href="#显式化指定" class="headerlink" title="显式化指定"></a>显式化指定</h3><p>当模板形参无法判断出类型时，如函数返回值是一个模板形参时，就必须显式指定。</p><p>fun<params>(params)。</p><p>但是，需要注意的是，params从左向右一一赋值，因此最好把形参中考前的作为推断不出的形参。</p><p>当显式化指定后，该形参就变成了普通形参，遵循原来的规则。</p><p>当可以通过auto+decltype推断来获取返回类型时，可以使用尾置返回。</p><p>有时候一些类型难以推断，如将一个引用类型转为一个普通类型，此时可以使用std的<type_traits>的类型转换模板。</p><p><img src="/image/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8BUntitled.png" alt="Untitled"></p><p>使用方法，typename fun<T>::type variable。</p><p>当且仅当可以转换的时候才会进行，否则返回原类型。</p><p>模板函数不能直接作为函数指针传入重载函数中，会发生二义性的问题。必须先行通过函数指针的类型来间接确定或fun<T>来直接确定。</p><h3 id="推断引用"><a href="#推断引用" class="headerlink" title="推断引用"></a>推断引用</h3><ol><li><p>保留并合并底层const。</p></li><li><p>会正常解析引用。解析的方式和类型别名一致。在这两种情况下将会产生引用折叠的问题，也就是对引用的引用。只有右值引用的右值引用会折叠为右值引用，其他都会被折叠为左值引用。</p><p> 因此对于一个右值引用的模板形参，可以传入左值引用将其转变为左值引用。或者相反。</p><p> 上述指的都是函数的实参。</p><p> 但是一旦涉及到了引用折叠就会很麻烦，因为这个模板形参即可能是普通类型的，也可能是引用的。</p></li></ol><p>static_cast除了用于合法的类型转换，还可以将一个左值转换为一个右值引用，这就是move的实现。</p><p>但是对于普通的函数传参，引用折叠就并不会起作用，甚至会报错。</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>转发就是通过一个函数将实参传递给另一个函数来调用。</p><p>在此处我们仅讨论转发函数是一个模板函数。</p><p>在转发的时候，我们希望保留原来实参的一些属性，如左右值引用与const。</p><p>此时，我们可以让转发函数的参数都为右值引用来通过引用折叠来保留所有属性。这当被转发的函数的参数为普通的参数或左值引用的时候非常有效，但是当为右值引用的时候，由于右值引用本身就是一个左值，因此不能将右值引用传递给接收右值引用的。</p><p>至于为什么能用std::move的返回值来给右值引用赋值，是因为它返回的事constexpr type&amp;&amp;，是一个右值，而非普通右值引用的左值。</p><p>此时我们可以使用forward，当面对普通参数和右值引用，forward会像move一样返回一个constexpr的右值引用，而面对左值引用，由于引用折叠，会返回一个左值引用。</p><h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><h3 id="函数推断"><a href="#函数推断" class="headerlink" title="函数推断"></a>函数推断</h3><p>所有可以合理实例化的模板函数加入待选函数中。</p><p>选择其中最匹配的待选函数。如果匹配度差不多，则先选择非模板函数。如果没有非模板函数，则选择其中特例化最高的，否则二义性。</p><p>重载模板可以用于对于指针和普通变量个性化处理，指针形参对于指针更加特化。</p><p>在定义任何函数前最好声明所有重载函数(包括模板)。</p><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>可变数目的参数被称为参数包，分为两种，模板参数包与函数参数包，模板参数包就是函数参数包中参数的类型。</p><p>template&lt;typename knowntype,typename…args&gt;</p><p>type fun(knowntype param,(const)(*)args(&amp;)…changeableparams)</p><p>…代表接下来是可变参数。</p><p>这两个参数包都是会根据调用来生成不同的实例，并可通过sizeof来获取args和changeableparams的个数。</p><p>一般情况下，可变参数模板函数都是递归进行的，每一层都处理一个元素。</p><p>当处理完第一个元素后，希望继续传入下一层，使用fun(changeableparams…)。另外，一般会有一个非可变参数模板来作为最终的终止，因为非可变参数模板更特化，所以会调用这个，然后就不会继续递归了。</p><p>…的意思是对一个参数包进行扩展。</p><p>扩展就是将这个参数包展开为param1,param2…的形式。</p><p>当我们希望展开的同时对每一个参数都做相同的一个函数操作时，需要func(params)…，将…放在外面，对整体进行扩展，但扩展完后必须作为其他函数的参数？以及这个func必须是非模板函数？</p><p>当我们希望无损失地转发参数包的时候，直接在模板函数参数中使用右值引用，并在转发时使用forward<args>(changeableparams)…即可。此时，…既会扩展args也会扩展changeableparams。</p><h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>有时候有一些类型需要特殊化处理，这时候就可以使用模板特例化。像重载一样，但是需要在函数前加上template&lt;&gt;，即便所有的模板参数都特例化了，也需要保留&lt;&gt;来表示这是一个模板，可以部分特例化，将特例化的模板参数用实际的类型替代即可，但书上说只有类模板可以部分特例化。</p><p>特例化的实质并不是重载一个实例化的实例，而是就是实例化了一个特殊的模板版本。</p><p>特例化的版本必须总是跟着原模板（在同一个作用域内），否则，即便不存在特例化的版本，编译器也不会报错，直接调用原模板了。</p><p>当特例化类的时候，在类名后加上&lt;&gt;里面输入特例化后的实参即可，实际上就是把template里的搬过来然后将其中要特例化的改掉，可以只是特例化一部分，比如可它加上&amp;或者&amp;&amp;等等。</p><p>除了特例化一整个类之外，我们也可以特例化其中的成员。特例化时只需要将&lt;&gt;中的内容更改即可，方法与特例化一整个类一致。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>特殊工具与技术 </title>
    <link href="/hide/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    <url>/hide/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊工具与技术"><a href="#特殊工具与技术" class="headerlink" title="特殊工具与技术"></a>特殊工具与技术</h1><p><a href="https://lhish.github.io/hide/%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">控制内存分配</a></p><p><a href="https://lhish.github.io/hide/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%ABRTTI">运行时类型识别RTTI</a></p><p><a href="https://lhish.github.io/hide/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benumeration">枚举类型enumeration</a></p><p><a href="https://lhish.github.io/hide/%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88">类成员指针</a></p><p><a href="https://lhish.github.io/hide/%E5%B5%8C%E5%A5%97%E7%B1%BB">嵌套类</a></p><p><a href="https://lhish.github.io/hide/union">union</a></p><p><a href="https://lhish.github.io/hide/%E5%B1%80%E9%83%A8%E7%B1%BB">局部类</a></p><p><a href="https://lhish.github.io/hide/%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7">固有的不可移植的特性</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用于大型程序的工具 </title>
    <link href="/hide/%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <url>/hide/%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="用于大型程序的工具"><a href="#用于大型程序的工具" class="headerlink" title="用于大型程序的工具"></a>用于大型程序的工具</h1><p><a href="https://lhish.github.io/hide/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></p><p><a href="https://lhish.github.io/hide/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a></p><p><a href="https://lhish.github.io/hide/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF">多重继承与虚继承</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重载运算与类型转化 </title>
    <link href="/hide/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/"/>
    <url>/hide/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="重载运算与类型转化"><a href="#重载运算与类型转化" class="headerlink" title="重载运算与类型转化"></a>重载运算与类型转化</h1><p>重载运算符的名称是operator+运算符。</p><p>重载运算符的参数个数与其作用的运算对象数量一样多。除了operator()之外其他的重载运算符都不允许有默认参数。</p><p>当一个重载运算符是成员函数时，this会被绑定到第一个参数上，因此成员函数的重载运算符会少一个参数。</p><p>不能对内置类型进行重载，但是若是同时对内置类型和非内置类型进行操作，这是可行的。</p><p>+，-，*，&amp;四种操作同时是一元和二元。</p><ol><li>+一元表示正，二元表示加。</li><li>-一元表示负，二元表示减。</li><li>*一元表示解引用，二元表示乘。</li><li>&amp;一元表示取地址，二元表示与。</li></ol><p>这些重载的运算符的优先级与结合律会和内置运算符一致。</p><p><img src="/image/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96Untitled.png" alt="Untitled"></p><p>虽然可以直接使用运算符来调用，但也可以像函数调用一样调用。要注意的是，函数的名称是有operator的，且成员函数要用点运算符来调用。</p><h3 id="不重载的运算符"><a href="#不重载的运算符" class="headerlink" title="不重载的运算符"></a>不重载的运算符</h3><p>一般情况下，不应该重载逗号，取地址，逻辑与和逻辑或运算符。逗号和取地址c++已经定义了其作用于类的特殊含义。逻辑与和逻辑或无法保留求值顺序和短路求值属性。</p><p>算术运算符返回右值，赋值运算符返回左值。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般只有操作的含义对于使用者非常明了的时候才使用重载运算符。</p><h3 id="成员函数与非成员函数"><a href="#成员函数与非成员函数" class="headerlink" title="成员函数与非成员函数"></a>成员函数与非成员函数</h3><p>一般来说，</p><p>成员函数：&#x3D;,[],(),→,复合赋值,递增,递减,解引用。</p><p>非成员函数：算术，相关性，关系，位运算符。</p><p>具有对称性，也就是即便左右变量互换也要成立，的函数用非成员函数。</p><h3 id="输出运算符"><a href="#输出运算符" class="headerlink" title="输出运算符&lt;&lt;"></a>输出运算符&lt;&lt;</h3><p>非成员函数，由于首参不是类对象。一般要被声明为友元。</p><p>形参：</p><ol><li>ostream引用</li><li>类对象的引用常量</li></ol><p>返回值：ostream引用</p><p>输出运算符不应该控制格式，要给予用户自由度，如不应该输出换行。</p><h3 id="输入运算符"><a href="#输入运算符" class="headerlink" title="输入运算符&gt;&gt;"></a>输入运算符&gt;&gt;</h3><p>非成员函数，由于首参不是类对象。一般要被声明为友元。</p><p>形参：</p><ol><li>istream引用</li><li>类对象的引用</li></ol><p>返回值：istream引用</p><p>相较于输出运算符不需要检查错误，输入需要检查是否发生IO错误，当发生错误时需要将读入对象设为默认状态，保证其正确性，因为在发生错误时可能已经读入了一部分了。</p><p>一般在所有数据读入完成后，数据使用之前检查istream来判断是否发生IO错误，因为我们并不在意哪一个出了问题。</p><p>即便IO没有发生错误，但读入格式或者其他出错了也可以通过标识istream的状态来标示错误。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>非成员函数，允许对左侧和右侧对象进行转换。</p><p>形参：常量引用</p><p>返回值：局部变量的副本</p><p>一般使用复合赋值运算符来实现算术运算符，而非相反。</p><h3 id="关系运算符（一般要const）"><a href="#关系运算符（一般要const）" class="headerlink" title="关系运算符（一般要const）"></a>关系运算符（一般要const）</h3><p>非成员函数，允许对左侧和右侧对象进行转换。</p><p>形参：常量引用</p><p>返回值：bool类型</p><p>相等运算符应该具有传递性。在实现上，可以return一个判断等于的&amp;&amp;长表达式。</p><p>一般来说实现小于运算符，其他调用即可。需要保证当两个对象不相等时一个应该小于另一个，错误的情况比如多个数据成员而小于运算符只比较其中一两个，而&#x3D;&#x3D;运算符保证全部成员相等。</p><p>当且仅当有唯一一种逻辑可靠的小于定义且小于运算符与&#x3D;&#x3D;运算符相符时定义小于运算符。</p><h3 id="赋值运算符-（复合赋值运算符）"><a href="#赋值运算符-（复合赋值运算符）" class="headerlink" title="赋值运算符&#x3D;（复合赋值运算符）"></a>赋值运算符&#x3D;（复合赋值运算符）</h3><p>成员函数（复合赋值运算符有时候会被定义为非成员函数）。除去移动与拷贝赋值运算符，还有其他的赋值运算符。如参数时initializer_list的列表赋值。</p><p>形参：常量引用</p><p>返回值：自身的引用</p><h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符[]"></a>下标运算符[]</h3><p>成员函数。一般会定义一个常量版本和一个非常量版本。</p><p>形参：std::size_t(int)</p><p>返回值：(常量)引用</p><h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>成员函数（虽然允许是非成员函数）。</p><p>前置</p><ul><li>形参：无</li><li>返回值：对自身的引用</li></ul><p>后置，一般调用前置运算符来实现</p><ul><li>形参：<strong>一个无用的int</strong>，用于区分前置和后置，由于无需用到，因此一般不用命名。</li><li>返回值：自身改变前的值</li></ul><h3 id="成员访问运算符（const）"><a href="#成员访问运算符（const）" class="headerlink" title="成员访问运算符（const）"></a>成员访问运算符（const）</h3><p>成员函数。</p><p>解引用（允许是非成员函数）</p><ul><li>形参：无</li><li>返回值：引用</li></ul><p>箭头（调用者：指针或重载了箭头的类对象）</p><ul><li>形参：无</li><li>返回值：指针</li></ul><p>箭头运算符不管怎么重载，只能改变其是从哪个对象中获取成员，但其获取成员这个本质属性不会变。</p><h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符()"></a>函数调用运算符()</h3><p>成员函数。</p><p>形参：任意</p><p>返回值：任意</p><p>当一个类定义了调用运算符，那么类的成员被称为函数对象。在定义对象后可以像函数一样调用。</p><p>其与函数的最大区别就在于其能存储变量。在初始化时或是后续修改能定制它的行为。</p><p>一般作为泛型算法的实参对象。如</p><p><img src="/image/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96Untitled%201.png" alt="Untitled"></p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>lambda生成了一个未命名(内部命名)的类，这个类只有一个函数，即调用运算符重载。</p><p>而对于捕获参数，如果有值传递，就相当于这个类有一个构造函数，这个构造函数的参数就是值传递的参数，初始化其中的局部变量，即便。若是引用传递，那么程序会保证lambda使用时其存在性。</p><p>其不会含有默认构造函数、赋值运算符及折构函数。但拷贝&#x2F;移动构造函数不一定。</p><h3 id="标准库中的函数对象"><a href="#标准库中的函数对象" class="headerlink" title="标准库中的函数对象"></a>标准库中的函数对象</h3><p>在<functional>中定义了一些重载了调用运算符的函数对象。</p><p><img src="/image/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96Untitled%202.png" alt="Untitled"></p><p>虽然比较指针是不合法的，但是这些函数对象会对指针所指向的对象进行操作。</p><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>可调用对象包括：函数、函数指针、lambda、bind、重载了函数调用运算符的类</p><p>这些对象的类型不一而定，所以即便他们享有着同样的调用形式（即形参相同，返回值相同），他们的类型名也会不同。因此我们不能把它们放在同一个容器中，并通过轻松的方式进行选取调用，如一个计算器中几种运算分别使用了不同的可调用对象实现，但却希望放在同一个函数表中。</p><p>在<functional>中function被定义。</p><p><img src="/image/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96Untitled%203.png" alt="Untitled"></p><p>function的类型就是调用形式(return type(param_list type) )，可以使用直接初始化也可以拷贝赋值。</p><p>当存在重载函数时，虽然其调用形式是不同的，但通过函数名是判断不出来的，因此可以通过函数指针的方式来间接特指。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>一种是通过隐式调用构造函数的方式进行类型转换。</p><p>另一种是通过定义类型转换运算符，是将自定义类型转换为另一种类型，与构造函数的转换正好相反。</p><p>形式：operator type() const;</p><p>这里的type只要是能返回的类型就是可行的。</p><p>除非两个类型之间存在明确的一一对应关系，不然最好不要定义类型转换，而是通过非成员函数从中提取信息。</p><p>另外，如果定义了一些类型转换，其可能会在不知情的情况下隐式发生，发生意想不到的情况。</p><p>因此可以通过explicit限定其必须显式执行。但若是该表达式用作条件判断，其必然会被隐式转换为bool而不管是否explicit。也正是因此，由于bool转换一般用于条件中，因此一般会explicit。</p><h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><ol><li>若是在两个类中都定义了互相的类型转换运算符和转换构造函数，那么当从一个类转为另一个类的时候既可以调用A的类型转换运算符也可以使用B的转换构造函数，产生了二义性。</li><li>当类定义了多个转换规则（无论是类型转换运算符还是转换构造函数），若是其转得的类型是平级的，例如double和int，那么若是其再次需要转换为另一种类型，例如说long，则会产生二义性，不知道该先转换为哪种类型。</li></ol><p>类型转换设计很麻烦。为了避免上述的二义性，要</p><ol><li>不要令两个类执行相同的类型转换</li><li>若是定义了目标是内置算术类型的类型转换<ol><li>不要定义接受算术类型的类型转换，让这个算数类型转换为本类型再操作</li><li>不要定义多种到算术运算符的类型转换，让标准类型转换来执行这个过程</li></ol></li></ol><p>当两个重载函数的参数类型都定义了某个类型到其的转换，那么也会发生二义性。可以通过显式转换来消除二义性。但这也表示了程序的设计不足。</p><p>但即便其定义的转换类型是不同的，double和int，也会由于存在标准类型转换而使得两个重载都是可以的，产生二义性。</p><p>由于重载运算符也是重载函数，其在匹配时会和标准的运算符或者非成员函数可能会产生二义性。如A定义了与int的双向类型转换，但是，同样重载了运算符+，那么此时使A+1就会发生二义性，不知道该调用int+int还是A+A。</p><h3 id="自定义运算符重载"><a href="#自定义运算符重载" class="headerlink" title="自定义运算符重载"></a>自定义运算符重载</h3><p>格式：$return_type\ operator””\ operator_name(){}$</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>随机数 </title>
    <link href="/hide/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/hide/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled.png" alt="Untitled"></p><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%201.png" alt="Untitled"></p><p>当种子相同的时候，生成的随机数序列也是相同的。因此需要随机数种子，一般用time(0)作为随机数种子。</p><p>一个常用的随机数引擎是std::mt19937，c++默认的default_random_engine就是这个。</p><blockquote><p>time(ptr)，ptr指向用于写入时间的数据结构。</p></blockquote><p>但大部分情况下，我们希望生成的随机数与engine生成的分布和范围不一样。</p><p>而distribution就是将一个数转换为特定分布和范围内的随机数。</p><p>一般是调用distribution(engine)来获取随机数。</p><p>而通过把随机种子定下来，我们也可以在多次调试过程中获得一个相同的随机数序列。</p><p>而如果有一个局部的引擎或分布，我们应该让其变为static的，否则每次调用的时候会生成相同的序列。</p><h3 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h3><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%202.png" alt="Untitled"></p><p>分布都是模板，接受一个模板参数表示生成的类型。不填这个模板参数代表使用默认类型。</p><p>下面是各种各样的引擎和分布。</p><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%203.png" alt="Untitled"></p><h3 id="分布-1"><a href="#分布-1" class="headerlink" title="分布"></a>分布</h3><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%204.png" alt="Untitled"></p><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%205.png" alt="Untitled"></p><p><img src="/image/%E9%9A%8F%E6%9C%BA%E6%95%B0Untitled%206.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象程序设计 </title>
    <link href="/hide/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/hide/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><p>数据抽象：将接口与实现分离。</p><p>继承：定义相似的关系并建模</p><p>动态绑定：忽略相似类型的区别，统一进行使用，可以使用基类指针或引用指向派生类对象</p><h3 id="基类与派生类"><a href="#基类与派生类" class="headerlink" title="基类与派生类"></a>基类与派生类</h3><p>基类一般要定义一个虚折构函数。</p><blockquote><p>派生类的折构函数会先调用自己的函数体，再调用基类的折构</p></blockquote><p>当我们希望进行动态绑定时，就应该将函数声明为虚函数，否则在编译时就会被解析。</p><p>派生类重写的时候可以通过override来显式表示重写（写在函数的最后，const后）。</p><p>派生类可以访问public和protected（只有自己和派生类能访问）的基类成员，而不能访问private的基类成员，但是可以通过基类的可访问成员函数类访问私有成员。</p><p>通过使用派生类列表来继承。格式：</p><p>class classname : 访问说明符 derivated_classname</p><p>访问说明符就是public，protected和private。</p><p>对于所有需要重写的成员都需要进行声明。</p><p>如果某个派生类对于基类的虚函数并没有进行重写，则会直接使用基类的函数。</p><p>虽然派生类继承了基类中的一部分成员，但是每个类自身控制它对应的初始化过程。在构造函数中原本是使用构造函数初始值列表来初始化，但其中属于基类的成员可以直接使用基类的构造函数来初始化。方式与其他构造函数初始值列表一致，如classname(param)。</p><p>而其调用的基类构造函数由编译器决定。当初始化时，基类部分先被初始化，然后再是派生类的部分。</p><p>在作用域方面，在使用派生类作用域的时候其外层就已经套了一层隐式的基类作用域，因此可以直接使用基类成员。</p><blockquote><p>需要注意的是基类的成员虽然可以被直接调用并赋值，但是使用的时候最好都调用基类的函数类对基类的成员进行控制与赋值，而不要直接在派生类中对基类进行控制。</p></blockquote><p>基类的静态成员即便被继承了也是通用的，但仍然遵循访问说明符的继承规则。</p><p>派生类在声明时不需要声明继承。</p><p>通过在类名后加final关键字可以防止继承的发生，也可以用在成员函数上。</p><p>派生类可以作为基类继续继承，派生类的基类是派生类的派生类的间接基类，而基类是这个派生类的直接基类。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>派生类对象是由多个对象组成的，派生类独有的成为组成一个对象，其继承的每一个基类对象的成员各自组成一个基类对象，这些存储是对象内的成员存储连续，而对象之间则不一定。</p><p>正是由于派生类中存在基类对象，因此可以将其作为基类来使用，而且，其成员一定是大于等于基类对象成员的，这很显然。也就是派生类可以向基类进行类型转换（会隐式发生），只能转换四种：指针到指针，引用到引用，对象到引用，对象到指针。</p><p>智能指针也存在这一转换。</p><p>而当我们这么做的时候，我们并不在乎对象是派生类还是基类。</p><p>而此时，这一类型是动态类型，有且仅有基类指针和引用可能是动态类型，而其他都是静态类型。</p><p>但不存在从基类向派生类的转换，或者说不存在隐式转换，可能存在显式的，因为可能访问不存在的成员，需要注意的是，即便一个基类指针指向了派生类，也不能将其赋值给一个派生类指针，因为编译器并不知道这件事，除非使用static_cast。</p><p>但上述的都是基类的指针与引用，而对象之间实际本身是不存在转换的。除非像普通的转换一样定义构造函数或赋值运算符，而其原始的合成版本会像普通的类型转换一样一一赋值并会把派生类多余的部分切掉。</p><p>在类型转换中可能存在访问权限的问题。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>由于虚函数是动态绑定的，因此并不知道会不会使用基类的虚函数本身，即便我们知道其并不会被使用，但仍然要对它进行定义。</p><p>当且仅当对有派生类的指针或引用调用虚函数的时候会进行动态绑定，而且也只有在调用的时候会发生。</p><p>虚函数在派生类中也将被隐式声明为虚函数。并且其形参表，返回类型都必须与原虚函数一致。<strong>除了当虚函数返回的是类本身的指针或引用</strong>，假设基类返回自己的指针，而派生类可以返回派生类自己的指针，不过这只有在派生类到基类的类型转换是可行的时候可用。</p><p>由于当形参表不同时会认为不是继承，因此可以通过override说明符来显式的表示这是重写来让编译器来检查这个函数是否重写了某个函数，而不发生前面的问题。</p><p>当虚函数中存在默认实参时，其调用时默认实参的值会依据<strong>静态类型</strong>（也就是基类），而非派生类的默认实参值。</p><p>这一动态绑定可以被指定为静态，在调用运算符后，函数之前加上基类的作用域或其他作用域来指定调用的虚函数版本。常常用于派生类的成员函数中。若在派生类版本的虚函数中需要调用基类版本的虚函数，那么若是不指定，则会调用自身版本，造成无限循环。</p><p>派生类是否能重写虚函数与虚函数访问权限无关。</p><p>函数模板不能被声明为 <code>virtual</code>。</p><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>有时我们完全不希望用户使用基类或基类中的某个成员函数，这个基类是抽象的，用来方便派生类的实现的，是抽象基类。</p><p>此时我们可以将这个成员函数定义为纯虚函数。定义的方式是在它最后增加&#x3D;0。</p><p>虽然我们可以对纯虚函数提供定义，但必须在类外。</p><p>只要一个基类含有纯虚函数，那么这个基类是抽象基类。所有的抽象基类都是不能实例对象化的。</p><p>一般用于规范接口。</p><p>一般用于实现接口类，当一个接口类的所有函数都是纯虚函数，那么这个类是纯接口类。</p><blockquote><p>重构：重新设计类的体系以便将操作和数据从一个类移动到另一个类中。</p></blockquote><h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>protected:基类的protected成员对于派生类与友元时可访问的。但是只能通过派生类对象来访问，也就是访问派生类对象继承的protected成员，而其他普通的与其没有任何关系的基类对象的protected成员是不可访问的。</p><p>对类声明的访问说明符并不影响派生类对于基类的访问权限，这些由基类自身的访问说明符决定，其决定的是继承的部分在派生类中的访问权限。</p><p>对于对类定义的访问说明符，会使得基类中大于等于它的权限缩小为其权限用于本类中。</p><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>对用户来说：当且仅当派生类是公有继承的时候可行</p><p>对派生类的派生类的成员函数与友元来说：当且仅当是公有继承或者受保护继承的时候是可行的（因为如果是私有的，那么派生类与基类对于派生类的派生类就是私有的不可访问的了？）</p><p>对派生类的成员函数与友元来说：是一直可行的</p><p>友元是不能被继承的，但是，能够访问派生类的基类部分（如果基类声明了友元）。而友元的基类或派生类并不会因为这种关系而具有对其他类的访问权限。</p><p>在派生类由类名后的访问说明符来确定访问权限后，可以通过using bassclassname::成员名 来调整其对外的访问权限。而这一访问权限由该语句处于哪一个访问运算符下来决定。但只能改变其能访问的成员的对外权限。</p><p>class的默认继承是private继承，struct的默认继承则是public继承。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>由于派生类的作用域包在基类的作用域之内，因此，名字查找的时候是由内而外的。派生类的同名会隐藏基类的同名（即便类型和形参可能是不同的，若都相同，就不是隐藏而是虚函数了），但派生类除了虚函数重写外不要使用基类中使用过的名字。</p><p>在查找对应对象（成员）的过程中，先寻找名称再进行类型检查。从内到外寻找相同名称的对象，找到后进行类型检查，若成功则根据是不是虚函数来选择调用的函数。</p><p>虚函数与普通函数的最根本的区别就是当使用指针指向一个可能非指针类型的对象的时候，虚函数会根据指向的对象而选择函数（实际上是在就相当于先找到名字相同的普通函数，然后只不过多了一步虚函数的重新选择函数），而普通函数只会根据指针的静态类型而选择函数。</p><p>？可以通过using来一次性覆盖一个函数的所有版本，因为using是通过名称来匹配的，而不管类型与参数。(p551)</p><h3 id="虚构折构函数"><a href="#虚构折构函数" class="headerlink" title="虚构折构函数"></a>虚构折构函数</h3><p>由于基类的指针可能指向派生类对象，而delete指针会调用其指向对象的折构函数，我们希望去调用派生类的折构函数，因此将基类的折构函数定义为虚函数。</p><p>虚折构函数会阻止合成移动操作。</p><p>另外，当且仅当基类的折构函数被声明为虚的了，那么派生类的折构函数才会去隐式调用基类的虚构函数。</p><h3 id="合成的拷贝控制"><a href="#合成的拷贝控制" class="headerlink" title="合成的拷贝控制"></a>合成的拷贝控制</h3><p>派生类的合成的拷贝控制函数会先调用基类的拷贝控制函数来处理其自身中的基类部分，后再调用自己的函数体。合成的拷贝控制函数能成立只需要其基类的对应的可以被访问。</p><p>而合成的析构函数会先删除派生类自身的成员，再删除其直接基类的成员，而这会调用直接基类的折构函数。</p><p>若基类中的折构函数无法访问或者对应的拷贝控制函数无法访问，则合成的对应的拷贝控制函数会被删除（折构对应全部）。</p><p>基类没有合成移动操作会使得派生类也不合成移动操作，因此基类中最好声明移动操作，以使得派生类中会自动合成移动操作（因为派生类中的折构函数不是虚的）。</p><h3 id="派生类的合成拷贝"><a href="#派生类的合成拷贝" class="headerlink" title="派生类的合成拷贝"></a>派生类的合成拷贝</h3><p>折构函数会隐式销毁包括基类的所有成员，因此折构函数只用处理自己派生类独有的部分即可。</p><p>而拷贝控制函数需要显式的去拷贝控制基类部分。派生类的移动或拷贝构造函数在初始化列表中调用基类对应的函数来初始化其基类部分，因为在传入参数的过程中会自动将派生类独有的部分被切掉了。</p><p>派生类的移动或拷贝赋值运算符中，调用基类对应的函数来赋值其基类部分。必须通过作用域符显式指定是基类的函数$base::operator&#x3D;(variable)$，实际上可以看做是this.base::operator&#x3D;，接着再自行处理自己的部分。</p><p>没懂。</p><p><img src="/image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Untitled.png" alt="Untitled"></p><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>using声明语句只是令某个名字在当前作用域可见。被using的函数往下的继承也会因为被声明时所在的访问声明符的不同而产生不同的往下继承权限。只能using能访问的函数来调整它的权限（到底能不能using private的基类函数）。就好像这个函数是在这里声明的一样。</p><p>构造函数只会继承普通构造函数（非默认，拷贝与赋值）。继承的构造函数形如：</p><p>$$<br>derived(params)\ :\ base(args)\ {}<br>$$</p><p>这种继承方式只对构造函数有用。</p><p>相当于在初始化列表中只调用了基类的构造函数，其他部分被默认初始化。</p><p>但构造函数的using 并不会改变访问级别。using也不能改变函数的属性。</p><p>当构造函数中含有默认实参的时候，派生类会自动生成实参数量+1个构造函数，每一个构造函数比上一个构造函数少一个默认实参。</p><p><img src="/image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Untitled%201.png" alt="Untitled"></p><p>派生类中定义的构造函数会覆盖继承的同名构造函数。</p><p>通过using基类的构造函数，其名字就会自动在派生类中变为派生类的名字，相当于直接使用基类的构造函数作为自己的构造函数。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>当我们想用容器来存储多种类型（属于同一基类的底下时（可以使用间接基类的指针指向派生类的对象）），最好使用基类的指针来间接存储。</p><p>在使用基础类的时候要加上std::。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>union </title>
    <link href="/hide/union/"/>
    <url>/hide/union/</url>
    
    <content type="html"><![CDATA[<h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><p>union实际是一种用来节省空间的存储方式。有的时候一个东西有多种存储方式，比如string,int,double等等，但任何时候的任何一种就能代表一整个整体，因此我们任何时候只需要其中的一种存在即可，也就是说这几种是互斥的存在，有一个，其他的就不会存在，并且占用同一块空间来节省空间。</p><p>本身仍然是一个类，但是是类似struct的，可以有折构，构造等等，以及各种不同类型的变量各一个。使用的时候仍然是指定对应类型的变量进行赋值，给一个类型赋值就会清除其他的值，当访问一个不是当前存储类型的类型时是未定义的。</p><p>当这个union类没有名字时，将会创建一个未命名的union对象，从表象看起来就好像可以直接使用union中的变量一样。</p><p>但是union有一个最大的问题就是，它本身只能够处理内置类型，如果涉及到自定义类类型，并且这个类类型还有折构，拷贝等控制函数，那么就必须自己定义其中的很多操作。因为，更换存储的类型这件事情union是通过先折构原本的对象再通过构造函数创建一个新的对象来实现的，而union折构的过程中并不会调用类类型自定义的折构函数，然后就出问题了。</p><p>因此一般管理存储类类型的union都会给这个union套一个类来控制它的行为。一般要实现构造，拷贝构造，拷贝赋值和折构函数。并且另外通过创建一个enum对象来存储当前存储的类型。</p><p>另外，要注意的是，在构造的时候需要在原本的内存位置来构造来节省空间，因此要用到定位new的方式。</p><p>c++17提供了variant来替代union，它可以自行处理类对象，并自动存储当前保存的类型。但是效率比union略低。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>固有的不可移植的特性 </title>
    <link href="/hide/%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/hide/%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="固有的不可移植的特性"><a href="#固有的不可移植的特性" class="headerlink" title="固有的不可移植的特性"></a>固有的不可移植的特性</h1><p>不可移植的特性是指因机器而异的特性，当将具有这种特性的程序迁移到不同的机器上时需要重新编写。</p><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>类可以将非静态成员定义为位域，一个位域中含有指定数量的二进制位，一般用无符号类型来保存一个位域。$unsigned\ type\ name:位域的二进位数;$类中连续定义的位域会被压缩在同一整数的相邻位来压缩存储。</p><p>取地址符不能用于位域，因此指针无法指向位域。另外，最好使用无符号类型，因为存储在带符号类型的位域是根据机器而定的。</p><p>可以直接对位域进行赋值，但一般还是会使用位运算符操作超过1位的位域。</p><p>需要注意的事，位域只能使用在类中。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>有的数据元素可能是由程序之外的别的什么在控制，此时我们就需要将这样的对象声明为volatile的，告诉编译器不应该对这样的对象进行优化。</p><p>volatile是一个很类似const的修饰符，当对于一个对象声明时，它内部的所有的成员也将被声明为volatile。</p><p>另外，volatile只有被形参也是volatile的函数调用。当声明volatile时，指针和引用本身也可以是volatile的，如果是volatile的，那么引用或指向的也必须是volatile的。</p><p>由于合成的拷贝控制的参数是const非volatile的，因此无法拷贝控制volatile的对象，因此必须自行定义。</p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>有的时候我们希望能够扩展c++的功能，去使用别的语言写的函数，这个时候就需要靠extern来声明这些函数。</p><p>如果是单个的，只要在声明前加上extern “语言字符串常量名”即可。如果多个声明，则要在””后用大括号包裹。这个多个声明也可以是一个include，其中的所有普通函数声明都认为是该语言编写的。</p><p>此外，函数所使用的语言本身也算是函数类型的一部分，因此假如说要用函数指针指向这些函数，就必须给这些函数指针也声明extern。</p><p>需要注意的是，extern这句语句是对于这句语句中的所有函数都声明，不管是返回类型还是形参时函数都会被声明上，因此如果要分开来处理可能就需要通过类型别名的方式。</p><p>当我们给一个正常的函数声明上extern时，相当于将这个函数给别的语言用。</p><blockquote><p>可以通过#ifdef __cplusplus预处理器来方便c和c++同时编译一个文件。</p></blockquote><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌套类 </title>
    <link href="/hide/%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
    <url>/hide/%E5%B5%8C%E5%A5%97%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p>更加封装也更加有逻辑和可读性。</p><p>正如其名，在类里面定义的类是嵌套类。但是嵌套类和外层类是互相独立的。</p><p>嵌套类就相当于外层类的一个普通的成员一样，也是具有着限定控制的。只不过嵌套类可以随意访问自己和外层类的所有成员，名字查找时是从内到外的，而外层类要访问嵌套类却要遵守限定。</p><p>在定义内部类的时候前面也要加上外层的作用域符。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>局部类 </title>
    <link href="/hide/%E5%B1%80%E9%83%A8%E7%B1%BB/"/>
    <url>/hide/%E5%B1%80%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h1><p>局部类和嵌套类不同，嵌套类是在类中的，而局部类是在函数中的，嵌套类可以使用外层类的成员，而局部类定义的类型只在它的作用域可见，并且所有的成员都必须完整的定义在类的内部。</p><p>另外，局部类中不允许声明静态数据成员。</p><p>局部类只能访问外层作用于定义的类型名静态变量和枚举成员。</p><p>另外，由于局部类已经被封装在了函数作用域内，所以一般就直接所有成员直接都public了。</p><p>局部类里可以继续定义一个嵌套类，但是这个嵌套类也是一个局部类。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多重继承与虚继承 </title>
    <link href="/hide/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <url>/hide/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h1><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>多重继承就是从多个直接基类继承。继承要求与普通继承一样。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>当不使用某个基类的继承构造函数初始化该部分时，就会使用该基类的默认构造函数。</p><p>另外，构造函数的顺序与我们写的顺序无关，是根据派生列表的顺序，派生树dfs的顺序。</p><p>当使用using继承了基类中同名同参的构造函数时，必须自行定义一个接受同样参数的构造函数来覆盖掉。</p><h3 id="向基类的转换"><a href="#向基类的转换" class="headerlink" title="向基类的转换"></a>向基类的转换</h3><p>对于编译器来说，只要是基类，那么转换都是一样好的，因此如果有函数重载内是基类，那么可能会出现二义性错误。</p><p>基类指针指向派生类对象时，只能使用自己基类部分的成员。</p><h3 id="作用域（派生类的名字会覆盖基类的名字，因为更局部）"><a href="#作用域（派生类的名字会覆盖基类的名字，因为更局部）" class="headerlink" title="作用域（派生类的名字会覆盖基类的名字，因为更局部）"></a>作用域（派生类的名字会覆盖基类的名字，因为更局部）</h3><p>当使用基类中的名字的时候，会同时在继承的所有基类中查找，很容易就会找到相同的。在继承的不同基类中有相同的名字并没有什么问题，这只是潜在的二义性问题而已，使用时必须指出作用域，或者一种更好的方式是自己定义并覆盖。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>有的时候，在整一个继承体系中会出现对某一个基类的多次继承（当存在多重继承的时候），此时就会有多个同样基类的实例，这是我们所不希望的。我们可以使用虚继承来让某个类同意共享它的某个基类，在这种情况下，无论出现多少次基类，使用的都是同一个实例。</p><p>通过class derived:virtual public&#x2F;… base就可以虚继承，并不会对本类造成任何影响，而表示本类的派生类都将共享本基类的base这个基类。</p><p>对于基类的成员，首先，派生类会覆盖基类的成员，当多重继承时，如果同一级的基类下有同名，则会二义性。</p><h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><p>由于虚基类可能会被多次构造，因此，若是存在虚基类，则必须由最底层的派生类来负责初始化，也就是在初始化列表中调用虚基类的构造函数。</p><p>如果最底层的派生类没有显式化构造虚基类，则虚基类的默认构造函数会被调用。</p><p>整体的构造顺序虚基类总是先于非虚基类。</p><p>折构的顺序正好相反。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>控制内存分配 </title>
    <link href="/hide/%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/hide/%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h1><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>new和delete实际上是opeartor new和operator delete，我们可以去重载这两个运算符。我们既可以在全局重载，也可以在类内重载。当我们new一个对象，首先会查找类内有没有实现，然后全局，最后才是使用标准库。</p><p><img src="/image/%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DUntitled.png" alt="Untitled"></p><p>这里delete的返回类型都错了，是void而不是void*。</p><p>前四个可能会抛出bad_alloc异常。nothrow_t是new头文件里的一个struct，不包含任何成员，并且定义了一个名为nothrow的const，可以通过这个常量来使用下面四个非抛出版本。当我们重载下面四个的时候也必须使用noexcept。</p><p>当作为类的成员时，会隐式声明为静态的，因为发生在对象创建前和销毁后因此与数据成员本身无关，是静态的。</p><p>对于operator new([])来说，它的返回类型必须是void*，第一个形参类型必须是size_t表示字节数或者数组所需空间大小。在此外，它不可以有默认实参，但是却可以有额外实参，这种有额外实参的new必须通过如定位new的方式来调用。</p><p>使用方式：new (形参) type([]);</p><p>但是，唯有$void\ ^<em>operator\ new(size_t,\ void^</em>);$不可以被重载，只能被标准库使用，在使用定位new时只传入一个地址时被调用。</p><p>对于operator delete([])来说，返回类型是void，第一个形参为void*。</p><p>当为类成员时，可以再传入一个类型为size_t的参数表达void*所指向对象的大小。通过虚折构可以根据不同的对象更改不同的大小。</p><p>不像其他重载可以重载含义，new和delete我们是指重载了内存分配的方式，但基本含义仍然不变。</p><h3 id="实际分配和释放内存"><a href="#实际分配和释放内存" class="headerlink" title="实际分配和释放内存"></a>实际分配和释放内存</h3><p>用malloc分配，free释放，定义于cstdlib中。</p><p>malloc接受一个待分配字节数size_t类型参数，返回指针或0表示失败。</p><p>free接受一个malloc返回的指针。free(0)没有意义。</p><h3 id="定位new-placement-new"><a href="#定位new-placement-new" class="headerlink" title="定位new(placement new)"></a>定位new(placement new)</h3><p>使用形式：$new\ (place_address)(除size_t以外的参数)\ type\ ([])\ (initializer)&#x2F;{list}$</p><p>只有new和type是必须的。</p><p>new和delete只负责内存相关的，构造与清除会在其中交予构造或折构函数。</p><p>place_address是一个指针。当有这个参数的时候就是定位new，就是在place_address的地方调用构造进行创建，（允许我们在一个特定的、预先分配的内存地址上构造对象），并不进行内存的分配与销毁。并且很重要的是，place_address可以是new的，也可以是其他的，甚至可以指向不是动态内存的。</p><p>折构函数可以被显式调用，但是折构函数只负责清除对象而不负责释放对象，因此我们必须手动delete，或者继续使用这块空间放其他的东西。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>枚举类型enumeration </title>
    <link href="/hide/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benumeration/"/>
    <url>/hide/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benumeration/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举类型enumeration"><a href="#枚举类型enumeration" class="headerlink" title="枚举类型enumeration"></a>枚举类型enumeration</h1><p>enum是整形常量的一个集合，定义出一个类型，这个类型的对象只能取枚举成员这些值，并且该类型对象是常量。</p><p>总共有两种枚举，限定作用域和不限定作用域的。</p><p>非限定使用方法 enum name{整形常量的名字，用,隔开}。name可以省略，但若是省略就必须在定义时初始化它的对象。</p><p>限定就是在enum后name前加上class。</p><p>在进行赋值的时候，只能使用类型内成员的名字进行赋值，而不能用整数，而限定的还必须加上作用域。若不进行赋值，第一个枚举成员为0，后一个枚举成员是前一个+1。</p><p>可以通过在name后加上:整数类型来声明其使用的成员类型，在不声明时，限定的默认使用int，非限定则根据其枚举成员的值自动调整，但最大也不能超过ull。</p><p>当仅仅是声明枚举类型时，非限定必须声明其成员类型，当多次声明时，该类型不能变。</p><p>整数不能转为enum类型的成员，但是不限定enum类型的成员能转为整数，也就是被提升为int或更大的整数类型。</p><p>enum一般用于避免直接使用整数常量，提高代码的可读性。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类成员指针 </title>
    <link href="/hide/%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/"/>
    <url>/hide/%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h1><p>类成员指针就是指向类成员的指针。</p><p>类成员指针即便是在赋值后也并不指向一个特定对象的成员，它是一个很宽泛的代表，相当于类成员有了一个别名一样。使用时需要在*前加上作用域符，但是大部分情况都是私有的，所以一般会定义一个函数返回类成员指针。而如果是成员函数指针，那么得要加括号，因为调用运算符的优先度更高，并且类型成员函数指针和类型成员函数对象不像不同函数能互相转换。</p><p>此外，假如说a是一个类成员指针，调用的时候就是b.a&#x2F;b→a，这个时候它才真正有了实际的含义。</p><p>这类型写起来很麻烦，所以最好还是使用auto或者using来解决。</p><p>有的时候可以配合enum实现函数表。</p><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>类成员指针不是一个可调用对象，因此泛型算法不能使用。</p><p>但我们只需要将类成员的地址绑到一个function类型上即可，并且将类型本身显式化，也就是this要显式化作为形参。它就变为一个可调用对象了，隐式传入this作为参数。但是至于是使用.还是→来调用根据形参来判断。</p><p>为了避免.和→的问题，可以使用mem_fn(成员指针地址)函数来生成一个function对象，类型直接auto就可以了，这就对于任何无论是指针还是对象都可用了。</p><p>除了function，也可以使用bind(成员函数指针地址，_1)来将其变为一个可调用对象，实际上就是强制将this本身传进去。可以达到与mem_fn一样的效果。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运行时类型识别RTTI </title>
    <link href="/hide/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%ABRTTI/"/>
    <url>/hide/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%ABRTTI/</url>
    
    <content type="html"><![CDATA[<h1 id="运行时类型识别RTTI"><a href="#运行时类型识别RTTI" class="headerlink" title="运行时类型识别RTTI"></a>运行时类型识别RTTI</h1><p>run-time type identification。</p><p>RTTI主要用于在没有使用虚函数时希望用基类指针或用用执行某个派生类操作，虽然仍然希望能使用虚函数就使用虚函数。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>$dynamic_cast&lt;type^*&#x2F;&amp;&#x2F;&amp;&amp;&gt;(e)$</p><p>e需与&lt;&gt;中的类型一致，type为类类型。</p><p>一般type应该是包含虚函数的类。</p><p>类型转换只能向本派生树上向上或向下或不动的公共类进行转化。若转换失败，指针返回0，引用抛出bad_cast，在类型转换后最好检查是否成功，指针if就可以检验了，而引用的则需要使用try并catch bad_cast(定义在typeinfo中)。</p><p>可以对空指针执行dynamic_cast、</p><h3 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h3><p>使用typeid(variable)，返回一个常量对象的引用，类型时type_info或其共有派生类型。这里的variable甚至可以使表达式，另外，忽略顶层const和引用，并且不会将数组或函数转为指针。</p><p>当对象不虚时，将返回静态类型。否则知道运行后才能知道真正的动态类型。</p><p>typeid里面的还可以是类型名。</p><p>如果typeid的表达式是动态类型，则在运行时必将求值并通过结果来获取类型，而若是静态类型在编译时就能通过类型之间的运算即可得出结果，因此静态类型无需要求其有效，但动态类型需要。</p><h3 id="RTTI的用处"><a href="#RTTI的用处" class="headerlink" title="RTTI的用处"></a>RTTI的用处</h3><p>如在继承体系中想重载&#x3D;，但是由于虚函数的参数需与基类的对应函数相同，因此传入的只能是基类的引用，因此需要typeid处理不同类型之间的比较和dynamic_cast来进行转换比较派生类独有的部分。</p><h3 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h3><p><img src="/image/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%ABRTTIUntitled.png" alt="Untitled"></p><p>type_info没有默认构造函数，并且拷贝和移动构造函数都被定义为删除的，因此只有可能通过typeid获取type_info对象。</p><p>name()返回的名字不一定与程序中使用的名字一致，对于其返回的唯一要求就是类型不同返回的字符串也要不同。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>A* </title>
    <link href="/hide/A/"/>
    <url>/hide/A/</url>
    
    <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>bfs，但是先去扩展f(x)小的点，f(x)&#x3D;g(x)+h(x)，g(x)表示起点到该点的距离，h(x)表示距离终点的距离，是一个启发式的函数，也就是说不是定的，只要能表示距离目标的距离即可。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPU </title>
    <link href="/hide/CPU/"/>
    <url>/hide/CPU/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ol><li>I instruction</li><li>A address</li><li>R register</li><li>D data</li><li>C counter</li><li>P program</li><li>S status</li><li>状态寄存器 PSW</li><li>操作控制器：建立数据通路，即从哪流向哪，<ol><li>时序逻辑型：硬布线控制器，就是通过设计电路硬做</li><li>存储逻辑型：微程序控制器，像程序一样读出一个一个的开关的状态进行操作</li></ol></li><li>数据通路：寄存器到寄存器，寄存器由时钟控制，而寄存器到寄存器间可能有各种结构，ALU，MEM等等，中间的却不受时间周期影响</li><li>指令周期：取指令到执行完指令的时间</li><li>CPU周期：即访问一次内存的时间   主频：CPU周期的倒数</li><li>T周期：访问一次寄存器的时间，每一次都可以打开一条数据通路</li><li>取指令必须要占用一次CPU周期</li><li>执行指令则另外花费CPU周期，一个CPU周期可能包含多个T周期，个数不确定</li><li>如mov,add就是1+2T，进dr，然后再进</li><li>lad则需要3个，放地址+取</li><li>jmp 2个，改</li><li>方框代表cpu周期，菱形：判断，箭头表示方向，虚线表示阶段，每个方框内写内容即T周期内容，最后加上一个波浪线</li><li>时序产生器，告诉CPU处在哪一个CPU或T周期</li><li>硬布线控制器：主状态周期（指令周期）—节拍电位（CPU周期）—节拍脉冲（T周期）</li><li>而微程序控制器只有：节拍电位（CPU周期）—节拍脉冲（T周期）</li><li>产生很多信号，如T1,T2,T3,T4，分别在其对应时间是高电平，如T1，就在第一个T周期高电平</li><li>有一个时钟源(晶振)，用来产生固定的频率，环形来产生顺序，从0-》2^n&#x2F;其他数字，译码译成对应的T，RD和WE是针对存储器的，暂时可以忽略，启停控制逻辑控制什么时候真正开始计数</li></ol><p><img src="/image/CPUUntitled.png" alt="Untitled"></p><ol><li>控制方式：同步控制（统一的机器周期，不定长（CPU周期不同）机器周期）&#x2F;异步控制（每个指令爱执行多久执行多久）</li><li>微程序控制器：微指令存放在控制存储器中，微操作有的是相容的，有的是互斥的，即不能同时打开开关，有的是相容的，可以同时打开，必须各占一位？</li><li>一般一条微指令分为两部分，操作和顺序控制字段，控制下面一条执行的微指令</li><li>微命令就是一个开关的10，微操作就是对应这个微命令</li><li>微指令组合起来就是微程序</li><li>顺序控制字段中还包括p1，p2这种可能判断要不要跳转的字段</li><li>微程序控制存储器(μCM)，存储微程序，只取里面的操作码，并进行一些地址转移逻辑，并放到微地址寄存器中并传入进行译码，找到这个操作码对应的微程序</li></ol><p><img src="/image/CPUUntitled%201.png" alt="Untitled"></p><p>在微程序中可能有条件判断，就通过p2来判断，如果满足则跳到后面的地址+1否则+1</p><ol><li>微命令编码<ol><li>直接编码：直接表示1和0，开和关，速度最快，但长度最长</li><li>编码表示法：分成若干个小段，每个小段用最短表示法，每个小段里的都是互斥的，最短，但慢</li><li>混合表示</li></ol></li><li>微地址的形成方法<ol><li>入口地址</li><li>计数器，跳转，但假如说有多条分支，就会很慢</li><li>多路转移，当且仅当p1为1，直接通过状态位或寄存器来直接更改微地址寄存器的某几位</li></ol></li></ol><p>微指令格式：</p><ol><li>水平型：一次性打开所有开关，快但长</li><li>垂直型：非一次性，按顺序，可能在一个T周期中，也可能不在，垂直短但慢</li></ol><p>现在的都是动态的微程序，而以前是静态的</p><p>CPU流水线：</p><p>比如，一条指令分成取指(IF)，译指(ID)，读取(EX)，写回(WB)，那么就是一个4级流水线，如果没有冲突的话，那么加速比就是四级。</p><p>不分更多级是因为会冲突。</p><p>冲突</p><ol><li>资源冲突</li><li>数据相关</li><li>控制相关，比如碰到条件，就不知道取哪一个</li><li></li></ol><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO </title>
    <link href="/hide/IO/"/>
    <url>/hide/IO/</url>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="/image/IOUntitled.png" alt="Untitled"></p><p>w代表宽字符，f代表file，s代表string，但指的是内存string对象。</p><p>其类型的不同并不会影响使用，通过继承机制，我们可以像如普通操作iostream一样操作fstream和sstream。</p><p>IO对象无初始化参数，无法拷贝也无法赋值。</p><p>由于在输入或输出时会改变状态，因此返回的是非const引用。</p><p><img src="/image/IOUntitled%201.png" alt="Untitled"></p><p><img src="/image/IOUntitled%202.png" alt="Untitled"></p><p>$cin&gt;&gt;a$返回的实际是$!\ cin.fail()$</p><p>当一个流发生错误，这个流就不能被继续使用了。</p><p>因为它进入了错误状态。</p><p>描述IO流对象的状态总共有4个，由四个位表示，分别是</p><ol><li>badbit，表示发生了无法恢复的问题</li><li>failbit，表示发生了可以恢复的问题，当badbit为置位也为置位</li><li>eofbit，表示流到了文件末尾</li><li>goodbit，表示流没有发生错误，当错误位都为复位时为置位</li></ol><p>因此，goodbit与failbit是正好相对的。</p><p>置位：将该位变为1</p><p>复位：将该位变为0</p><p>这四种状态被存储在iostate中，可以通过rdstate()来获取当前的iostate。</p><p>通过4个分别检测四种状态的情况的函数，即可对应进行检测。</p><p>通过clear函数可以将状态复位，并且可以通过参数来指定复位的位置。</p><p><img src="/image/IOUntitled%203.png" alt="Untitled"></p><p>setstate正好与clear相反，是根据参数类指定置位的位置。</p><p><em><strong>具体clear与setstate是如何根据传入参数而选择位置的，暂时还没懂。</strong></em></p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>由于设备的写操作可能很费事，因此程序会先将输出内容暂存到缓冲区。之后再将缓冲区的内容一并输出，大大提高性能。</p><p>缓冲区刷新就是指将缓冲区内容输出并清空。</p><p>缓冲区刷新将在以下几种情况刷新。</p><ol><li>程序正常结束，在return 0时刷新。当非正常结束时，不会刷新。</li><li>当缓冲区满的时候。</li><li>当使用endl，flush和end操纵符时。flush仅会刷新缓冲区，end会额外输出一个空字符，endl额外输出一个换行符。</li><li>可以通过unitbuf设置流的状态来立即清空缓冲区，在cerr中unitbuf是默认设置的，因此其内容每次都会直接输出。</li><li>当输出流被关联到其他流时，当被关联流读写时，其本身就会刷新。cin与cerr都关联cout，因此读写cin,cerr会使cout刷新。</li></ol><p>通过unitbuf操纵符，表示之后所有的写操作后都flush，并可以通过nounitbuf重置。</p><p>$$<br>cout&lt;&lt;unitbuf;<br>$$</p><p>通过将读操作关联到写操作，可以保证输出的结果必会在用户的后操作前显示出来。</p><h3 id="tie"><a href="#tie" class="headerlink" title="tie"></a>tie</h3><p>是istream的一个成员函数，通过点运算符调用。</p><ol><li>无参数。返回指向当前输入流所关联到的输出流的指针。可能返回空指针。</li><li>一个指向输出流的指针作为参数。将当前输入流关联到输出流。可以传入空指针来解除关联。</li></ol><p>多个输入流可以关联到一个输出流。</p><p>但一个输入流不能关联到多个输出流。</p><p>虽然一般只会将输入流绑定到输出流上，但是实际上输出流也是有tie这个属性。</p><h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>继承所有的iostream特性。</p><p><img src="/image/IOUntitled%204.png" alt="Untitled"></p><p>由于fstream是iostream的派生类，而在要求使用基类型对象的地方，可以使用派生类替代。因此可以在要求iostream时用fstream替代。</p><p>若是open失败，这流的failbit会被置位。其后续操作也将不能继续。</p><p>另外，若是对于一个已经打开文件的流，若是再次调用open，则会是失败，failbit也会被置位。</p><p>当离开作用域时，会自动调用close。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ol><li>in读模式</li><li>out写模式</li><li>app追加模式，每次写操作定位至文件末尾</li><li>ate打开文件时定位至文件末尾</li><li>trunc截断文件，即删除文件中所有内容</li><li>binary二进制读</li></ol><p>trunc只有在out时才能才能使用。</p><p>trunc与app相冲突。</p><p>默认情况下out就附带了trunc，若要不截断，必须显式声明app或in。</p><p>fstream类型会以其默认功能的模式打开。</p><h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p>实际上就是对string的操作。主要用来防止缓冲区溢出错误（？）。</p><p><img src="/image/IOUntitled%205.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++基础 </title>
    <link href="/hide/c++%E5%9F%BA%E7%A1%80/"/>
    <url>/hide/c++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h1><p><a href="https://lhish.github.io/hide/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">变量与基本类型</a></p><p><a href="https://lhish.github.io/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84">字符串、向量和数组</a></p><p><a href="https://lhish.github.io/hide/%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a></p><p><a href="https://lhish.github.io/hide/%E8%AF%AD%E5%8F%A5">语句</a></p><p><a href="https://lhish.github.io/hide/%E5%87%BD%E6%95%B0">函数</a></p><p><a href="https://lhish.github.io/hide/%E7%B1%BB">类</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>modern </title>
    <link href="/hide/modern/"/>
    <url>/hide/modern/</url>
    
    <content type="html"><![CDATA[<h1 id="modern"><a href="#modern" class="headerlink" title="modern"></a>modern</h1><ol><li><p>对齐：一个结构体中的所有元素所占的空间大小都会按其中最大的类型所占的空间大小，不到的部分空字节填充。</p><p> alignof()获取某一个类型的对齐大小</p><p> alignas(int)让某一个类型的大小对齐int大小，写在变量名前</p></li><li><p>static_assert(bool,string&#x2F;c_str)</p><p> 编译时assert</p></li><li><p>变量模板</p><p> 就是将一个变量的类型变为模板</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">template&lt;typename T&gt;<br>T val;<br><span class="hljs-comment">//使用的时候</span><br>val&lt;某个type&gt;=...<br></code></pre></td></tr></table></figure></li><li><p>泛型lambda</p><p> 支持模板化</p></li><li><p>interger_sequence&lt;T,number1,number2,…&gt;</p><p> 一个类型为T，值为number的整数序列，一般用于模板元编程</p><p> make_interger_sequence&lt;T,number&gt;生成一个0-19的interger_sequence</p><p> make_interger_index<number>类型为size_t</p></li><li><p>std::exchange(obj,new_value)</p><p> 以new_value替换obj的值并返回obj的旧值</p></li><li><p>std::quoted(字符串)，给暂时的字符串加上””，可以用来简化生成JSON、XML等带引号的文本格式的代码。</p><p> std::quoted(in, delim, escape)，delim是要加上的字符，而如果原字符串中有delim字符，那么在前面加上escape以实现转义。</p></li><li><p>结构化绑定（都需要大小一致）</p><ol><li>绑定数组，第一个绑定a[0]….，必须要绑定的数量和数组大小一致</li><li>绑定元组</li><li>绑定结构体，按声明顺序一一绑定</li></ol></li><li><p>if中初始化：if(初始化;条件){}初始化的变量的生命周期是整个if</p></li><li><p>复制消除</p><p>有的时候编译器会省略一些复制构造和移动构造直接使用原本的变量来作为新的变量来省去这一开销。</p><p>而c++17中引入了一部分的强制复制消除的规则，原本都是非强制的。</p></li><li><p>折叠表达式</p><p>通过折叠表达式来原地展开来简化形参包的使用。</p><p><img src="/image/modernUntitled.png" alt="Untitled"></p></li><li><p>模板类型(c++20还有非类型的)推导，即有些能推导的地方就不用写&lt;&gt;了</p></li><li><p>非类型模板参数的类型也可以用auto来推导了</p></li><li><p>using可以一次性using多个变量了，用,隔开。</p></li><li><p>属性说明符列表可以将命名空间提前。</p><p><img src="/image/modernUntitled%201.png" alt="Untitled"></p></li><li><p>[[fallthrough]]</p><p>在一个case结束时不break不会警告</p></li><li><p>std::any，一个可以为任何类型的类型，但是要获取对应值的时候要进行any_cast转为特定的类型后才能访问。</p></li><li><p>charconv：from_chars(char*,char*,数字&amp;,chars_format)和to_chars(char*,char*,数字,char_format)，from_chars返回值通过引用传递，提供了更好的字符串和数字转换(可以调整格式)</p></li><li><p>excution：提供seq顺序,par按顺序并行,par_unseq乱序并行,unseq乱序四种方法。一般用于for_each(策略,iter,iter,函数)，表示以什么样的策略对iter范围的数据执行这个函数。</p></li><li><p>filesystem：提供filesystem和path来处理文件系统和路径。</p></li><li><p>optional:提供一种可选值类型，当被默认初始化或者另一个空的optional赋值时为空。可以通过reset来清空值。当转换为bool或者调用has_value的时候返回是否含有值的bool。</p></li><li><p>string_view:一个只读的只持有指针和大小不持有空间的字符串。</p><p>字符串视图有两个主要的应用：</p><p>你可能已经分配或者映射了字符序列或者字符串的数据，并且想在不分配更多内存的情况下使用这些数据。典型的例子是内存映射文件或者处理长文本的子串。</p><p>你可能想提升接收字符串为参数并以只读方式使用它们的函数&#x2F;操作的性能，且这些函数&#x2F;操作不需要结尾有空字符。</p></li><li><p>variant：通过get<T>(变量)来获取值，通过holds_alternative<T>(变量)或者变量.index()来判断持有类型。比union更加安全，自动内存管理，取错误的类型会报错。</p></li><li><p>std::apply(func,tuple)：将tuple作为形参列表给func运行</p></li><li><p>make_from_tuple<T>(tuple)和std::apply(T(),tuple)功能差不多。</p></li><li><p>std::search(iter,iter,iter,iter)：在区间1搜索区间2</p></li><li><p>std::search(iter,iter,searcher(iter,iter))：在区间1中以某种特定的搜索方法搜索区间2，有default_searcher和<strong>boyer_moore_searcher</strong></p></li><li><p>as_const能够避免使用const_cast</p></li><li><p>std::not_fn(func)：将func的功能取反，一般如将返回的bool取反之类的？</p></li><li><p>std::gcd,std::lcm</p></li><li><p>std::launder：主要是用来帮助辅助编译器来解决一些别名的问题，如别名所指向的失效的问题，这个时候就需要实际进行访问真正的内存情况</p></li><li><p>功能特性测试：由于编译器可能不支持c++的所有规定的特性，因此，可以使用功能特性测试提供的一系列宏来测试，并根据结果来适配不同的版本</p></li><li><p>&lt;&#x3D;&gt;：三路比较运算符，可重载，要求在a&lt;b时&lt;0，a&gt;b时&gt;0，a&#x3D;b时&#x3D;0.</p></li><li><p>默认比较函数：当将三路比较运算符设为&#x3D;default时就会生成默认比较函数.</p></li><li><p>struct和union的指派初始化器：{.元素&#x3D;值,…}要按声明顺序，并且union只能初始化一个</p></li><li><p>如if和switch一样，for(:)时也能进行初始化for(定义;<em>:</em>)，以更方便使用for。定义可以为别名声明，也可以时普通定义。</p></li><li><p>[[likely]][[unlikely]]：分支时使用，用于编译时优化</p></li><li><p><strong>[[no_unique_address]]：</strong>若该成员非空，则其中的任何尾随填充空间亦可复用于存储其他数据成员。</p></li><li><p>consteval：只在编译期执行,必须返回常量,使用条件比constexpr更严格。</p></li></ol><p><a href="https://lhish.github.io/hide/module">module</a></p><p><a href="https://lhish.github.io/hide/concept">concept</a></p><ol><li>source_location：提供行数，列数，文件名和所在函数的名字</li><li>ranges：一个新的库，表示一个范围(通过首迭代器和喂迭代器来确定一个范围)，各种std都实现了参数为ranges而非迭代器的重载。</li><li>用户自定义operator：operator””名字，所有用户定义的名字必须以_开头，而标准库中的则不需要。允许的形参为long double，unsigend long long，各种字符类型，各种字符串(char*)，并且对于字符串指针可以有第二个形参size_t类型，表示这个字符串的长度。使用的时候直接在后加上这个名字即可。</li><li>noexcept在新标准中也已经是函数类型的一部分了。</li><li>span：也是一个视图</li><li>ranges：就是给算法加上了require约束</li></ol><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nth_element </title>
    <link href="/hide/nth_element/"/>
    <url>/hide/nth_element/</url>
    
    <content type="html"><![CDATA[<h1 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h1><p>实际上寻找第n个element分为两个部分。</p><p>第一个部分是寻找第n大的数，不过时间复杂度最优是on，最劣是ologn。</p><p>方法就是：</p><p>在快速排序的每一次迭代中，都会分出3段，分别是小于，等于和大于，然后看第k大的数在哪一段然后继续迭代即可。</p><p>第二个部分就是如何将这个复杂度优化到on，主要内容是寻找近似中位数。</p><p>快速排序的复杂度大部分取决于pivot的选取，因此最好选出一个靠近中位数的数。</p><p>方法就是将其进行分组，对于每个组选出一个中位数，然后对于这些中位数组成的新的数组，继续分组，选中位数，进行迭代，一般情况下是5个一组。</p><p>这样的优化下能on时间下求出一个近似的中位数。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>timsort </title>
    <link href="/hide/timsort/"/>
    <url>/hide/timsort/</url>
    
    <content type="html"><![CDATA[<h1 id="timsort"><a href="#timsort" class="headerlink" title="timsort"></a>timsort</h1><p>timsort就是优化到极致的mergesort.</p><p>如果数组小于64就用插入排序解决。</p><p>首先，有一个minrun的值，取决于数组大小的前6位。如果后面不是全0，就要加1，主要是要让n&#x2F;minrun差不多正好是2的幂或比它稍小，并且minrun本身要大于64.</p><p>对于每一个minrun，在检查的时候，首先先找到从当前位开始的最长的严格下降或上升序列，然后如果是降序就on反一下，如果没有到达minrun个数，那么就强行扩张，将后面几个通过插入排序的方式插入。</p><p>每次找到一个新的minrun后，就检测前面的minrun是否要合并，要一直保持A&gt;b+c,b&gt;c的情况，实际上就是只要比较最后两个run的大小就可以了，如果倒数第二个小于倒数第一个，那么就合并，然后向前递归。</p><p>到最后全部都有了之后，强行将剩下的所有minrun合并。</p><p>合并的方法是mergesort里的merge。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>type_traits </title>
    <link href="/hide/type_traits/"/>
    <url>/hide/type_traits/</url>
    
    <content type="html"><![CDATA[<h1 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a>type_traits</h1><ol><li>通过传入非类型模板参数，定义了整型常量这种类型</li><li>以此为基础定义了true和false这两种常量类型，及其模板版本，即bool_constant&lt;…&gt;</li><li>实现了conditional_t&lt;bool,type1,type2&gt;，其成员类型type根据bool来等于type1或type2</li><li>实现了__type_identity_t<T>来返回T这一类型，来实现更加复杂的类型运算，为了更容易生成对象？</li><li>实现了__or_，__and_，__not_三个模板元编程，参数为&lt;…&gt;，通过前述的bool_constant和conditional_t来实现。并提供他们的别名conjunction，disjunction，negation。这些返回的都是bool常量类型类型，因此需要::value来获取他们的值，而后提供了…_v版本来直接获取其bool值。</li><li>定义is_const和is_violate(const放在type前和type后表达的意思一致，但是最好放在右侧，从右往左读更易于理解)。</li><li>定义is_pointer，is_lvalue_reference，is_rvalue_reference</li><li>定义有着大小的type和(引用，function，空，is_array_unknown_bounds)为完整的或未绑定的类型，可通过__is_complete_or_unbound来获取bool常量类型。</li><li>定义了__success_type&lt;…&gt;有type类型&#x3D;…，而__failure_type&lt;…&gt;没有type类型。</li><li>定义remove_cv_t&lt;…&gt;调用remove_cv::type来直接返回…去掉cv的版本，为后面的类型萃取做准备。</li><li>定义is_void，只有void，和其cv版本is_void为true_type。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__is_void_helper</span><br>    : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__is_void_helper</span>&lt;<span class="hljs-type">void</span>&gt;<br>    : <span class="hljs-keyword">public</span> true_type &#123; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span><br>    : <span class="hljs-keyword">public</span> __is_void_helper&lt;<span class="hljs-type">__remove_cv_t</span>&lt;_Tp&gt;&gt;::type<br>    &#123; &#125;;<br></code></pre></td></tr></table></figure><ol><li><p>定义is_integral，方法如前。其中，除了基本类型还定义了<code>__GLIBCXX_TYPE_INT_N_0\1\2\3</code></p><p> 为integral。</p></li><li><p>定义is_floating_point，包括float128。</p></li><li><p>定义is_array，包括array[size]和array[]。</p></li><li><p>定义is_member_pointer，其萃取的方式为_Tp *Cp::<em>，这是一个类型，表示</em>Cp这个类型中类型为_Tp的成员(函数指针或成员)</p></li><li><p>定义is_member_function_pointer和is_member_object_pointer，就是和is_member_pointer一致，在萃取后再通过is_function来区分。</p></li><li><p>定义is_function，有左值引用或者右值引用的或者它的const版本不是const的就是function？</p></li><li><p>定义is_null_pointer，只有nullptr_t及其cv版本。</p></li><li><p>定义is_reference，包括左值引用和右值引用</p></li><li><p>定义is_arithmetic(算数型)，包括整形和小数</p></li><li><p>定义is_fundamental(基础类型)，包括算数型，空，和空指针</p></li><li><p>定义is_object，非function，引用和空类型</p></li><li><p>定义is_scalar(A <em>scalar</em> type is a type that has built-in functionality for the addition operator without overloads)，包括算数型，枚举，指针，member_pointer，空指针。</p></li><li><p>定义is_compound，非基础类型。</p></li><li><p>定义is_same，两个版本，is_same&lt;Tp,Tp2&gt;继承false，is_same&lt;Tp,Tp&gt;继承true？</p></li><li><p>定义is_one_of&lt;type1,type2…&gt;，即是否与后面的任意一个类型相同。</p></li><li><p>定义is_signed_integer，is_unsigned_integer。</p></li><li><p>定义is_standard_integer，包括signed和unsigned integer。</p></li><li><p>定义void_t&lt;…&gt;，对于任何类型都&#x3D;void。</p></li><li><p>定义is_referenceable&lt;Tp,&#x3D;void_t&lt;Tp&amp;&gt;&gt;，通过void_t来判断Tp&amp;到底存不存在，这样，referenceable的类型可以实例化这个模板，而非的就不能，因为不能实例化void_t&lt;Tp&amp;&gt;，能左引就能右引。</p></li><li><p>声明is_trivial，is_trivially_copyable，is_standard_layout（都需要是完整类型）。</p></li><li><p>声明is_empty，is_polymorphic，is_final。</p></li><li><p>定义is_signed&lt;Tp,bool&#x3D;is_arithmetic<Tp>::value&gt;来限定要满足is_arithmetic，然后继承integral_constant&lt;bool，Tp(-1)&lt;Tp(0)&gt;，和is_unsigned。</p></li><li><p>定义declval(int&#x2F;long)，将其返回其类型的一个右值引用，如果Tp是右值引用的话，方式是调用declval&lt;…&gt;(0)，declval(int)返回增加右值引用，declval(long)返回原类型，0即能匹配long也能匹配int。因为要函数不同就必须形参不同。这通过不同的形参的方式好像是比较老了，c++11后就可以使用void_t来进行更简单的处理。</p></li><li><p>声明declval()，调用declval(int&#x2F;long)，使用的时候应该都是declval<Tp>通过引用折叠来获取Tp&amp;&amp;这一类型，当且仅当declval_protector<Tp>::stop为true时。</p></li><li><p>定义extent&lt;…,num&#x3D;0&gt;，如果num&#x3D;0则返回当前最外维大小(unbounded就是0)，否则类似rank递归去掉一维，往外走一维。达到返回第n维大小的效果。</p></li><li><p>定义remove_extent，用Tp[]和Tp[size]去匹配。</p></li><li><p>定义remove_all_extents，即remove_extent的递归版本。</p></li><li><p>定义is_array_known_bounds(知道第0维大小的array)，即extent&lt;…&gt;::value&gt;0。</p></li><li><p>定义is_array_unknown_bounds，首先要is_array，并且extent不知道。</p></li><li><p>定义is_destructible_impl(是否能调用析构函数)，通过declval来获取引用来在不创造实例的情况下调用析构函数，就可以判断是否能调用析构函数了(析构函数返回本类型)。</p></li><li><p>定义is_destructible_safe，空，不知边界的数组和function都是不可的，引用和scalar都是可以的，而其余的通过remove_all_extents规约到前面两种情况。</p></li><li><p>定义is_destructible，首先要是完整的或者无边界数组，并且is_destructible_safe的。</p></li><li><p>上述三个还有要判断是否nothrow的版本，即在is_nt_destructiable_impl中调用析构函数时套一个noexcept()。</p></li><li><p>定义is_constructible&lt;Tp,args…&gt;，is_default_constructible，都要时cp_or_ub(complete or unbounded)类型的，再像前面一样通过引用调用构造函数即可，default_constructible就是没有args…。</p></li><li><p>定义is_copy_constructible，拷贝构造函数的参数就是const Tp&amp;，因此首先判断是否referencable，然后是否constructible&lt;Tp,const Tp&amp;&gt;即可。</p></li><li><p>定义is_move_constructible，与copy一致，只不过最后是constructible&lt;Tp,Tp&amp;&amp;&gt;。</p></li><li><p>定义上述三个constructible的nothrow版本。</p></li><li><p>声明is_(&#x2F;copy&#x2F;move)_assignable及其nothrow版本。</p></li><li><p>声明is_trivially_constructible。</p></li><li><p>定义is_implicitly_default_constructible，即能否使用{}默认构造对象。由于const &amp;能接受临时对象，因此尝试传入{}作为const Tp&amp;。</p></li><li><p>声明is_trivially_copy_constructible，is_trivially_move_constructible，is_trivially_(&#x2F;copy&#x2F;move)_assignable。</p></li><li><p>声明is_trivially_destructible(有析构且有trivially_destructor)。</p></li><li><p>声明has_virtual_destructor。</p></li><li><p>定义alignment_of<Tp>&#x3D;integral_constant&lt;size_t,alignof(Tp)&gt;，即大小为其align的整型常量。</p></li><li><p>定义rank，即几维的数组，通过Tp[]和Tp[size_t]去递归萃取。</p></li><li><p>声明is_base_of</p></li><li><p>定义is_convertible(能否隐式转换)，void转void是可行的，此外，function和array不能作为隐式转换的结果对象的。此外，尝试能否用From这个Type的引用调用构造函数获得的对象调用func(To(这个Type))。及其noexcept版本。</p></li><li><p>定义remove_const和remove_volatile，方法类似extent，即通过Tp const和Tp volatile来萃取Tp。</p></li><li><p>定义add_const，add_volatile和add_cv。</p></li><li><p>定义remove_reference，add_(l&#x2F;r)value_reference(借助is_referencable)。</p></li><li><p>定义cv_selector&lt;type,bool,bool&gt;，第一个bool代表const，第二个代表volatile，将type加上对应的const&#x2F;volatile如果为真。</p></li><li><p>定义match_cv_selector&lt;type1,type2&gt;，根据type1的cv情况对type2进行cv_selector。</p></li><li><p>定义make_unsigned的所有integral版本，(浮点数是没有unsigned版本的)。</p></li><li><p>定义通用的make_unsigned，对所有enum类型和integral类型。但对于bool特化没有make_unsigned。对于所有的类型，都先去掉cv标识符(remove_cv)再进行匹配，匹配完后再通过cv_selector匹配回来。匹配的方法：建立一个可匹配类型，list&lt;所有可匹配的类型&gt;，进行一一匹配。每一次匹配，获取首类型的大小，若≤，则匹配成功，否则去掉第一个，进行递归。在这种情况下w_char，char8&#x2F;16&#x2F;32_t这些没有unsigned版本的类型也用有其对应类型，如char16_t对应unsigned int。</p></li><li><p>定义通用的make_signed，同样对于bool特化没有。匹配的方式是，转化为unsigned，在将其对应的unsigned类型通过前面普通的特化版本来转化为signed版本。</p></li><li><p>定义remove_pointer，通过T*匹配，会将顶层(应该是顶层)的const和volatile去掉，而remove_reference就不会。</p></li><li><p>定义add_pointer，只能给referencable和void加<em>。因为实际上reference本身就是一种“指针”。加的过程就是先remove_reference再直接加</em>。</p></li></ol><h2 id="对齐大小"><a href="#对齐大小" class="headerlink" title="对齐大小"></a>对齐大小</h2><p>假如说对齐大小已经定下来了，并且现在已经放入了一些数据，如果准备加入一个新的数据，如果连着放会导致它被对齐大小的整数倍截断，那么，就会直接跳到对齐大小的整数倍放。对齐大小一般就是结构体中最大类型的对齐大小。总体的目的就是不被截断，能一次读到。提高效率。</p><ol><li>定义最大对齐存储aligned_storage_msa。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">union</span> <span class="hljs-title class_">__type</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __data[_Len];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__attribute__</span>((__aligned__)) &#123;<br>    &#125; __align;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>通过union使得data和struct共享存储空间。由于unsigned char的大小为1字节，因此，相当于申请了大小为Len字节的空间。又因为共享空间的结构体启用了最大对齐，因此，这段空间也就启用了最大对齐。</p><ol><li><p>定义对齐大小不同的存储空间aligned_storage&lt;len,对齐大小&gt;，方法如上。</p></li><li><p>定义strictest_alignment&lt;types…&gt;，两个size_t成员，s_alignment和s_size，存储的是所有的type中最大的对齐大小和最大的大小(比如结构体有三个成员，那么大小可能就不止是对齐大小)。求的方式就是模板元编程递归版本的打擂台。</p></li><li><p>定义aligned_union，使它的大小为strictest_alignment的s_size和要求的Len中的大者。而对齐就是strictest_alignment的s_alignment，并将aligned_storage&lt;S_len,s_alignment&gt;作为它的存储方法。</p></li><li><p>定义decay_selector(进行等价于按值传递函数实参进行的类型转换)。去掉cv符和引用，对于array，去掉一维并转为指针，对于函数，转为指针。</p></li><li><p>定义strip_reference_wrapper，将一个被reference_wrapper包裹的类型的reference_wrapper转为真正的引用。</p></li><li><p>定义enable_if&lt;bool,Tp&gt;，Tp就是在bool成立时::type的值，如果不成立就不存在::type，通过这种方式可以以返回值，模板参数，形参类型等为参数对函数的范围进行约束。相当于在Tp不改变的情况下凭空加上限制条件，或者直接加在后面enable_if<bool>，因为Tp默认是void。</p></li><li><p>定义Require&lt;…type&gt;，即满足多个条件的enable_if。</p></li><li><p>定义common_type&lt;type…&gt;(这些类型都能够隐式转换到的类型)。关键在于下面这句话</p><p> <code>*decltype*(*true* ? std::declval&lt;_Tp&gt;() : std::declval&lt;_Up&gt;())</code></p><p> 由于其中的三元判断既可能输出_Tp类型也可能输出_Up(无关前面是否是个固定的条件)，因此，输出的类型必须是_Tp和_Up的共同类型。再decltype就可以获取其共同类型了。</p><p> 在c++20中，<code>*decltype*(*true* ? std::declval&lt;const _Tp&amp;&gt;() : std::declval&lt;const _Up&amp;&gt;())</code>的引入解决了有const和&amp;因与remove_cv版本类型不一致而导致无法获取共同类型的问题(如const int&amp;和int&amp;应该有共同类型const int&amp;)。</p><p> 为了让这两个同时起效，定义两个函数，每个函数分别有其更劣的重载版本(…)，第一个的更劣版本返回第二个函数decltype的结果，第一个函数判断第一个部分，第二个函数判断第二个部分，成功则返回success_type包裹common_type，否则返回failure_type。</p><p> 对于多个类型，递归地取前两个并用common_type来替换，并保证common_type是success的。</p></li><li><p>对于enum类型声明underlying_type(enum的元素类型)。</p></li><li><p>声明declval_protector，若其成员stop为false则不能进行declval()。</p></li><li><p>定义invoke_result&lt;functor,args&gt;(其type为这个函数这个args的情况下的返回类型)，其中包括普通函数，function包括的对象，成员函数，和类的数据成员(调用的形参的类别是这个类)。此外，还包括其对应的函数指针，函数引用等等。最基本的实现很简单如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">get1</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> a,<span class="hljs-keyword">typename</span> b,<span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">get1</span>&lt;a b::*,args...&gt;&#123;<br>    <span class="hljs-keyword">using</span> type_=a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过a b::*来萃取出其返回类型。</p><p>但是为了适配指针，函数引用等等，实现上进行了一些加工。</p><p>有以下几个要注意的点</p><ol><li><code>decltype(std::declval&lt;_Fn&gt;()(std::declval&lt;_Args&gt;()...)</code>通过调用来测试这个函数是否存在</li><li>将所有的类型分为，普通函数，数据成员指针和成员函数指针，分别进行处理，对于指针和引用来说在declval的时候也要注意区别。</li><li>对于成员来说，验证提供的类是不是拥有这个函数或成员。</li></ol></li><li><p>定义inv_unwrap，类似strip_reference_wrapper，但是strip_reference_wrapper只会去掉一层wrapper，而inv_unwrap会将相关的wrapper外层的cvr都去掉，并去掉这一层。</p></li><li><p>定义detector_or&lt;default，void&lt;op<args>&gt;(void)，&lt;template args…&gt;Op，args&gt;，如果有以args为参数的实例化，则返回op&lt;args…&gt;，否则返回default这个type。</p></li><li><p>声明is_tuple_like。</p></li><li><p>定义swappable及nothrow版本，必须为unbounded或complete类型，要求swap(其declval版本)是可行的，并且反过来也要。并且单独对相同类型的swap进行了特判swap。</p></li><li><p>定义is_invocable及nothrow版本，即这样调用invoke是否可行。对于没有限定返回类型的invoke调用，只需要判断调用invoke_result返回的type是否是个正常的类型。对于有限定返回类型的invoke调用，判断限定的类型是否正常，接着构造一个函数返回值为result::type的函数(无需函数体)，将其返回值传给一个被构造出来的参数为限定返回类型的模板函数，如果一样就能被构造出来，在这一层外再套一层decltype来保证它不被实际执行，也就不需要函数体。之所以不适用declval来调用而是使用构造一个函数的方式是因为declval会返回一个右值引用而右值引用会阻止复制省略，而构造函数不会，它允许。虽然不知道为什么这里需要允许复制省略。</p></li><li><p>定义call_is_nt（是个函数），分类讨论5大情况，成员函数&#x2F;成员指针及其对应引用，和其他情况，分别尝试，返回其noexcept(调用这个对象)的结果，一个普通的bool类型。</p></li><li><p>声明nonesuchbase，和nonesuch(一个析构，拷贝构造及拷贝赋值都被delete的一个类)。</p></li><li><p>声明is_aggregate。</p></li><li><p>声明has_unique_object_representation。</p></li><li><p>定义了很多用来匹配或寻找共同c&#x2F;v&#x2F;ref。</p></li></ol><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三路排序 </title>
    <link href="/hide/%E4%B8%89%E8%B7%AF%E6%8E%92%E5%BA%8F/"/>
    <url>/hide/%E4%B8%89%E8%B7%AF%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="三路排序"><a href="#三路排序" class="headerlink" title="三路排序"></a>三路排序</h1><p>每一次排序分为小于，等于，大于三段，对于拥有大量相同值的数据表现更优</p><p>实现思路，三个指针，一个指向小于部分的尾后，一个指向大于部分的前置，一个指向当前处理的元素，小于就扔到小于部分，大于就扔到大于部分</p><p>但是对于交换回来的小于部分，由于已经是被处理过的，因此是小于等于的，不用再处理。</p><p>而对于交换回来的大于部分，还未被处理过，因此需要再处理，i不能++。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内省排序 </title>
    <link href="/hide/%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/"/>
    <url>/hide/%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="内省排序"><a href="#内省排序" class="headerlink" title="内省排序"></a>内省排序</h1><p>快速排序层数超过log2n的级别时转用堆排序</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数 </title>
    <link href="/hide/%E5%87%BD%E6%95%B0/"/>
    <url>/hide/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>在<strong>调用函数</strong>的时候，会进行两步。</p><ol><li>将<strong>形参实例化</strong>。</li><li>将控制权交给被调<strong>函数</strong>。</li></ol><p>在<strong>调用</strong>时，<strong>形参</strong>与<strong>实参</strong>的个数必须对应，而在此过程中，若类型不同，这将进行<strong>类型转换</strong>。</p><p><strong>形参</strong>可以不被<strong>命名</strong>，如果它在<strong>函数</strong>中不需要被使用，但是不代表程序不应该传入<strong>实参</strong>与它对应。(虽然并不知道这有什么用)</p><p><strong>名字</strong>有<strong>作用域</strong>，<strong>对象</strong>有<strong>生命周期</strong>。</p><p>当<strong>局部变量</strong>在其自身的<strong>作用域</strong>的时候，会隐藏其<strong>外层作用域</strong>的<strong>同名变量</strong>。但是在<strong>作用域</strong>结束之后会，取消隐藏，并且其<strong>值</strong>不变，就好像没有被隐藏过一样。</p><p><strong>局部变量</strong>的<strong>生命周期</strong>取决于它的<strong>定义</strong>方式。</p><h3 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h3><p>会在离开<strong>作用域</strong>之后<strong>自动销毁</strong>的<strong>对象</strong>。</p><p>并不是所有的<strong>局部变量</strong>都是<strong>自动对象</strong>，<strong>静态局部变量</strong>就不是，因为它出<strong>作用域</strong>并不会<strong>销毁</strong>。</p><h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><p>使用<strong>static</strong>修饰词修饰。</p><p>在离开<strong>作用域</strong>时，不会被<strong>销毁</strong>，只会在程序结束的时候被<strong>销毁</strong>。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>没有<strong>函数体</strong>的对<strong>函数</strong>的<strong>定义</strong>就是<strong>函数声明</strong>。类似于<strong>变量</strong>。<strong>声明</strong>时<strong>形参</strong>无需名字。函数声明也被成为函数原型。</p><p><strong>函数声明</strong>应该都写在<strong>头文件</strong>中，而非<strong>源文件</strong>，并且在<strong>源文件</strong>中引用<strong>头文件</strong>。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ol><li><strong>值传递</strong>：传递的<strong>参数</strong>是一个<strong>拷贝</strong></li><li><strong>引用传递</strong>：传递的<strong>参数</strong>是对原本<strong>实参</strong>的一个<strong>引用</strong></li></ol><p>由于<strong>值传递</strong>需要<strong>拷贝</strong>，而<strong>拷贝</strong>需要花时间且有时类没有<strong>拷贝方法</strong>，此时可以用<strong>引用</strong>来进行传递。但是，此时改变它的值会影响到原本的<strong>实参</strong>，因此若是不需要进行修改，则应加上<strong>const</strong>，使用<strong>常量引用</strong>。</p><p><strong>函数</strong>只能返回一个<strong>对象</strong>，虽然可以使用<strong>结构体</strong>，但是也可以通过传入<strong>引用</strong>来作为一种返回<strong>变量</strong>的方式。</p><p>除非是<strong>常量引用</strong>或者<strong>常量指针</strong>，不然<strong>常量</strong>并不能作为<strong>形参</strong>，因为不能向<strong>常量</strong>写值。</p><p>使用<strong>常量引用</strong>还能扩大<strong>函数</strong>的使用范围，使其当<strong>传入参数</strong>为<strong>常量</strong>时也仍然能使用(<strong>字面值</strong>是<strong>常量</strong>)。</p><h3 id="数组传参"><a href="#数组传参" class="headerlink" title="数组传参"></a>数组传参</h3><p>对于<strong>数组</strong>传参，无论<strong>形参</strong>写成什么形式，是<strong>指针</strong>亦或是<strong>数组</strong>，其所接收的是一个<strong>头指针</strong>。</p><p>为了保证<strong>数组不越界</strong>，最好传入一些表示<strong>数组</strong>大小的<strong>形参</strong>，例如在<strong>数组</strong>结尾增加标记，<strong>尾后指针</strong>，<strong>数组</strong>大小等。</p><p>可以传递对<strong>数组</strong>的<strong>引用</strong>，但是也限制了<strong>数组</strong>的大小。</p><p>由于<strong>多维数组</strong>实际上是一个一维的<strong>指针数组</strong>，因此可以通过传递<strong>指针数组</strong>的方式来传递<strong>多维数组</strong>。</p><p><strong>多维数组</strong>也可以通过<strong>a[][大小]<strong>的方式定义，但</strong>编译器</strong>会自动省略第一个维度，将其当成是一个<strong>指针数组</strong>，因此它的<strong>第二维</strong>的大小必须定义，对于更多维并没有进行测试。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p><strong>main</strong>可以有两个从外部运行程序时传入的<strong>参数</strong>。</p><ol><li><strong>int argc</strong>，表示<strong>字符</strong>串的个数</li><li><em>*char *argv[]<strong>，一个</strong>字符串数组**，实际</em>*参数<strong>，它的0号</strong>字符串<strong>是这个</strong>可执行文件<strong>的名字(这并非是在运行时输入的，而是在</strong>程序编译<strong>的时候就已经</strong>存储<strong>的)，从1号</strong>字符串<strong>开始才是正式的</strong>参数**。</li></ol><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>当<strong>实参</strong>的类型相同时，可以使用<strong>initializer_list。</strong></p><p>其类似于<strong>vector</strong>，但是它的元素数量无法改变，与初始化时元素数量相同，且其元素都是<strong>常量</strong>。<strong>默认初始化</strong>时元素个数为0。若进行<strong>赋值</strong>，它会与原<strong>变量</strong>共享相同的元素，而非进行<strong>拷贝</strong>，相当于是<strong>引用</strong>。</p><p>一般只作为<strong>形参</strong>使用，在传入<strong>参数</strong>时使用<strong>列表初始化</strong>。</p><h3 id="省略符"><a href="#省略符" class="headerlink" title="省略符"></a>省略符</h3><p>一般只用于访问<strong>特殊</strong>的<strong>C代码</strong>。</p><p>用法：**(parm_list,…)<strong>或</strong>(…)**</p><p>并不会对<strong>省略符</strong>内的<strong>实参</strong>进行<strong>类型检查</strong>。</p><h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>当<strong>函数</strong>的返回值是<strong>void</strong>时，除了<strong>return;<strong>还可以</strong>return</strong>一个返回值是<strong>void</strong>的<strong>函数</strong>。</p><p>一个非<strong>void</strong>返回类型的<strong>函数</strong>的<strong>return</strong>必须有返回值，但是若是<strong>隐式</strong>返回大部分编译器并不会检查。</p><p>整数类型默认返回1，小数类型<strong>dev</strong>上返回一个非常接近0的数。</p><p>由于<strong>函数</strong>在结束后其所占的<strong>内存空间</strong>会被<strong>释放</strong>，因此不能返回其<strong>局部变量</strong>的<strong>引用</strong>或者<strong>指针</strong>。</p><p>当返回值是一个<strong>非常量引用</strong>时，便是<strong>左值</strong>。</p><p>返回值可以使用<strong>列表初始化</strong>，通过这种方式可以返回<strong>vector</strong>。</p><p><strong>main函数</strong>当失败退出的时候返回的非0值会根据机器而不同。可以使用<strong>cstdlib</strong>中的<strong>EXIT_SUCCESS</strong>和<strong>EXIT_FAILURE</strong>两个<strong>预处理变量</strong>来免除因机器不同而产生的差异，<strong>SUCCESS</strong>是0，<strong>FAILURE</strong>是1。</p><p><strong>main</strong>按书中是不可以调用自己的，但<strong>Dev</strong>中可以。</p><p><strong>复杂类型</strong>的返回有四种方式：</p><ol><li>当类型比较繁琐麻烦的时候最好使用<strong>类型别名</strong>，如在使用<strong>指向数组</strong>的<strong>指针</strong>的时候。由于<strong>函数</strong>不能返回<strong>数组</strong>，所以通过返回<strong>指向数组</strong>的<strong>指针</strong>来间接返回<strong>数组</strong>。</li><li>不使用<strong>类型别名</strong>来返回<strong>数组指针</strong>十分的麻烦，格式：</li></ol><p>$$<br>Type\ (*function \ (paramenter_list)\ )\ [dimension]<br>$$</p><ol><li>这种方式非常的复杂，因此我们可以使用<strong>尾后返回类型</strong>的方式来处理。此处的<strong>type</strong>若使用<strong>数组指针</strong>的话就是*<em>int (</em>)[10]**。</li></ol><p>$$<br>auto\ function\ (paramenter_list)\ -&gt;Type<br>$$</p><ol><li>也可以使用<strong>decltype</strong>来处理，但要注意的是<strong>decltype</strong>不会把<strong>数组</strong>转成<strong>指针</strong>，因此需要加上<strong>解引用号</strong>。</li></ol><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>当使用相同的<strong>函数名</strong>而不同的<strong>形参</strong>时，就是用了<strong>函数重载</strong>。</p><p><strong>main函数</strong>不能被<strong>重载</strong>。</p><p><strong>形参</strong>不同有以下几点要注意的：</p><ol><li><strong>形参</strong>类型，包括类型，<strong>声明符</strong>。但是<strong>类型别名</strong>并不代表类型不同。</li><li>底层<strong>const</strong>会被当做不同，但是顶层不会。</li></ol><p>可以通过<strong>const_cast</strong>来将<strong>常量函数重载</strong>为<strong>非常量</strong>。</p><p><img src="/image/%E5%87%BD%E6%95%B0Untitled.png" alt="Untitled"></p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>函数</strong>内部也可以定义<strong>函数</strong>。当在<strong>函数</strong>内部<strong>重载</strong>外部<strong>函数</strong>的时候，就并不是<strong>重载</strong>，而是<strong>覆盖隐藏</strong>，因为<strong>函数</strong>内部是<strong>局部作用域</strong>，因此会<strong>隐藏外部作用域</strong>的同名。</p><p>在这种情况下，<strong>调用函数</strong>就不能在名字查找时查找到外部的<strong>函数</strong>，即便外部有类型匹配的<strong>函数</strong>，也并不会去调用，只会调用<strong>局部作用域</strong>内的<strong>函数</strong>，即便会报错。</p><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>可以给<strong>形参</strong>指定<strong>默认参数</strong>，但是当一个<strong>形参</strong>被<strong>声明</strong>了<strong>默认形参</strong>，其右侧定义的剩下的<strong>形参</strong>也必须要<strong>声明默认形参</strong>。</p><p>在调用的时候只需从某一个<strong>形参</strong>开始省略，其右侧的所有<strong>形参</strong>也将使用<strong>默认形参</strong>。</p><p>可以通过多次<strong>声明</strong>来增加<strong>默认形参</strong>，但是不允许在这一过程中更改已有的<strong>默认形参</strong>的<strong>值</strong>。</p><p><strong>默认形参</strong>可以被<strong>赋值</strong>为<strong>变量</strong>或者<strong>函数</strong>。当<strong>变量</strong>或者<strong>函数</strong>的返回值改变的时候，其默认的<strong>值</strong>也会改变。</p><p>但是当在<strong>内作用域</strong>内重新<strong>定义</strong>一个用作<strong>默认参数</strong>的<strong>变量</strong>或者<strong>函数</strong>时，其新<strong>赋</strong>的<strong>值</strong>并不会改变<strong>默认形参</strong>的<strong>值</strong>，它<strong>隐藏</strong>了外部的同名，但是<strong>默认形参</strong>使用的仍然是外部<strong>形参</strong>的。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p><strong>函数</strong>比普通的<strong>表达式</strong>执行的速度与消耗更慢也更大，因此当<strong>函数</strong>内容较少时可以添加<strong>关键字inline</strong>将<strong>函数</strong>转为<strong>内联函数</strong>，此时再<strong>编译</strong>时会将所有<strong>调用函数</strong>的地方替换为<strong>函数</strong>的内容，但是<strong>inline</strong>只是一个建议，而非强制，<strong>编译器</strong>可以选择忽略。</p><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>用于作为<strong>常量初始化</strong>时的一部分时，最好使用<strong>constexpr修饰</strong>。</p><p><strong>函数</strong>的<strong>形参</strong>必须是<strong>常量</strong>，<strong>函数</strong>的返回值也必须是<strong>常量</strong>，但是返回值可以是一个<strong>表达式</strong>，但是要保证当<strong>形参</strong>为<strong>常量</strong>时，其返回值也必须为<strong>常量值</strong>。</p><p>由于在<strong>编译</strong>时会自动将<strong>函数</strong>替换为其结果，因此<strong>constexpr函数</strong>会被<strong>隐式声明</strong>为<strong>inline</strong>。</p><p>由于<strong>constexpr定义</strong>必须一致，因此一般会直接在<strong>头文件</strong>中<strong>定义</strong>，而非在<strong>源文件定义</strong>。</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p><strong>assert</strong>是一种<strong>预处理宏</strong>，定义于<strong>cassert头文件</strong>。</p><p>用法**assert(expr)**。</p><p>当<strong>expr</strong>为假时，就会终止程序。</p><p>一般用于检查“不能发生”的情况。</p><p><strong>assert</strong>使用无需<strong>using声明</strong>，因为<strong>宏</strong>是<strong>预处理器</strong>处理而非<strong>编译器</strong>。</p><h3 id="NDEBUG（Not-DEBUG）"><a href="#NDEBUG（Not-DEBUG）" class="headerlink" title="NDEBUG（Not DEBUG）"></a>NDEBUG（Not DEBUG）</h3><p><strong>NDEBUG</strong>是一个<strong>预处理变量</strong>。</p><p>可以在<strong>编译</strong>程序的时候指定是否<strong>定义NDEBUG</strong>。</p><p>当<strong>NDEBUG</strong>没有被<strong>定义</strong>时，<strong>assert</strong>会正常工作，并且可以通过</p><p><strong>#ifndef NDEBUG</strong>在内部写一些只有在<strong>调试</strong>时需要的<strong>调试代码</strong>，例如<strong>输出</strong>程序错误等。</p><p>在其中有四个非常有用用于<strong>调试</strong>的<strong>预处理变量</strong>：</p><p><img src="/image/%E5%87%BD%E6%95%B0Untitled%201.png" alt="Untitled"></p><h3 id="函数匹配的规则"><a href="#函数匹配的规则" class="headerlink" title="函数匹配的规则"></a>函数匹配的规则</h3><ol><li>寻找所有同名的可见的<strong>函数</strong>。</li><li>从中去除所有不能匹配的，即即便类型转换也不能匹配的<strong>函数</strong>。</li><li>在剩下的<strong>函数</strong>中进行最优匹配。</li></ol><p>当没有找到匹配，则会报错。</p><h3 id="最优匹配"><a href="#最优匹配" class="headerlink" title="最优匹配"></a>最优匹配</h3><p>若有且仅有一个<strong>函数</strong>满足下列条件则匹配成功：</p><p><img src="/image/%E5%87%BD%E6%95%B0Untitled%202.png" alt="Untitled"></p><p>即在其他情况下相平的情况下有一点更优。</p><p>若没有，则报<strong>二义性错</strong>。</p><p>当使用<strong>重载函数</strong>的时候最好不要<strong>强制类型转换</strong>。</p><h3 id="优的顺序"><a href="#优的顺序" class="headerlink" title="优的顺序"></a>优的顺序</h3><ol><li><p>精确匹配</p><p> 类型相同，<strong>数组</strong>&#x2F;<strong>函数</strong>转<strong>指针</strong>，对顶层<strong>const</strong>操作</p></li><li><p>对底层<strong>const</strong>操作</p></li><li><p>小整数到大整数</p></li><li><p>算数类型转换&#x2F;<strong>指针</strong>转换</p></li><li><p><strong>类</strong>类型转换</p></li></ol><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>一个<strong>函数指针</strong>的类型只由<strong>形参</strong>和返回类型决定。当要<strong>声明</strong>的时候，只需要将<strong>函数名</strong>部分改为<strong>指针</strong>即可，但必须加括号。</p><p>$$<br>Type\ (*name)(param_list);<br>$$</p><p>直接使用**&#x3D;<strong>进行</strong>赋值<strong>。在使用时可以直接将</strong>指针名<strong>作为</strong>函数别名**，$name(param_list)$。</p><p>当<strong>函数指针</strong>指向一个<strong>重载函数</strong>时，会根据<strong>函数指针</strong>的<strong>形参表</strong>来进行精准匹配。</p><p><strong>函数</strong>可以使用<strong>函数指针</strong>来传入<strong>函数</strong>作为<strong>实参</strong>。格式与<strong>声明</strong>时相同，但最好还是使用<strong>类型别名</strong>与<strong>decltype</strong>来简化使用，也更加易于理解。</p><p>与<strong>数组</strong>一样，<strong>函数</strong>也可以用<strong>指针</strong>来返回。</p><p>函数会在传参的时候自动转换为函数指针。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>变量与基本类型 </title>
    <link href="/hide/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/hide/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="变量与基本类型"><a href="#变量与基本类型" class="headerlink" title="变量与基本类型"></a>变量与基本类型</h1><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://files.catbox.moe/u5ptwi.png" alt="https://files.catbox.moe/u5ptwi.png"></p><p>char类型有三种，char，与有符号的，无符号的，但是实际上只有两种char，有符号与无符号的，char是哪一种由编译器决定。</p><p>少用float多用double。</p><p>无符号超出范围会取mod，而有符号超出范围会报错。 </p><p>带符号与无符号在一起，带符号会转化为无符号。</p><p>若两个char字面值仅由空格，缩进，换行分割则视为一个整体。</p><p>开头有0为八进制，有0x为十六进制</p><p>+数字为八进制的char，只管前3个，\x+数字为十六进制的char，管后面的所有。</p><p><img src="/image/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8BUntitled.png" alt="Untitled"></p><p>nullptr是指针的字面值。</p><h3 id="初始化与命名"><a href="#初始化与命名" class="headerlink" title="初始化与命名"></a>初始化与命名</h3><p>事实上在C++语言中，初始化和赋值是两个完全不同的操作。</p><p>初始化不是赋值，初始化的含义是剑建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p><p>列表初始化的表现形式为使用花括号来初始化，如&#x3D;{}或者{}，会在数据精度存在丢失可能的情况下报错。</p><p>声明：名称与类型</p><p>定义：声明+实体（申请存储空间，初始化等）</p><p>对于一个变量加上$extern$关键字且不以显式初始化即表示声明。</p><p><img src="/image/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8BUntitled%201.png" alt="Untitled"></p><p>当全局变量与局部变量相同的时候，局部变量会在块域内覆盖全局变量。内层的局部变量也会覆盖较外层的局部变量，但当离开作用域后覆盖也会失效，若是要在内层访问全局变量，只需加上作用域解析运算符：：即可，但是不能访问较外层但非全局变量的变量。</p><h3 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h3><p>引用在定义后无法换绑，因此必须初始化。当引用初始化时被赋为另一个引用时，会绑定另一个引用绑定的变量。</p><p>由于引用没有地址，所有指针无法指向引用。</p><p>void*是一种特殊的指针，它能指向各种类型，但是，并不能对它所指向的对象进行操作，因为不清楚它指向的</p><p>类型修饰符如*,&amp;不过是声明符的一部分。</p><p>当为…*&amp;时，是一个对指针的引用。</p><p>nullptr指针空值。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const常量只能获取它的信息，但不能改变它。const仅在当前文件内可用，若是要使其在其他文件中可用，需要加上extern关键字。</p><p>const … &amp;，常量引用，只能引用常量，所能做的事与const相同。</p><p>常量引用可以绑定非常量变量。当类型一致时，和普通的引用没有任何区别。当并非绑定变量而是表达式或者函数时，其所绑定的值将是该表达式或函数返回值的临时量，并不会因为其内部值的改变而改变。当类型不同时，编译器会增加一句先将其转换为const类型的常量，接着将引用指向它。</p><p><img src="/image/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8BUntitled%202.png" alt="Untitled"></p><p>但即便引用了非常量，也不能通过常量引用来改变它。</p><p>常量只能被常量引用引用，但常量引用可以引用非常量。</p><p>常量指针也和常量引用差不多，但是类型不能不一样。</p><p>但是常量指针只是其指向的地址是固定的，因此常量指针是否能改变其指向的对象取决于其对象的类型。</p><blockquote><p>所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去玫变所指对象的值</p></blockquote><p>由于指针与其所指向的类型是完全相同的，因此指向这个指针的指针也与其最终所指向的量的类型是相同的。若是要定义一个指针为常量，将$<em>$改为$^</em>const$，当为二级指针的时候，将$**$改为$^<em>const\ ^</em>const$，如指向一个（指向int常量的常量指针）的常量指针，$const\ int\ ^<em>const\ ^</em>const$.</p><p>对于一个指针，若它本身是常量，则为顶层const。若它指向的是一个常量，则为底层const。</p><p>当为顶层const时，只能作右值。</p><p>当为底层const时，需要保证左值与右值的底层一致或者左值是常量右值是非常量。</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>当定义时是一个常量，且初始化为一个常量（即不运行这个值就已经确定的）时候，这就是常量表达式（const expression），可以通过constexpr关键字来确保这是一个常量表达式。此外，也可以通过对函数类型增加这一关键字来确保其可以作为常量表达式的一部分。会在编译的时候就会计算完成并替代。</p><p>能够被声明constexpr的变量类型必须为字面值类型。引用和指针也能被声明，但是其初始化只能指向固定地址或者nullptr。此外，由于函数体内的变量不是固定地址，故constexpr指针不能指向这些变量，但可以在函数体内定义全局变量（拥有着固定的地址），可以被指向。</p><p>constexpr保证为顶层const。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>typedef A B，B是A的别名。实际上比这复杂很多，还是用using比较好。</p><p>using A&#x3D;B，A是B的别名</p><p>另外可以使用类型修饰来构造复合类型。</p><p>可以通过替换的方式来理解，但是要注意的是要加上括号来理解。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>通过初始化的值的类型来判断类型，因此必须初始化。</p><p>当初始值为一个引用时，会直接代换为其引用的对象。</p><p>会保留底层const但会忽略顶层const。</p><p>因此auto不可能推断出顶层const，需要在auto前增加const关键字使其推断为const。</p><p>auto中也可以使用类型修饰符，但需保证初始值是一个类型。</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype用在不想使用用来判断类型的表达式作为初始值的情况。decltype(表达式)代替类型关键字。decltype并不会对其表达式的类型作任何改变，而会直接传过来，引用和指针也会被传出来。</p><p><strong>解指针所得的是对其指向变量的一个引用，而非其指向的变量本身。</strong></p><p>若是decltype中一个变量被加上了括号，那么它就会变成一个引用类型。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>struct在初始化时可以为其每一个成员定义一个初始值，若是没定义，将会被默认初始化。</p><p>头文件里通常包含只能被定义一次的实体。</p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>#include会在预处理时将其自身替换为头文件的内容。</p><p>#define 将一个名字设为预处理变量</p><p>#ifdef 当且仅当变量已被定义时为真</p><p>#ifndef 当且仅当变量未被定义时为真</p><p>#endif if语句结束</p><p>预处理器无视作用域。</p><p>为了防止与其他实体产生名字冲突，预处理中将其大写。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>默认初始化：瞎几把初始化</li><li>值初始化：若为普通类型，初始化为0，否则按类定义初始化。</li></ol><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图灵完备 </title>
    <link href="/hide/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    <url>/hide/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h1><ol><li>当前字节数+-1</li><li>向前后移动一个字节</li><li>输入输出当前字节的内容</li><li>循环的开始与结束</li></ol><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串、向量和数组 </title>
    <link href="/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>通过using namespace::name；的方式来直接使用命名空间的名称。如cin就是using std::cin;</p><p>头文件不应该包含using，避免在引用头文件时对程序的内容进行误判。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string定义在std命名空间中。</p><p>拷贝初始化：初始化中包含＝。</p><p>直接初始化：初始化中不包含&#x3D;。</p><p>getline(is,var)</p><p>size()返回的类型是string::size_type。且返回值是一个无符号整数。</p><p>当进行相加时，加号左右必须有一个为string类型（不是字符串字面值，字面值与string不是同一种类型）(从左到右)。</p><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84Untitled.png" alt="Untitled"></p><p>使用for-range来遍历序列。</p><p>for( auto i:序列)来遍历序列，如python中for item in list。</p><p>使用auto &amp;i来用引用来改变序列中的值。</p><p>当使用&amp;&amp;时，若第一个条件为假，就不再继续判断下去。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>模板通过提供的信息来实例化。</p><p>引用不是对象，不能作为模板的元素。</p><p>在c++11中，$vector&lt;vector<int>&gt;$无需再写成$vector&lt;vector<int>\ \ &gt;$。</p><p>可以通过&#x3D;或者()来对vector进行复制赋值。vec2(vec1)</p><p>对vector进行列表初始化vector&lt;…&gt; name{ele1,ele2,…}</p><p>vec(个数,ele(可省略))，当省略时会默认初始化。</p><p>()与{}的初始化方式是不同的，当且仅当提供的参数不能用来初始化，会考虑其他初始化的方式。</p><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84Untitled%201.png" alt="Untitled"></p><p>当且仅当其中的所有元素相同时，初始化的效率优于建立一个空的vector。</p><blockquote><p>范围for语句体内不应改变其所遍历序列的大小。</p></blockquote><p>vector.size()返回的类型是vector<T>::size_type。</p><p>当vector中的元素可比较时，vector之间也是可比较的。</p><blockquote><p>确保下标合法的一种有效手段就是尽可能使用范围for语句。</p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><em><strong>begin()<em><strong>返回指向第一个元素的</strong></em>迭代器</strong></em></p><p><em><strong>end()<em><strong>返回指向最后一个元素后面一个位置的</strong></em>迭代器</strong></em>（<em><strong>尾后迭代器</strong></em>）</p><p>当容器为空，<em><strong>begin()<em><strong>返回的也是</strong></em>尾后迭代器</strong></em>。</p><p>由于很多的<em><strong>标准库</strong></em>都不支持&lt;或者下标，因此最好多用≠与迭代器。</p><p>当获取<em><strong>begin()<em><strong>或</strong></em>end()<em><strong>时，若是</strong></em>vector</strong></em>元素为<em><strong>常量</strong></em>，则返回<em><strong>常量迭代器</strong></em>，若不是，则<em><strong>普通迭代器</strong></em>。</p><p>可以通过<em><strong>cbegin()<em><strong>和</strong></em>cend()<em><strong>来固定获取</strong></em>常量迭代器</strong></em>。</p><p><em><strong>(<em>t).num</em></strong>和</em><strong>t→num</strong>*是完全一致的，没有区别。</p><p>两个<em><strong>迭代器</strong></em>相减所得的类型是<em><strong>difference_type</strong></em>，是<em><strong>带符号整数</strong></em>。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><em><strong>数组</strong></em>在定义时的大小必须为<em><strong>常量表达式</strong></em>。</p><p>不能使用<em><strong>auto</strong></em>来推断。</p><p>*<em><strong>p[10]   一个存放指针的数组</strong></em></p><p><em><strong>&amp;p[10]   不存在</strong></em></p><p>***(<em>p)[10]      一个指向数组的指针</em>**</p><p><em><strong>(&amp;p)[10]     一个对数组的引用</strong></em></p><p><em><strong>数组</strong></em>从内向外看类型。</p><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84Untitled%202.png" alt="Untitled"></p><p><em><strong>数组</strong></em>的下标最好使用<em><strong>size_t</strong></em>类型（一种足够大的类型），被定义在<em><strong>cstddef</strong></em>。</p><p>**&#x3D;{}<strong>与</strong>&#x3D;{0}**等价。</p><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84Untitled%203.png" alt="Untitled"></p><p>当使用<em><strong>auto</strong></em>来推断一个以<em><strong>数组</strong></em>来赋值的<em><strong>数组</strong></em>时，会判断出一个<em><strong>指针</strong></em>，指向首元素。</p><p>而<em><strong>decltype</strong></em>就没有这个问题。</p><p>虽然对于<em><strong>尾后迭代器</strong></em>不能<em><strong>解引用</strong></em>，但我们仍然可以去获取它的地址。</p><p>为了防止误获取地址，可以使用<em><strong>begin(arr)<em><strong>和</strong></em>end(arr)<em><strong>两个</strong></em>标准库</strong></em>函数来获取<em><strong>头</strong></em>与<em><strong>尾后指针</strong></em>。</p><p>但这两个<em><strong>指针</strong></em>相减的类型是<em><strong>ptrdiff_t</strong></em>类型，是<em><strong>带符号整数</strong></em>。</p><p>当以<em><strong>数组</strong></em>中的某个元素的地址作为指针时，也可以将它当做<em><strong>数组</strong></em>来使用，只不过<em><strong>下标</strong></em>就是从当前位置作加减了。</p><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>以<em><strong>’\0’</strong></em>(<em><strong>空字符</strong></em>)作为结尾的字符串。</p><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84Untitled%204.png" alt="Untitled"></p><p><em><strong>C风格字符串</strong></em>的<em><strong>函数</strong></em>必须传入<em><strong>C风格字符串</strong></em>。</p><p>将<em><strong>string</strong></em>转为<em><strong>C风格字符串</strong></em>，<em><strong>str.c_str()<em><strong>，返回值为一个</strong></em>常量字符指针</strong></em>。</p><p>但在使用后最好重新拷贝一份结果。</p><p>可以用<em><strong>数组</strong></em>来初始化<em><strong>vector</strong></em>，<em><strong>vec</strong></em>(<em><strong>头指针</strong></em>，<em><strong>尾后指针</strong></em>)，可以只是<em><strong>数组</strong></em>的一部分。</p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>因为<em><strong>引用</strong></em>也可以<em><strong>引用数组</strong></em>，因此<em><strong>多维数组</strong></em>也可以通过<em><strong>range for</strong></em>来遍历，用<em><strong>auto</strong></em>来写对<em><strong>数组引用</strong></em>的类型。但是除了最内层的<em><strong>循环</strong></em>以外，所有的<em><strong>循环</strong></em>都应该是<em><strong>引用</strong></em>，不然会将其判断为<em><strong>指针</strong></em>而非<em><strong>数组</strong></em>。</p><p>虽然可以把<em><strong>多维数组</strong></em>看做一个很长的换行的<em><strong>数组</strong></em>，但是，当我们说它的<em><strong>声明符</strong></em>的时候，是一个指向<em><strong>数组</strong></em>的<em><strong>高维指针</strong></em>，而非指向<em><strong>首元素</strong></em>的<em><strong>一级指针</strong></em>，虽然它们的<em><strong>地址</strong></em>完全相同。当对于这个<em><strong>声明符</strong></em>＋1的时候，它并非指向第二个<em><strong>元素</strong></em>，而是指向第二行<em><strong>数组</strong></em>。</p><p>当使用<em><strong>begin()<em><strong>或</strong></em>end()<em><strong>时，获取的得到的也并非是</strong></em>指向变量的指针</strong></em>，而是<em><strong>指向数组的指针</strong></em>。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希相关 </title>
    <link href="/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/"/>
    <url>/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串哈希相关"><a href="#字符串哈希相关" class="headerlink" title="字符串哈希相关"></a>字符串哈希相关</h1><p>可以通过前缀的方式o(n)预处理o(1)查询所有子串的hash</p><p><strong>最多k次失配的匹配问题</strong></p><p>通过二分来找出当前失配的位置，然后截去，继续匹配</p><p><strong>最长公共子串</strong></p><p>二分长度，对于每个长度进行hash求交集看是否存在</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序 </title>
    <link href="/hide/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/hide/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>每次以一定的间隔，将间隔这么大的元素分为一组，进行插入排序。</p><p>不断减小间隔。</p><p>在每一次排序的过程中，从前往后遍历每一次遍历过程中都把当前的这个元素当成要插入的元素，那么，疯狂向前交换，直到不能交换了（也就是到位置了，因为前面都是有序的）</p><p>时间复杂度跟选择的间隔大小很相关。</p><p>当前最优的最劣复杂度是$O(Nlog^2N)$，使用的间隔是$2^p\cdot3^q$。</p><p>但最简单的但复杂度也比较优的一个间隔是$h_{k+1}&#x3D;3h_k+1$，复杂度大约是$O(N^{1.5})$，应该吧。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开始 </title>
    <link href="/hide/%E5%BC%80%E5%A7%8B/"/>
    <url>/hide/%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>当istream (istream) 对象输入的数据类型错误或者输入了文件结束符，其自身会返回false，但并不会报错。</p><p>Ctrl+Z可以输入文件结束符。其他系统中是Ctrl+D。</p><p>return 后可以跟任意数，其在终端中也会在程序结束时显示出来，如1就是1，2就是2，0就是0，但当数字超过unsigned int的范围的时候，其返回值会因为系统的不同而不同。</p><p>缓冲区(buffer)个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地删新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout:程序非正常终止时也会刷新Cout。</p><p>操纵符(manipulator)对象，如std:endl,在读写流的时候用来“操纵”流本身。</p><p>cerr没有缓冲区，用来输出错误及与正常逻辑无关的东西。</p><p>clog有缓冲区，用来输出日志到文件。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>指令系统 </title>
    <link href="/hide/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/hide/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><ol><li><p>宏指令</p><p> 由多条机器指令组成，属于软件。</p></li><li><p>微指令</p><p> 直接控制机器</p></li><li><p>机器指令</p><p> 大概就是汇编，由微指令组成</p></li></ol><p>指令集：机器指令的合集</p><p>cisc：复杂指令系统计算机(正确性不保证，且很多指令效率低下浪费资源)</p><p>risc：精简指令系统计算机(减少了很多使用频率低下的指令)</p><p>操作码：等长</p><p>地址码：可能二地址码到1地址码，三地址码到3地址码</p><p>SS   存储器-存储器类型<br>RS   寄存器-存储器类型<br>RR   寄存器-寄存器类型</p><p>零地址指令：1. 不需要地址 比如中断 2. 处理器知道应该是什么地址</p><p>寻址：PC寄存器程序计数器</p><p>数据类型：地址数据，数值数据，字符数据，逻辑数据</p><p>寻址方式：</p><ol><li>隐含寻址</li><li>立即寻址 立即数</li><li>直接寻址 提供操作数的直接地址</li><li>间接寻址 根据存放操作数的地址的块的地址</li><li>寄存器寻址 操作数就存放在寄存器中</li><li>寄存器间接寻址 根据存放操作数的地址的寄存器</li><li>偏移寻址 对当前程序计数器PC的偏移量</li><li>偏移寻址：基址寻址 根据基址地址 算偏移量</li><li>偏移寻址：变址寻址 指令提供基址 偏移量在变址寄存器中</li><li>段寻址 将存储器划分为多段</li></ol><p>ARM、MIPS指令集大多数指令仅支持寄存器寻址和立即寻址，仅Load和Store能进行直接寻址</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>标准库 </title>
    <link href="/hide/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/hide/%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p><a href="https://lhish.github.io/hide/IO">IO</a></p><p><a href="https://lhish.github.io/hide/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8">顺序容器</a></p><p><a href="https://lhish.github.io/hide/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95">泛型算法</a></p><p><a href="https://lhish.github.io/hide/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8">关联容器</a></p><p><a href="https://lhish.github.io/hide/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98">动态内存</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型算法 </title>
    <link href="/hide/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <url>/hide/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>能够通用于各种容器的算法。</p><p>算法的一切都是基于容器通用的迭代器与容器元素类型的自己的函数来进行的。因此能够泛化。因此，不管容器为何，算法都是能用的。但是由于只使用迭代器，算法并不能改变底层容器的大小，虽然有可以插入元素的迭代器存在。</p><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>最好使用cbegin()与cend()</p><ol><li><p>find(begin,end,val)</p></li><li><p>find_if(begin,end,predicate)</p><p> 对于元素调用谓词，若谓词返回为非0值则算成功。</p></li><li><p>accumulate(begin,end,初始值)</p><p> 虽然允许元素与初值的类型不同，但是必须得能够相加才行。</p></li><li><p>equal(begin1,end1,begin2)</p><p> 对于三参数迭代器参数都需要保证第二个容器的大小大于等于第一个，因为其并不会检查当前访问元素是否存在，而是直接访问，因此会访问不存在的元素，产生报错。</p></li></ol><h3 id="写元素算法"><a href="#写元素算法" class="headerlink" title="写元素算法"></a>写元素算法</h3><p>需保证原大小大于写入新序列的大小。</p><ol><li><p>fill(begin,end,val)</p></li><li><p>fill(begin,num,val)</p><p> 需要保证num小于等于begin到容器末尾的距离</p></li><li><p>replace(begin,end,originalnum,replacenum)</p></li></ol><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器?"></a>插入迭代器?</h3><p>可以使用back_inserter(容器)来获取容器对应的插入迭代器。</p><p>给插入迭代器赋值会将所赋的值作为一个新的元素插入其中。相当于调用push_back()。</p><p>可以用于算法中。</p><p>fill_n(back_inserter(vector),num,val)</p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>copy(begin,end,target’sbegin)</p><p>仍要注意不要越界，返回指向copy完后的一位</p><p>多数算法提供了拷贝版本，将结果写入一个新的容器而非在原容器上进行更改。</p><p>function_copy(begin,end,back_inserter(newvec),…)</p><h3 id="重排算法"><a href="#重排算法" class="headerlink" title="重排算法"></a>重排算法</h3><ol><li><p>sort(begin,end,cmp)</p></li><li><p>unique(begin,end)</p><p> unique作为算法，并不能改变容器的元素个数，不能进行删除，因此其所做的是将不重复元素放到容器的前部，并返回一个指向不重复元素尾后迭代器，但是这之后的元素并不是重复元素，是未知的。</p><p> 最后需要调用erase来真正的消除。</p></li></ol><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词是一个返回可用作条件的可调用的表达式，一般使用函数。</p><p>有一元谓词与二元谓词。</p><p>接受谓词的算法对输入序列的元素调用谓词。元素类型必须能转换为谓词的参数类型。</p><p>可以给sort第三个参数一个二元谓词来指定排序顺序。</p><p>stable_sort可以保证“相等”元素的顺序按照原本的顺序。</p><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>for_each(begin,end,func)</p><p>对每一个元素执行一元谓词func。</p><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><ol><li>函数</li><li>函数指针</li><li>重载调用运算符的类</li><li>lambda</li></ol><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>可以看作一种内联函数。</p><p>$$<br><a href="param_list">capture\ list</a>-&gt;return_type{function\ body}<br>$$</p><p>函数体与形参表可以忽略。</p><p>捕获列表表示其中定义的局部变量(通常为空)。</p><p>→与return_type可以一起省略。</p><p>必须使用尾置返回。</p><p>当把一个变量设置为lambda类型后，就可以通过调用运算符调用它。</p><p>lambda不能设置默认参数，因此实参与形参类型应该数量相同且相符。</p><p>lambda与普通函数最大的不同就是它能够不通过形参表而通过捕获列表来将作用域外部的变量传入作为局部变量，并且可以直接使用局部static变量与全局变量（cout也算是全局的）。</p><p>通过这种方式能够防止某些算法只允许一元谓词或二元谓词。</p><p>定义lambda实际上是定义了一个新的类。并以之创建了一个类对象。auto的类型就是这个新创建类型的名字。</p><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>当使用值传递时，其将在创建时进行拷贝。$&#x3D;name$</p><p>而使用引用拷贝，其局部变量就会根据其外部引用的变量的变化而变化。$&amp;name$</p><p>当捕获指针或者引用时，需要保证在调用时还存在并且正确。</p><p>可以使用隐式捕获。通过第一位使用&amp;或者&#x3D;来指定默认传递方式，将表示所有隐式传递的变量都是使用该方式来传递。其后可以增加显式捕获的变量，但是必须是采用不同方式传递的变量。</p><p>一般来说值传递的变量不在函数体中进行更改，但可以在参数列表后加上mutable来声明要改变。</p><p>而通过引用传递可以改变其引用的值。</p><p>当一个lambda包括return以外的语句时，若是不显式指定，return_type就会被判断为void类型，然后就报错了。</p><p>建议所有捕获列表为空的lambda都用函数写。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>通过bind也能实现lambda解决的问题。</p><p>$$<br>auto\ newfunc&#x3D;bind(func,args_list)<br>$$</p><p>通过调用newfunc来间接给func传入参数并调用。</p><p>newfunc所接收到的参数将会有$_n$的别名，代表newfunc接收到的第n个参数。</p><p>通过在args_list使用$_n$可以指定这些参数该如何传入func，并且在args_list可以直接使用变量指定传入的参数的值。</p><p>$_n$是定义在std命名空间的placeholders空间的，placeholders定义在functional头文件中。</p><p>bind不仅可以用来转换一元谓词，也可以更改参数的顺序。</p><p>bind所做的是拷贝参数，若是要传递引用参数，则需要用ref(val)或cref(val)来获取其的一个可拷贝的引用。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ol><li><p>插入迭代器</p><ol><li>back_inserter调用push_back</li><li>front_inserter调用push_front</li><li>inserter(val,iterator)，调用insert，并使迭代器指向其原本指向的</li></ol><p> <img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled.png" alt="Untitled"> </p></li><li><p>iostream迭代器</p><p> istream_iterator，需要通过&lt;&gt;指定读入类型。</p><p> 初始化时可以绑定到istream对象，而当istream为空或者IO错误时，与未绑定的迭代器相等。</p><p> <img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%201.png" alt="Untitled"></p><p> 通过++来读入下面一个值。可以将其当做一个一次性的vector容器。以未绑定的对象来作为其结尾。</p><p> 其并不是立即从流中读取值，而是可能会延迟，但是保证在解引用之前已经完成了读取。</p><p> ostream_iterator，相当于一个cout，但是通过赋值来输出。</p><p> <img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%202.png" alt="Untitled"></p><p> 必须绑定ostream，并且可以指定每次输出后输出一个固定的字面值。类似于python中的print的end非常相似。</p><p> 当要输出一个容器时，可以通过copy的方式。</p><p> 流迭代器对于任何定义了输入与输出运算符的类都可以使用。</p></li><li><p>反向迭代器</p><p> 通过rbegin和rend来获取容器的尾迭代器与首前迭代器。</p><p> 其递增与递减是正好相反的。</p><p> 若给sort传入反向迭代器，就是逆向排序了。</p><p> 可以看作是将整个容器倒序后的正常迭代器，因此其所有的行为都将是逆序的。</p><p> 可以点运算符调用base()来将自身转换为普通迭代器。</p></li></ol><h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p>算法是对迭代器的操作，会对迭代器的权限有要求，也仅会对迭代器的权限有要求，其他都不重要，因此分为了5个类别。</p><p><img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%203.png" alt="Untitled"></p><p>编译器不会因为给算法传入错误的迭代器而报错。</p><p>算法除了传入一个迭代器范围(begin,end)外，可能会传入第二个迭代器范围，其他参数，与一个表示算法可以写入的目的位置的迭代器。</p><h3 id="dest"><a href="#dest" class="headerlink" title="dest"></a>dest</h3><p>算法假定向这个位置写入无论多少个元素都是安全的。</p><ol><li>若为指向容器的迭代器，会直接写入覆盖容器原本的元素。</li><li>插入迭代器或ostream_iterator。</li></ol><h3 id="算法的命名"><a href="#算法的命名" class="headerlink" title="算法的命名"></a>算法的命名</h3><ol><li>有的算法提供重载版本，重载的版本可以传入谓词。</li><li>有_if版本的算法，将比较相等改为是谓词为真。</li><li>拷贝与非拷贝版本。</li></ol><p>对list与forward_list有一些特定的成员函数代替通用算法。</p><p><img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%204.png" alt="Untitled"></p><p><img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%205.png" alt="Untitled"></p><p><img src="/image/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95Untitled%206.png" alt="Untitled"></p><p>不像其他的通用算法，专用于这二者的成员函数会改变容器中的结构，因此不能使用算法，只能使用成员函数。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类 </title>
    <link href="/hide/%E7%B1%BB/"/>
    <url>/hide/%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的重点在于两点：</p><ol><li>数据抽象。<ol><li>接口。用户所能使用的方法。</li><li>实现。实现接口的背后的原理。</li></ol></li><li>封装。隐藏实现的部分。</li></ol><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>成员函数就是属于类对象的函数。隶属于成员本身。通过点运算符来调用。</p><p>声明时必须在类内部。而定义可以在类之外。</p><p>非成员函数，并不是类的一部分，不能被类对象调用。但希望可以对类对象进行操作，或者对多个类对象进行操作。</p><p>可以被重载。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>所有的成员函数，都有一个隐式参数this，一个常量指针指向调用这个函数的类对象。通过这种方式告诉成员函数是哪一个类对象在调用它。</p><p>$$<br>a.b()\&#x3D;class_name::b(&amp;a)<br>$$</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>由于this是一个指向非常量的常量指针，因此常量对象不能调用普通成员函数，因为底层const不同。</p><p>通过在函数的形参表后增加const关键字使得将this转为指向常量的常量指针，通过这种方式使得常量对象可以调用该函数，也就是const成员函数。</p><p>const成员函数常用来获取类的数据成员。并且在此过程中不能对类成员产生更改。</p><h3 id="成员与成员函数"><a href="#成员与成员函数" class="headerlink" title="成员与成员函数"></a>成员与成员函数</h3><p>在编译时，会先编译成员的声明，后编译成员函数，因此成员函数可以任意调用成员。</p><h3 id="在外部定义成员函数"><a href="#在外部定义成员函数" class="headerlink" title="在外部定义成员函数"></a>在外部定义成员函数</h3><p>在外部定义成员函数需要在函数名前增加类作用域，通过这种方式将这个函数的这个块，也就是作用域声明在类的作用域内，使其能够调用类的成员函数与成员。</p><h3 id="成员函数的返回值"><a href="#成员函数的返回值" class="headerlink" title="成员函数的返回值"></a>成员函数的返回值</h3><p>当成员函数的作用类似于某个内置运算符时，应该尽力去模仿这个运算符。如形参与返回值类型。</p><p>当我们希望返回的是一个左值时，就应该返回一个引用类型。</p><p>当我们希望通过引用返回一个右值来避免拷贝的时候，应该返回一个引用常量类型。</p><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p>当非成员函数是类接口组成部分，应该将其的声明与类放在同一个头文件，但在类的外面。</p><p>IO类型可以作为函数的参数，但是只能使用引用的方式传入。因为IO类型不可拷贝且在读写过程中会改变IO的内容。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数用来初始化一个类对象。当初始化一个常量对象的时候，构造函数需要对常量对象的成员进行初始化，因此其只能在构造函数执行完成之后才能获得常量属性。</p><p>但是常量，引用，与未提供默认初始化的类型必须通过构造函数初始化列表的方式进行初始化而不能使用&#x3D;赋值，没有默认初始化的类型不能完成赋值的第一步，即先默认初始化。</p><p>因此最好在一般情况下构造函数使用构造函数初始化列表的方式进行初始化。</p><p>若是没有在构造函数中显式初始化，则将在构造函数执行前默认初始化。</p><h3 id="默认构造函数（？）"><a href="#默认构造函数（？）" class="headerlink" title="默认构造函数（？）"></a>默认构造函数（？）</h3><p>当一个构造函数不接受任何实参的时候，它就是默认构造函数。</p><p>当一个构造函数的形参都有默认参数时，其也将隐式地被用作默认构造函数，但同时也可以被用作非默认构造函数。</p><p><img src="/image/%E7%B1%BBUntitled.png" alt="Untitled"></p><p>当定义一个对象时</p><p>$$<br>typename\ \ name;<br>$$</p><p>此时就是默认初始化，无需在name后加括号。</p><p>当在类中并没有进行显式的对构造函数的声明时，编译器会自动生成一个合成的默认构造函数来作为构造函数。</p><p>其初始化的方式是：</p><ul><li>如果成员在类内有初始值，这用该值来初始化。</li><li>如果不存在，这默认初始化。</li></ul><p>最好只在简单的类中使用合成的默认构造函数。</p><ol><li>当且仅当一个类中不存在任何的构造函数的声明，即便声明的构造函数不是默认构造函数也算是声明了，此时，编译器将不会自动生成合成的默认构造函数，此时，这个类的默认构造函数就缺失了。</li><li>当类的成员中有内置类型或复合类型，其默认初始化之后将会是未定义的。</li><li>当类中有其他类成员，若这个类也没有默认构造函数，当前类的默认构造函数是无法自动初始化的。</li></ol><p>在第一种的情况下，我们希望能写一个和合成的默认构造函数相同的默认构造函数时，可以使用</p><p>$$<br>class_name()\ &#x3D;\ default;<br>$$</p><p>来显式告诉编译器要生成一个合成的默认构造函数。</p><p>当default在类内部声明时使用时，函数是inline的。</p><p>当default在类外部定义时使用时，函数是非inline的。</p><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>$$<br>name(param_list):variable1(initnum),variable2(initnum)…{\ }<br>$$</p><p>当某个数据成员在初始化时被列表忽略时，其将会被以像合成的默认构造函数中一样进行隐式初始化。</p><blockquote><p>构造函数最好不要覆盖类内原值。</p></blockquote><p>列表中对象的顺序并不是真实的初始化顺序，其真实的顺序是与对象在类中声明的顺序相同。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>将构造函数初始值列表改为另一个构造函数的执行语句即可。</p><p><img src="/image/%E7%B1%BBUntitled%201.png" alt="Untitled"></p><p><img src="/image/%E7%B1%BBUntitled%202.png" alt="Untitled"></p><p>$$<br>classname(param_list):classname(another_param_list){}<br>$$</p><p>在执行委托构造函数的初始化列表时也会执行其函数体，之后才会执行该构造函数的函数体。</p><h3 id="拷贝、赋值和折构"><a href="#拷贝、赋值和折构" class="headerlink" title="拷贝、赋值和折构"></a>拷贝、赋值和折构</h3><p>如构造函数一样，在这三种操作的函数没有被定义时，编译器会自动生成一个合成的版本。</p><p>但当其中存在对类成员以外的(如内存)进行操作时，合成的版本就是失效的。但可以使用vector或string来避免。</p><h3 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h3><ol><li>保证用户不会破坏封装对象的情况。</li><li>可以随时改变实现的细节。</li></ol><h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3><p>public与private，private部分就是被封装的部分。</p><p>在一个类中访问说明符可以多次被使用，即便该说明符前面已经被使用过了。</p><p>每一个访问说明符的范围是其从冒号开始到下一个访问说明符或类结束。</p><h3 id="class与struct的区别"><a href="#class与struct的区别" class="headerlink" title="class与struct的区别"></a>class与struct的区别</h3><p>class默认成员是private的，struct默认成员是public的。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>由于产生了封装，因此用户，其他类或者非成员函数无法访问其非公有成员。</p><p>可以通过在类中声明这些函数或类为友元来使其能够访问。</p><p>格式：与声明相同并在前加上friend关键字。</p><blockquote><p>建议集中在一起，在开头或结尾。</p></blockquote><p>友元声明并不是对函数或类的声明，只是对已有的已声明的函数或类进行权限的声明。最好在友元声明前先对其进行声明。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>可以在类内定义类型别名，但必须先定义后使用。</p><p>别名也存在公与非公，当为公的时候其可以被用户使用。</p><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>定义在类内部的函数都是隐式的inline函数。</p><p>但是也可以在类外进行显式的定义。</p><h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>在将一个类对象定义为const时，其所有的成员都将是const类型。或者在调用const函数时。在这两种情况下都不能对类的数据成员的值进行更改。</p><p>可以通过使用mutable关键字来使这个变量不可以是const，在上述的两种情况中都可以被改值。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化与赋值是不同的，赋值是先默认初始化再赋予它一个值。</p><p>当对于类对象进行初始化时。</p><ol><li>使用构造函数，直接初始化。</li><li>使用&#x3D;，进行赋值。</li></ol><h3 id="返回类对象本身"><a href="#返回类对象本身" class="headerlink" title="返回类对象本身"></a>返回类对象本身</h3><p>当返回一个非引用类型的时候，不能将其作为左值继续调用类对象的其他成员，因为它是一个临时的类对象。</p><p>当返回一个引用类型的时候，可以将其作为左值继续调用类的对象的其他成员。</p><p>但是，若是使用const类型的成员函数，即便返回的是引用类型的类对象本身，也是底层const类型的引用，此时，其作为引用不能被当做左值调用其非常量成员函数（指会改变类对象值的成员函数）。</p><p>可以通过在其外部定义一个调用其的函数来解决。</p><p>这个函数有两个重载版本。</p><ol><li>函数是const类型且返回值是const&amp;。</li><li>函数是普通类型且返回值为普通引用。</li></ol><p>在这种情况下，当类对象是常量时，会调用第一个，而为非常量时，会调用第二个。以此解决即便是非常量类型调用时返回值为常量的问题。</p><blockquote><p>此处声明一个两个函数既能保证代码的模块化与简便性，同时在类内定义使其内联保证其不会产生额外的开销。</p></blockquote><h3 id="不完全类型"><a href="#不完全类型" class="headerlink" title="不完全类型"></a>不完全类型</h3><p>当一个类仅仅完成了声明而没有完成定义（被称为前向声明）时，这个类就属于不完全类型。</p><p>在完成声明后，这个类类型由于不知道自身的成员，也就并不知道其占有多大的存储空间。因此类的成员不能使自己。</p><p>虽然不能创建它的对象，或者定义以他为参数或返回值的函数。但是可以声明以他为参数或返回值的函数并且可以创建指向它的指针或引用。</p><p>因此一个类的成员可以是指向自身类型的指针或引用。</p><h3 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h3><p>除了可将非成员函数定义为友元，还可以将别的类或其成员函数定义为友元。</p><p>$$<br>friend\ \ class\ \ classname;\friend\ \ type\ \ classname::functionname(param_list);<br>$$</p><p>友元不具备传递性，每个类控制自己的友元。</p><p>当一个类要使用另一个类的成员时，另一个类的定义必须先于自身。</p><p>当要声明重载函数为友元时，必须全部一个一个声明。</p><p>当友元函数被定义在类内部时，是隐式inline的，此处的定义是指在提供被访问权限的类中定义内容时。但即便是在类中定义了，其也必须要在类的外部先进行声明。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>对于定义在外的成员函数，返回值类型是声明在函数之前的，也就是说作用域并不没有包含返回值类型，因此若是返回值类型是在类内定义的，就必须在其前通过$::$作用域运算符来声明其作用域。</p><p>实际上，如果在作用域外调用成员函数就是违规的。</p><p>但是通过点运算符和箭头运算符与调用成员函数的类变量，使这个函数处于了作用域之内。</p><h3 id="名字查找"><a href="#名字查找" class="headerlink" title="名字查找"></a>名字查找</h3><p>对于类来说，名字查找在遵守作用域从内到外与内层同名会隐藏外层同名的两条规则以外，其并不只对处于它之前的进行查找，而是整个作用域（仅作用于类这一层作用域）。</p><p>为了实现这一点，类的所有定义都是在类的所有成员声明完之后才进行的。</p><p>虽然被同名被隐藏了，但仍然可以通过强制指向与作用域来指定对象。</p><p>这一点对于定义于类外的函数也是成立的，因为其也属于类作用域。</p><p>但对于类型的定义有些许不同。其不遵守类的规则，仍然是按顺序的，且无视作用域。因此最好将类型定义写在类的开头。并且若是在类外类内都对同名进行了类型定义，就会报错。</p><h1 id="初始化！！！！！"><a href="#初始化！！！！！" class="headerlink" title="初始化！！！！！"></a>初始化！！！！！</h1><h3 id="类类型转换"><a href="#类类型转换" class="headerlink" title="类类型转换"></a>类类型转换</h3><p>当构造函数的参数为一个时，就会自动作为类型转换的函数。</p><p>如定义一个参数为string的构造函数，此时可以将string类型作为自定义类的类型来使用，也就是在使用时如果有需要会自动通过这个构造函数转换为类类型（通过制造一个临时变量）。</p><p>但是只允许一步的类型转换。如果使用一个char数组，那么就不能了。</p><p>可以使用explicit关键字来声明一个构造函数不能作为类型转换函数，只应该出现在类内声明时。</p><p>而对于用了explicit关键字的构造函数，在拷贝初始化中也不能进行隐式的类型转换。</p><p>但是explicit并不会阻止显式的类型转换，包括直接初始化。</p><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><ol><li>所有的成员都是public的，使得所有成员都能被用户访问操作</li><li>没有构造函数与初始值</li><li>没有基类与虚函数</li></ol><p>可以通过列表初始化的方式初始化，其列表的顺序对应声明的顺序，故没有初始化的将列初始化。</p><p>在这种情况下，类的初始化的重任完全交给了用户。</p><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ol><li>数据成员必须为字面值类型，初始化时要么使用constexpr构造函数或字面初始值。</li><li>使用折构函数的默认定义。</li></ol><p>一般来说constexpr折构函数的函数体为空。</p><p>作用列举：</p><p><img src="/image/%E7%B1%BBUntitled%203.png" alt="Untitled"></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>对于类中的成员或成员函数，都可以将其声明为static。</p><p>此时其将不属于类的任何一个实例化的一个对象，而是属于类本身，并且被其实例化的所有对象共享。不能被声明为const类型。</p><p>可以使用作用域符访问。</p><p>并且虽然不属于对象，但是可以被对象通过点运算符或箭头运算符访问。</p><p>static和explicit一样，只能在类内使用，而不能用在类外。</p><p>由于不属于对象，因此不在构造函数中定义。</p><p>一般在类外进行初始化，通过作用域符。</p><p>当静态成员是整型constexpr时，可以在类内初始化，但其他都不行。</p><p>静态成员不但可以是不完全类型，如类本身，也可以作为默认实参。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类设计者的工具 </title>
    <link href="/hide/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <url>/hide/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="类设计者的工具"><a href="#类设计者的工具" class="headerlink" title="类设计者的工具"></a>类设计者的工具</h1><p><a href="https://lhish.github.io/hide/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6">拷贝控制</a></p><p><a href="https://lhish.github.io/hide/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">重载运算与类型转化</a></p><p><a href="https://lhish.github.io/hide/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象程序设计</a></p><p><a href="https://lhish.github.io/hide/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">模板与泛型编程</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>表达式 </title>
    <link href="/hide/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/hide/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><em><strong>左值</strong></em>可以用作<em><strong>右值</strong></em>，但<em><strong>右值</strong></em>不能用作<em><strong>左值</strong></em>。<em><strong>左值</strong></em>用的是对象的身份，即<em><strong>内存地址</strong></em>，而<em><strong>右值</strong></em>用的是对象的内容，即<em><strong>值</strong></em>。</p><p>因此，<em><strong>左值</strong></em>不能为<em><strong>常量</strong></em>。</p><p>除<em><strong>取地址符</strong></em>返回的<em><strong>指针</strong></em>是<em><strong>右值</strong></em>，其他的<em><strong>运算符</strong></em>返回的基本都是<em><strong>左值</strong></em>。</p><p>对于<em><strong>decltype</strong></em>来说，如果是<em><strong>左值</strong></em>，则为<em><strong>引用</strong></em>，如果是<em><strong>右值</strong></em>，则为<em><strong>指针</strong></em>。</p><h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于<em><strong>运算符</strong></em>所操作的<em><strong>对象</strong></em>，并没有定义<em><strong>运算顺序</strong></em>，也并非是从左到右的，如果出现了这种情况，且会由于顺序而对结果造成影响，则称<em><strong>表达式</strong></em>为<em><strong>未定义的</strong></em>。</p><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled.png" alt="Untitled"></p><p>只有***&amp;&amp;    ||    ?:    ,<em><strong>四种</strong></em>运算符<em><strong>指定了</strong></em>求值顺序***。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>正负号$&gt;$乘除取余$&gt;$加减 </p><p>返回的都是<em><strong>右值</strong></em>。</p><p>当混合运算时，<em><strong>小整数类型</strong></em>（<em><strong>bool</strong></em>，<em><strong>char</strong></em>，<em><strong>short</strong></em>）会自动转换为<em><strong>大整数类型</strong></em>（<em><strong>int</strong></em>）。</p><p><em><strong>int</strong></em>会转为<em><strong>float</strong></em>&#x2F;<em><strong>double</strong></em>。（并不知道具体是哪一个）</p><p><em><strong>商</strong></em>一律切除<em><strong>小数部分</strong></em>。</p><p>$m\bmod n&#x3D;m\bmod |n|$</p><p>当<em><strong>m</strong></em>时<em><strong>负值</strong></em>时，结果也为<em><strong>负值</strong></em>。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>非$&gt;$大小判断$&gt;$等于判断$&gt;$与$&gt;$或</p><p>当一个<em><strong>变量</strong></em>非常大时，<em><strong>遍历</strong></em>时使用<em><strong>引用</strong></em>能避免大量<em><strong>拷贝</strong></em>操作。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><em><strong>右结合律</strong></em>，因此可以连等。</p><p><em><strong>优先级</strong></em>较低。</p><h3 id="递增与递减"><a href="#递增与递减" class="headerlink" title="递增与递减"></a>递增与递减</h3><p><em><strong>前置版本</strong></em>返回<em><strong>左值</strong></em>，<em><strong>后置版本</strong></em>返回<em><strong>右值</strong></em>。</p><p><em><strong>前置</strong></em>：加完后返回值</p><p><em><strong>后置</strong></em>：加完后返回原始值</p><blockquote><p>最好使用前置</p></blockquote><h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p><em><strong>解引用</strong></em>低于<em><strong>递增递减</strong></em>。</p><p>****ptr++***是返回当前值再向后移一位。</p><h3 id="点与箭头运算符"><a href="#点与箭头运算符" class="headerlink" title="点与箭头运算符"></a>点与箭头运算符</h3><p><em><strong>点</strong></em>：其所属<em><strong>对象</strong></em>是<em><strong>左值</strong></em>还是<em><strong>右值</strong></em>决定<em><strong>成员</strong></em></p><p><em><strong>箭头</strong></em>：<em><strong>左值</strong></em></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p><em><strong>cond ? A : B</strong></em></p><p>A与B也可以是<em><strong>表达式</strong></em>。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>取反(~)$&gt;$左右移$&gt;$与$&gt;$亦或$&gt;$或</p><p>最好不要用<em><strong>左右移</strong></em>来处理<em><strong>有符号数</strong></em>，对于<em><strong>符号位</strong></em>的处理是<em><strong>未定义的</strong></em>。</p><p><em><strong>左右移</strong></em>的底层是在其左右添加新的<em><strong>位</strong></em>，但<em><strong>右移</strong></em>在处理<em><strong>有符号数</strong></em>时视情况而定。</p><blockquote><p>但是实际在<em><strong>Dev</strong></em>中使用时并不会因为<em><strong>左移</strong></em>而去掉<em><strong>符号</strong></em>。</p></blockquote><p>在<em><strong>位</strong></em>处理时，<em><strong>小整数</strong></em>类型会被<em><strong>提升</strong></em>为<em><strong>大整数</strong></em>。</p><blockquote><p>有趣的是，<em><strong>unsigned int</strong></em>在<em><strong>取反</strong></em>后仍然是<em><strong>unsigned int</strong></em>，并没有<em><strong>提升</strong></em>到<em><strong>int</strong></em>，但是<em><strong>unsigned char</strong></em>却被<em><strong>提升</strong></em>为了<em><strong>int</strong></em></p></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p><em><strong>cout</strong></em>的<em><strong>返回值</strong></em>是<em><strong>cout</strong></em>，当输出<em><strong>cout</strong></em>的时候会输出一个<em><strong>地址</strong></em>，应该是<em><strong>cout</strong></em>的<em><strong>地址</strong></em>(？)，并且<em><strong>地址</strong></em>不变，即便电脑不同，也都不变。</p><p><em><strong>左结合律</strong></em>。</p><p>算术$&gt;$IO$&gt;$关系赋值条件</p><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p><em><strong>sizeof(类型&#x2F;变量)，返回类型是size_t，常量值。</strong></em></p><p>在获取大小的时候不会去获得其具体值，因此可以<em><strong>解空指针引用</strong></em>。</p><p>且可以不通过<em><strong>实例</strong></em>来通过<em><strong>作用域</strong></em>获取<em><strong>类</strong></em>的<em><strong>成员</strong></em>的大小。</p><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled%201.png" alt="Untitled"></p><p><em><strong>char</strong></em>是一个<em><strong>字节</strong></em>。</p><p><em><strong>引用</strong></em>不是<em><strong>对象</strong></em>，因此获取其的大小是获取它所<em><strong>引用对象</strong></em>的大小。</p><p><em><strong>指针</strong></em>是<em><strong>对象</strong></em>，因此获取的是<em><strong>指针</strong></em>的大小。</p><p><em><strong>指针</strong></em>是可以直接被<em><strong>赋予常量地址</strong></em>的，即实际值，只需要将这一<em><strong>表达式</strong></em>转换为***int ****即可。</p><p>可以用来获取<em><strong>数组</strong></em>的大小。</p><h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><p><em><strong>逗号</strong></em>返回的是最右侧<em><strong>表达式</strong></em>的<em><strong>返回值</strong></em>。</p><h3 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h3><ol><li>将小整数类型提升为大于<em><strong>int</strong></em>的最小的整数类型(<em><strong>unsigned int</strong></em>$&gt;$<em><strong>int</strong></em>)。</li><li>若为不同符号类型（下面的大于小于是指<em><strong>存储空间大小</strong></em>）<ol><li><em><strong>有符号</strong></em>小于<em><strong>无符号</strong></em>，<em><strong>有符号</strong></em>将转为<em><strong>无符号</strong></em>。(更常见，但若<em><strong>有符号</strong></em>为负数，则结果将错误）</li><li><em><strong>有符号</strong></em>大于<em><strong>无符号</strong></em>，<em><strong>无符号</strong></em>将转为<em><strong>有符号</strong></em>。</li></ol></li></ol><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled%202.png" alt="Untitled"></p><p>在进行<em><strong>整型提升</strong></em>之后，才会进行<em><strong>类型转换</strong></em>。</p><blockquote><p>当<em><strong>cin</strong></em>读入时，若成功，则返回一个<em><strong>地址，</strong></em>与<em><strong>cout</strong></em>一致，不然返回0。</p></blockquote><p><em><strong>数组</strong></em>与<em><strong>指针</strong></em>有着本质的不同，将<em><strong>数组赋</strong></em>给<em><strong>指针</strong></em>的时候，实际上执行了<em><strong>类型转换</strong></em>。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>用法：<em><strong>转换方式&lt;类型&gt;(变量)。</strong></em></p><ol><li><p><em><strong>const_cast</strong></em>，可以将<em><strong>常量</strong></em>转为<em><strong>非常量</strong></em>。</p><p> 常用于<em><strong>函数重载</strong></em>。</p></li><li><p><em><strong>static_cast</strong></em>，普通的<em><strong>强制类型转换</strong></em>，可以将无视损失精度而进行转换。对于原本不能进行互相转换的类型可以通过***void ****作为中转来转换。</p></li><li><p><em><strong>reinterpret_cast</strong></em>，直接将其<em><strong>存储内容按位</strong></em>重新解释为转换后的类型，并没有对其值本身作任何更改，因此对于原本不能进行互相转换的类型可以直接进行转换。</p></li><li><p><em><strong>dynamic_cast</strong></em>，后面会谈及。</p></li></ol><p><em><strong>static_cast</strong></em>与<em><strong>reinterpret_cast</strong></em>的具体区别及4种<em><strong>cast</strong></em>的用法可参考：</p><p><a href="https://www.cnblogs.com/heyonggang/p/3361643.html">static_cast ，reinterpret_cast - 猿人谷 - 博客园</a></p><p><em><strong>旧式类型转换</strong></em>会先尝试<em><strong>const_cast</strong></em>与<em><strong>static_cast</strong></em>，若不合法，再执行<em><strong>reinterpret_cast</strong></em>。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled%203.png" alt="Untitled"></p><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled%204.png" alt="Untitled"></p><p><img src="/image/%E8%A1%A8%E8%BE%BE%E5%BC%8FUntitled%205.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论 </title>
    <link href="/hide/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/hide/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><p>计算机是实现某些逻辑、数学运算的工具（并非一定由程序所控制）。</p><p>1. </p><p>模拟：无限个值，连线（无法改变），电压，精度低</p><p>电子：有限个值，大部分程序控制，精度高</p><p>1. </p><p>专用(快)&#x2F;通用(适应)</p><p>电子管-》晶体管-》集成电路</p><p>nmos，1导通，pmos，0导通</p><p>机器字长代表一次性处理的位数，即运算器的宽度，及其寄存器的宽度</p><p>吞吐量B&#x2F;s，表示处理速度（处理多少数据）</p><p>响应时间：输入后多久完成得出结果</p><p>利用率，实际使用时间&#x2F;总时间</p><p>总线宽度：一次性可以传输的二进制长度</p><p>带宽：单位时间读出的数据量，B</p><p>主频&#x2F;时钟周期(主频的倒数)：每秒钟输出的主时钟数，即进行这么多次计算</p><p>CPI(cycle per instruction&#x2F;平均的指令花费的周期数)</p><p>MIPS(millions instruction per second)</p><p>冯·诺伊曼型计算机</p><p>五大部件：输入输出，控制，存储，计算</p><p>程序存储在存储器中并顺序执行</p><p>以运算器为中心</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BAUntitled.png" alt="Untitled"></p><p>现代计算机是以存储器为中心</p><p>系统总线：连接各种的部件</p><p>控制器：操作码和操作数</p><p>适配器：将输入输出设备与总线相连接</p><p><a href="https://lhish.github.io/hide/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87">图灵完备</a></p><p>手编程序：手动编译二进制码</p><p>软件实际上就是控制信号</p><p>五大层级：</p><p>高级语言 软件层</p><p>汇编语言 软件层</p><p>操作系统 混合层</p><p>上面层级被成为虚拟机</p><p>下面是物理机</p><hr><p>一般机器 硬件层&#x2F;&#x2F;微程序是一组控制信号</p><p>微程序设计 硬件层</p><p>软件和硬件都能实现所有的逻辑</p><p>固件是硬件，功能是软件</p><p>计算机系统结构：计算机系统结构是程序员所看到的计算机属性，即概念性结构与功能属性。</p><p>系统结构是计算机系统的软硬件界面（功能描述）<br>组成是计算机系统结构的逻辑实现.<br>计算机实现是计算机组成的物理实现.</p><p>系列机：系统结构相同但组成不同</p><p>高级的能运行在低级的上，但低级的不一定能原封不动的运行在高级机上</p><p>模拟：虚拟机的指令用宿主机来解释（软件）</p><p>仿真：用宿主机的微程序来解释（硬件）</p><p>设计的时候要即兼顾软件也要兼顾硬件，所以从中间开始设计，即指令集。</p><p>设计的原则：1.常用的要快，衡量：改进前用的时间&#x2F;改进后用的时间</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BAUntitled%201.png" alt="Untitled"></p><p>改进后的时间&#x3D;原时间((1-Fe)(不可改进的占比+改进的部分占比*改进的效果&#x3D;新的改进部分在源程序中的占比)</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>语句 </title>
    <link href="/hide/%E8%AF%AD%E5%8F%A5/"/>
    <url>/hide/%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h3 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h3><p>用一个<em><strong>；</strong></em>作为一个<em><strong>语句</strong></em>，用来<em><strong>占位</strong></em>。</p><p>多出的<em><strong>空语句</strong></em>并不会有<em><strong>语法</strong></em>上的错误，但可能会产生逻辑上的错误。如在<em><strong>循环</strong></em>后加一个<em><strong>；</strong></em>。</p><p>当<em><strong>花括号</strong></em>内不存在<em><strong>语句</strong></em>时被称为<em><strong>空块</strong></em>，与<em><strong>空语句</strong></em>作用一致。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><em><strong>条件语句</strong></em>也有<em><strong>作用域</strong></em>。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>当不使用<em><strong>花括号</strong></em>时，<em><strong>else</strong></em>会和最近的<em><strong>if</strong></em>相匹配，而非根据<em><strong>缩进</strong></em>。</p><p>if的条件括号中定义的变量只在if和else中时有效的。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(变量)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>.....<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>.....<br><span class="hljs-keyword">default</span>:<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>case</strong></em>后的值是<em><strong>变量</strong></em>的可能值，但必须为<em><strong>整型常量</strong></em>，<em><strong>小整数类型</strong></em>(包括<em><strong>字符</strong></em>)也是<em><strong>整型</strong></em>。</p><p>当<em><strong>case</strong></em>都不符合时，会执行<em><strong>default</strong></em>。</p><p>当一个<em><strong>case</strong></em>内部运行结束时，并不会结束<em><strong>switch</strong></em>，而是接着运行下面一个<em><strong>case</strong></em>，因此需要在每一个<em><strong>case</strong></em>的最后加一个<em><strong>break</strong></em>。</p><p>此外，由于会跳过<em><strong>语句</strong></em>，因此虽然整体属于一个<em><strong>switch的作用域</strong></em>内，但是不允许在<em><strong>case</strong></em>内<em><strong>声明初始化语句</strong></em>。</p><p>但是，可以通过在<em><strong>case</strong></em>内部加入一组<em><strong>大括号</strong></em>来制造一个<em><strong>作用域</strong></em>。</p><blockquote><p>因此，<em><strong>作用域</strong></em>是由<em><strong>大括号</strong></em>来决定的。</p></blockquote><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p><em><strong>定义语句</strong></em>虽然可以<em><strong>多重定义</strong></em>，但由于是一句<em><strong>语句</strong></em>，因此<em><strong>声明</strong></em>时<em><strong>变量</strong></em>必须是同种<em><strong>类型</strong></em>的。</p><p><em><strong>传统for</strong></em>的<em><strong>三要素</strong></em>都是可以省略的。</p><p><em><strong>for-range语句</strong></em>的<em><strong>对象</strong></em>必须是一个能够通过***.begin()<em><strong>与</strong></em>.end()<em><strong>返回</strong></em>头<em><strong>和</strong></em>尾后指针<em><strong>的</strong></em>类型***。其等价于：</p><p><img src="/image/%E8%AF%AD%E5%8F%A5Untitled.png" alt="Untitled"></p><p>因为***.end()<em><strong>是一开始就获取好的，因此不能在</strong></em>循环<em><strong>中向其中添加</strong></em>元素<em><strong>，使其</strong></em>.end()***改变。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>终止<em><strong>while</strong></em>, <em><strong>do while</strong></em>, <em><strong>for</strong></em>, <em><strong>switch</strong></em>。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>结束<em><strong>while</strong></em>, <em><strong>do while</strong></em>, <em><strong>for</strong></em>的当前一次<em><strong>迭代</strong></em>。</p><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>在程序中以<em><strong>lable:<em><strong>来</strong></em>声明标签</strong></em>位置，接着可通过<em><strong>goto label</strong></em>来跳转。</p><p>不能向后跳过<em><strong>初始化语句</strong></em>，但可以向前跳过，在此过程中，会<em><strong>销毁</strong></em>这一<em><strong>初始化</strong></em>的<em><strong>变量</strong></em>。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>步骤：</p><ol><li>在可能出现错误的地方使用<em><strong>try</strong></em>包裹。</li><li>在出现错误的地方用<em><strong>throw抛出异常</strong></em>。</li><li>在<em><strong>try</strong></em>后用<em><strong>catch</strong></em>捕捉<em><strong>错误类型</strong></em>并处理解决。</li></ol><p>格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">throw</span> 错误类型(错误信息);<br>&#125;<span class="hljs-built_in">catch</span>(错误类型 抛出来的存储错误信息的变量)&#123;<br>;<br>&#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>;<br>&#125;<br></code></pre></td></tr></table></figure><p>错误信息是<em><strong>string</strong></em>类型或者<em><strong>C风格字符串</strong></em>。</p><p><em><strong>try</strong></em>内部<em><strong>声明</strong></em>的<em><strong>局部变量</strong></em>并不能在<em><strong>catch作用域</strong></em>中被使用。</p><p>可以通过***.what()<em><strong>来获取</strong></em>初始化<em><strong>错误时使用的</strong></em>字符串字面值，<em><strong>返回值是</strong></em>const char ****。</p><p><em><strong>catch</strong></em>只会通过<em><strong>错误类型</strong></em>进行匹配。</p><p>当并没有匹配到对应的<em><strong>catch</strong></em>时，会返回<em><strong>调用</strong></em>当前<em><strong>函数</strong></em>的<em><strong>函数</strong></em>继续寻找，若到底层仍然没找到，则直接<em><strong>terminate</strong></em>，程序<em><strong>非正常退出</strong></em>。</p><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><ol><li><em><strong>exception头文件</strong></em>，异常类型<em><strong>exception</strong></em>，最常见的问题，不提供任何其他信息。</li><li><em><strong>stdexcept头文件</strong></em>，提供多种异常类型。</li></ol><p><img src="/image/%E8%AF%AD%E5%8F%A5Untitled%201.png" alt="Untitled"></p><ol><li><em><strong>new头文件</strong></em>，异常类型<em><strong>bad_alloc</strong></em>。</li><li><em><strong>type_info头文件</strong></em>，异常类型<em><strong>bad_cast</strong></em>。</li></ol><p>只有<em><strong>stdexcept</strong></em>提供<em><strong>非默认初始化</strong></em>。</p><blockquote><p><em><strong>鲁棒性</strong></em>，指系统在扰动或不确定的情况下仍能保持它们的特征行为。</p></blockquote><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运算方法和运算器 </title>
    <link href="/hide/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"/>
    <url>/hide/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><p>小数：IEEE754</p><p>1位符号位</p><p>8位阶码（移码）补码的最高位取反（将指数变为正数）（+127）</p><p>23位尾数（原码）</p><p>符号位是尾数的符号位</p><p>最终的结果是1.尾数*10^阶码</p><p>当尾数和阶码全0时为0，因符号位有正0和负0</p><p>当尾数位0且阶码全为1为无穷大</p><blockquote><p>当阶码为0而尾数不为0时，则为0.尾数*10^（-126）</p></blockquote><p>当阶码为全1且尾数不为0时，则为Nan，一种非数值</p><p>浮点数有正负上下溢</p><p>奇偶校验码：加上校验码这一位是奇数个1还是偶数个1</p><p>补码取负：取反，末位➕1</p><p>溢出判断：</p><ol><li><p>双符号位法，用两位表示符号位，在运算完后</p><p> 负则前两位为1，否则前两位为0</p></li><li><p>单符号位，分别看符号位的进位和最高位的进位</p></li></ol><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled.png" alt="Untitled"></p><p>乘法器：</p><ol><li>首先算出所有的部分积(第一个数字的某一位和另一个数字的某一位的积)</li><li>一起输入阵列乘法器(实际执行的是加法)，进行相加(按列相加)。</li><li>每一位的加法是，上面的和+当前位+前面一列这一行的进位</li></ol><p>对于一个补码，要相乘。</p><ol><li>算前求补，变为原码（为n位)</li><li>乘法</li><li>算后求补，变为补码（为2n位)</li></ol><p>原补互变的方式：</p><ol><li>符号位为0，不变</li><li>符号位位1，从右往左找到第一个1，然后，从这一位左侧那一位到符号位之前都取反</li></ol><p>对于电路来说，遇到第一个1后，或就永远是1了，然后当E也位1时，与出来就为1，也就是要取反了</p><p>除法器：</p><ol><li>定点原码除法，每次将除数右移，主要问题在于判断当前是商0还是1，要减一下看一下&lt;&#x3D;&gt;0，然后还要加回来</li><li>不恢复余数法，余数为正，商1，下一次右移做减法，为负，商0，下一次做加法</li></ol><p>并行加法器：</p><p>普通的逐位加法器，被称为行波进位</p><p>并行：</p><p>第一种是，四位内并行，四位外行波。</p><p>$$<br>G_i&#x3D;Y_{4i+3}+Y_{4i+2}X_{4i+3}+Y_{4i+1}X_{4i+2}X_{4i+3}+Y_{4i}X_{4i+1}X_{4i+2}X_{4i+3}\P_i&#x3D;X_{4i}X_{4i+1}X_{4i+2}X_{4i+3}\G_{ij}&#x3D;G_{i(j-1)}X_{j}+Y_j\P_{ij}&#x3D;P_{i(j-1)}X_j<br>$$</p><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled%201.png" alt="Untitled"></p><p>每一位的Ci可以先行计算，而在计算出所有G和P后也可以由C0计算出C4,8,12,16，而可以由AB算出所有的G和P，因此就可以先行算出所有的进位。</p><p>可以做到16位内并行，16位外行波。</p><p>总线：cpu内或者与外部设备的，有单向双向</p><p>单总线：对于ALU前必须有暂存器，存下第一个，再存下第二个，然后计算，再返回，因为单总线所有的线只能存一个数据</p><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled%202.png" alt="Untitled"></p><p>双总线：就不需要有暂存器了</p><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled%203.png" alt="Untitled"></p><p>三总线：总线都是单向的了</p><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled%204.png" alt="Untitled"></p><p>浮点数加减：</p><ol><li><p>判断浮点数是否为0，因为0是人为定义的。</p></li><li><p>统一指数，变为更大的指数，为了保证改变后仍然是1.M&#x2F;0.M，求和结果大概率是1.M</p></li><li><p>尾数求和&#x2F;减</p></li><li><p>结果规格化</p></li><li><p>舍入处理</p><p> 1进0舍，如果是负数，则相反。</p><p> 朝+∞舍入：正数结尾不全为0就进，负数相反</p><p> 阶码上溢，一般将其认为是＋∞和－∞ 。<br> 阶码下溢，则数值为0。</p></li></ol><p>乘除：</p><ol><li>检查</li><li>阶码加减</li><li>尾数乘除</li><li>规格化+舍入</li></ol><p>流水线操作：如对于浮点数计算，则将每个部分分为一个部分。</p><p><img src="/image/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8Untitled%205.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>顺序容器 </title>
    <link href="/hide/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <url>/hide/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>string是类似vector的，但更适用于字符。</p><p>deque，双端队列，但不是用list实现的。</p><p>queue，单端队列，使用deque或者list实现。在默认情况下使用deque实现。</p><p>array不是内置数组，是一种数据结构，优于内置数组。</p><p>有的时候容器会需要更多的参数。如对于一个没有默认构造函数的类型定义一个定长度的vector时，需要提供初始化器。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%201.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%202.png" alt="Untitled"></p><p>c.emplace(inits)用初始化器添加一个元素。</p><p>reference是引用</p><p>反向迭代器++是到上一个元素。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%203.png" alt="Untitled"></p><p>容器的拷贝有两种</p><ol><li>拷贝整个容器，必须保证元素类型相同</li><li>用两个迭代器指定拷贝范围，不要求元素类型相同，只需能够转换即可</li></ol><p>当使用列表初始化时不但指定了值也指定了大小。</p><p>只有顺序容器支持初始化大小。</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>在指定类型外还要指定大小。</p><p>$$<br>array&lt;type,size&gt;\ name;<br>$$</p><p>允许拷贝。</p><p>但是array类型必须类型与大小相同。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%204.png" alt="Untitled"></p><p>assign不止能将相同的容器进行拷贝，不同的容器也可以通过这种方式进行拷贝。</p><p>不能将自己assign给自己，因为旧迭代器会失效。</p><p>swap若用在array之外，其交换并不交换具体元素，而是交换数据结构。因此很快且迭代器不会失效。</p><p>max_size返回的是能容纳的最大元素数，应该是跟内存大小有关？。</p><p>关联容器可以判断等于，两个顺序容器还可以进行比较。</p><p>若是前缀，这短的更小。</p><p>若不是，则根据第一个不同的值的大小。</p><p>容器的等于是依靠类型的等于，容器的其他比较是依靠类型的小于。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%205.png" alt="Untitled"></p><p>可以通过这些函数的返回值来反复插入元素。</p><p>emplace通过传入的args并以之为参数调用构造函数并将构造出的元素插入。会在内存空间中直接创建元素。而push会先创建一个临时的，然后再插入。</p><p>front和back必须先保证容器非空。</p><p>由于front和back返回的是引用，虽然也有常量引用的重载。</p><p>下标运算符并不会判断是否越界，但可以通过.at(index)来加上判断。若是越界，则会抛出异常。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%206.png" alt="Untitled"></p><p>删除元素必须保证元素存在在容器中。</p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>单向链表，比list运行效率上更优并且空间上更优。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%207.png" alt="Untitled"></p><p>由于是单向的，但是更改当前元素会影响到前面一个元素，因此所有的操作都是更改当前元素的后面一个元素。并且提供首前指针接口。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%208.png" alt="Untitled"></p><p>对于vector和string，插入或删除若没有重新分配，则其前的所有将仍有效，而后都无效。</p><p>对于deque，只有在插入或删除头尾时不会失效，而其他情况所有都会失效。</p><p>必须保证迭代器有效。</p><p>通过insert和erase的返回值来更新迭代器。insert返回插入的最后一个，erase返回删除的后面一个。</p><p>end()返回的迭代器常常会在容器元素改变时失效，因此使用时应该直接调用，不要保存。</p><p>begin()倒是问题不是很大，但还是要注意一下。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>提供capacity()与reserve()接口。capacity返回当前申请的总空间中能存储几个数据。而reserve(int)使vector先进行分配一定量的空间若是当前的capacity小于请求量时。</p><p>当申请新的空间时，一般是翻倍，但是这也会因实现不同而不同。</p><p>另外shrink_to_fit()可以建议vector去掉多余的空间，但不一定会执行。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>有较多函数，主要有几个方面。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%209.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2010.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2011.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2012.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2013.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2014.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2015.png" alt="Untitled"></p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2016.png" alt="Untitled"></p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>容器适配器就是使用别的容器来实现的效果一致的容器。</p><p>stack，queue，priority_queue都是容器适配器。是通过其他容器实现的。</p><p>虽然使用其他的容器实现，但是不能访问实现它的容器的底层接口，只能调用其特有的接口。因此stack与priority_queue有top()这种其他容器所没有的接口。</p><p><img src="/image/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Untitled%2017.png" alt="Untitled"></p><p>可以将其他的容器元素全部拷贝来初始化。</p><p>由于一个容器适配器可以用多种容器实现，因此，在定义一个容器适配器时可以指定实现的底层容器。</p><p>stack，可以使用所有除forward_list和array的容器。</p><p>queue，可以使用list或deque。</p><p>priority_queue，可以使用vector或deque。</p><p>默认都是使用deque实现的。</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高级主题 </title>
    <link href="/hide/%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    <url>/hide/%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><p><a href="https://lhish.github.io/hide/%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD">标准库特殊设施</a></p><p><a href="https://lhish.github.io/hide/%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7">用于大型程序的工具</a></p><p><a href="https://lhish.github.io/hide/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF">特殊工具与技术</a></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>B-树 </title>
    <link href="/B-%E6%A0%91/"/>
    <url>/B-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>B树是一种类似于红黑树的树，但并非是二叉树，是多叉树，假设一个节点有n个孩子，那么，该节点将存储n-1个关键字，这些关键字就是孩子们之间的分割线，通过比对这n-1个关键字，即可知道数据是在哪个孩子里面。</p><p>由于机械硬盘的随机读取速度非常慢，故希望能在一次读取中读取多个数据，B树就可以优化读取的这一部分，即IO部分。另外，为了保证少读取几次，要使得B树的高度尽可能小。</p><p>在电脑中，主存的大小一般小于磁盘大小。对于存储在硬盘上的一棵超大的B树，需要分次读取。一般来说，这颗B树的每一个节点的大小应和主存大小差不多，使得能够最大的减少B树的高度。此处的读取是连续读取。</p><blockquote><p>每一个节点内部是否可以用链表？</p></blockquote><h3 id="卫星数据"><a href="#卫星数据" class="headerlink" title="卫星数据"></a>卫星数据</h3><p>一般来说，所有对数据的整体操作，都会依赖于关键字，数据依附于关键字而存在，故被称为卫星数据。</p><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><ol><li>关键字的个数</li><li>关键字</li><li>关键字的指针</li><li>是否是叶节点</li></ol><h3 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h3><p>存在一个最小度数t，使得除根节点外的节点的子节点个数$n\ge t-1且n\le 2t-1$。</p><h3 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h3><p>$h\le log_t\frac{n-1}{2}$</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li>B树的根结点始终在主存中，这样无需对根做DISK-READ操作；然而，当根结点被改<br>变后，需要对根结点做一次DISK-WRITE操作。</li><li>任何被当做参数的结点在被传递之前，都要对它们先做一次DISK-READ操作。</li></ul><blockquote><p>并不知道第二条约定是为什么而存在</p></blockquote><p>和二叉搜索树差不多，每到一个节点遍历关键字，继续向下，直到存在或者说是叶节点。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>但首先需要特殊创建一个叶节点来作为根节点。</p><p>接着，插入时B树并不像其他的树一样建立一个新的节点，不然就违反B树的性质了。B树扩张的方式是分裂节点，正如前所述，B树的节点是有一个最大的子节点数上限的，当一个节点到了这个上限，就会将其split成两个$t-1$大小的节点，而其父节点的关键字也会+1。然而其父节点也可能会因为这+1而需要分裂，因此分裂的操作会在插入的时候自上而下的进行，以保证被分裂的节点的父节点并不是满的。</p><p>但是，可以发现的是，虽然分裂操作能够扩张树，但是只能水平的进行扩张，但这样还是会到极限的。此时，我们可以去思考一下，在什么样的情况下，我们会认为当前的B树快满了，需要进行纵向的扩张呢？</p><p>就是在根节点满的时候。当根节点满的时候，虽然还有一些空位，但也表明需要扩张了。有趣的是，B数的扩张并不是向下的，而是向上的，通过在根节点上再制造一个根节点使得原本的根节点成为它的孩子的方式来扩张，接着分裂原本的根节点即可。</p><p>接下来是具体插入时的操作。在碰到一个节点时，自后向前扫描，这样能够它需要插入新的节点的关键字的时候，能够顺便将后面的直接向后移一位。注意，非叶节点是不可能在插入的时候进行扩张的，当且仅当其子节点扩张的时候，它自身才会进行扩张。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>情况一：不是叶节点。</p><ol><li>如果该关键字前的子节点的关键字大于t-1，则将其后继替换本关键字。</li><li>如果该关键字后的子节点的关键字大于t-1，则将其前驱替换本关键字。</li><li>如果前后都小于t，则将其合并，此时合并所得节点的关键字数量会小于2t。</li></ol><p>情况二：是叶节点。删除即可。</p><p>但会出现叶节点的关键字过少的问题。</p><ol><li>如果该叶节点左右有大于t-1的叶节点，则将其后继或前驱上升至父节点，父节点的关键字下降到本节点。</li><li>如果该叶节点左右没有大于t-1的叶节点，则将其余其兄弟合并，此时其父节点的中间关键字需要下放。</li></ol><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的变体。</p><ol><li>其内部节点不会存卫星数据及其关键字，所有的数据都会在其子节点可以找到。</li><li>而内部节点中关键字的个数不是n-1个，而是n个，其关键字为其子节点的最大值或者最小值。</li><li>其叶节点之间会存在指针，从较小的叶节点指向较大的叶节点，形成了一个链表。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>因为中间节点不会存数据，因此更加矮胖，IO次数更少。</li><li>必须抵达叶节点，更加稳定。</li><li>能够轻松地靠叶节点链表进行范围查询。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++premier </title>
    <link href="/c++premier/"/>
    <url>/c++premier/</url>
    
    <content type="html"><![CDATA[<h1 id="c-premier"><a href="#c-premier" class="headerlink" title="c++premier"></a>c++premier</h1><p><a href="https://lhish.github.io/hide/%E5%BC%80%E5%A7%8B">开始</a></p><p><a href="https://lhish.github.io/hide/c++%E5%9F%BA%E7%A1%80">c++基础</a></p><p><a href="https://lhish.github.io/hide/%E6%A0%87%E5%87%86%E5%BA%93">标准库</a></p><p><a href="https://lhish.github.io/hide/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7">类设计者的工具</a></p><p><a href="https://lhish.github.io/hide/%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98">高级主题</a></p><p><a href="https://lhish.github.io/hide/modern">modern</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective c++ </title>
    <link href="/Effective%20c++/"/>
    <url>/Effective%20c++/</url>
    
    <content type="html"><![CDATA[<h1 id="Effective-c"><a href="#Effective-c" class="headerlink" title="Effective c++"></a>Effective c++</h1><h3 id="模板推导"><a href="#模板推导" class="headerlink" title="模板推导"></a>模板推导</h3><p><img src="/image/c++Untitled.png" alt="Untitled"></p><p>对于传数组，由于c中数组和指针是等价的，因此，数组通过值传递的时候被视为一个指针，模板推导出来也是一个指针。然而，当作为引用传递的时候，其就不和指针等价了，可以推导出其类型和大小。</p><p><img src="/image/c++Untitled%201.png" alt="Untitled"></p><p>但实际上，这两个传进去的东西用起来是一样的。都是函数()。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">template&lt;typename T&gt;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-title class_">ParamType</span> param);<br><br><span class="hljs-title class_">ParamTypeOfAuto</span> param;<br></code></pre></td></tr></table></figure><p>这两个实际上是等价的，除了一种情况。</p><p>当使用{}初始化的时候，auto会默认为std::initialize_list，而模板推导则不会默认，模板推导接受{}是必烂的。而如果是构造，如果这个{}能够符合两个类型的构造，那么就是歧义的。</p><p>返回类型的auto和lambda的形参auto虽然看着是auto，但实际上使用的规则是模板推导的规则而非auto的规则。</p><p>另外，lambda的形参使用auto相当于就是模板函数。</p><p><strong>使用auto能够让类型上的依赖自动推导，不用牵一发而动全身。</strong></p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype不是类型推导，decltype会忠诚的返回变量本身的类型。</p><p>然而，对于一个非引用值来说，如果他是复杂的表达式，即便是(param)，param是T类型，也会让整个类型的推导变为T&amp;。</p><p>由于auto是类型推导，为了让其使用decltype的规则，就应该使用decltype(auto)，这个时候会把推导方法使用decltype的规则。</p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>编译器或者typeid产生的推导可能是不正确的，还是靠编译器编译的时候的解释比较靠谱。一种比较简单的方式是</p><p><img src="/image/c++Untitled%202.png" alt="Untitled"></p><h3 id="使用auto的好处"><a href="#使用auto的好处" class="headerlink" title="使用auto的好处"></a>使用auto的好处</h3><ol><li>避免没有初始化</li><li>省略冗长类型名</li><li>避免不必要的类型转换(如在不同平台typedef实际不同)及其产生的相关问题</li></ol><p><img src="/image/c++Untitled%203.png" alt="Untitled"></p><h3 id="不使用auto的场合"><a href="#不使用auto的场合" class="headerlink" title="不使用auto的场合"></a>不使用auto的场合</h3><blockquote><p>由于c++不允许对bit的引用，但是vector<bool>是按bit存放的，因此，返回的并不是bool&amp;，而是一个代理类，有着类似的功能。</p></blockquote><p>然而，不显式的代理类一般是不被平常使用的，他是隐藏于使用但我们并不知道他被使用了，我们也不会主动去使用他，因为这可能会导致一些错误，就像工具人一样。</p><p>而使用auto会让这些代理类被显式使用，会导致错误。</p><p>为了贯彻auto的理念，使用 auto a&#x3D;static_cast<type>(b)来显式类型初始化惯用法。</p><p>而这也表明了，b可能不是这个类型，而我希望让他转换成type这个类型的意思。</p><h3 id="和"><a href="#和" class="headerlink" title="()和{}"></a>()和{}</h3><ul><li><p>{}的好处</p><p>  在任何情况下都可以用</p><p>  避免了类型变窄的隐式转换</p><p>  避免了默认初始化可能会被误判成函数声明的问题</p></li><li><p>{}的坏处</p><p>  如果定义了以initialized_list为参数的构造函数(要避免)，那么所有能够匹配到initialized_list的都会使用这个构造函数</p><p>  当通过模板完美转发的时候，不知道使用者到底是想要使用{}还是()</p></li></ul><h3 id="使用nullptr"><a href="#使用nullptr" class="headerlink" title="使用nullptr"></a>使用nullptr</h3><h3 id="使用别名声明"><a href="#使用别名声明" class="headerlink" title="使用别名声明"></a>使用别名声明</h3><ol><li>using看起来比typedef更易懂</li><li>using支持模板，而typedef应该是一个宏，所以不支持</li></ol><blockquote><p>为什么要加typename的原因是::所得的成员不一定是一个类型，可能是一个实际成员。</p></blockquote><h3 id="使用限定域enum"><a href="#使用限定域enum" class="headerlink" title="使用限定域enum"></a>使用限定域enum</h3><p>避免了作用域的问题。</p><p>避免了隐式转化。</p><p>限定域enum默认最为int大小，而非限定没有默认，因此不能声明和定义分开。</p><p>而对于用来表示对应数字的问题，如对于tuple的get来说，是比较麻烦的，但为了贯彻限定域enum，可以</p><p><img src="/image/c++Untitled%204.png" alt="Untitled"></p><h3 id="使用deleted"><a href="#使用deleted" class="headerlink" title="使用deleted"></a>使用deleted</h3><p>deleted能够达到与声明为private一样的效果。</p><ol><li>能够在编译的时候就检测出来，而非在链接的时候。</li><li>针对任何函数</li><li>能够用来对于函数的参数进行过滤，虽然现在大概应该要用concept更好把</li></ol><h3 id="使用override"><a href="#使用override" class="headerlink" title="使用override"></a>使用override</h3><blockquote><p>基类和派生类函数名必须完全一样（除非是析构函数)，因此构造函数不能继承。</p></blockquote><h3 id="使用const-iterator"><a href="#使用const-iterator" class="headerlink" title="使用const_iterator"></a>使用const_iterator</h3><h3 id="使用noexcept"><a href="#使用noexcept" class="headerlink" title="使用noexcept"></a>使用noexcept</h3><p>移动，swap和析构都需要是noexcept的。</p><p>一个函数时候应该是noexcept应该要衡量noexcept带来的性能上的优势与实现noexcept带来的性能上的劣势。</p><p>另外，noexcept函数并不要求其调用的函数是noexcept（这是为了兼容老代码）。</p><h3 id="使用constexpr"><a href="#使用constexpr" class="headerlink" title="使用constexpr"></a>使用constexpr</h3><p>constexpr保证了变量是编译器可知的，因此编译器就会在编译期把他求出来，一个constexpr变量一定是const的。</p><p>constexpr函数则表示，这个函数的返回值可能是编译期可知的，也就是，可以用非constexpr参数去调用这个函数，返回的也不是constexpr的，但是，如果用constexpr的形参去调用，则返回的结果也是constexpr的，但不一定是const的。</p><p>所以如果一个函数的调用的形参是constexpr的，那么这个函数就应该被声明为constexpr的。</p><h3 id="保证const函数线程安全"><a href="#保证const函数线程安全" class="headerlink" title="保证const函数线程安全"></a>保证const函数线程安全</h3><blockquote><p>大概是为了保证其他函数的const性，所以某些函数也要被生成为const，至少表面看上去是const，而为了在里面修改内容，就需要用mutable</p></blockquote><p>由于const函数是只读的，因此对于多线程是可以并行的。所以如果有mutable，那么就要进行保护，如使用atomic或者mutex。</p><p>一般来说atomic比mutex快，但是，对于多个mutable同时操作，atomic就并不能保证安全了，只能用mutex。</p><h3 id="默认函数的生成"><a href="#默认函数的生成" class="headerlink" title="默认函数的生成"></a>默认函数的生成</h3><blockquote><p>对于默认生成的移动函数来说，对于所有成员都会进行移动请求，可以移动的就会移动，但如果无法移动就会拷贝</p></blockquote><p>拷贝的两个函数的生成是互不影响的。</p><p>移动当且仅当5大函数都没有声明的时候才会生成。</p><blockquote><p>这些的逻辑是，如果声明了，那么就说明他和默认的不一样，那么连带着其他的也可能不一样</p></blockquote><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>比如说pimpl或者工厂都会使用unique_ptr。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>如果通过一个shared_ptr的this来构造shared_ptr，那么会烂掉。</p><p>这种情况要让这个被shared_ptr管理的类继承于enable_shared_from_this。</p><p>shared_ptr和unique_ptr都是原子的。</p><h3 id="用make"><a href="#用make" class="headerlink" title="用make"></a>用make</h3><p>使用make保证了当分配内存的时候他就必然已经被管理了。而new返回的指针来构造则并不能保证这一点。这样才是异常安全的。</p><p>但make不能自定义deleter。</p><p>make中使用的完美转发也会导致()和{}的内部使用问题。</p><p>对于重载了new和delete的类不能使用make。</p><h3 id="Pimple和ptr"><a href="#Pimple和ptr" class="headerlink" title="Pimple和ptr"></a>Pimple和ptr</h3><p>如果一个类中的成员的类型依赖于其他文件，这样就会导致依赖库的变化会导致整个的变化。</p><p>因此一般声明一个struct，并让类拥有一个指向这个struct的指针。</p><p>而这个struct的定义在cpp中实现，这样依赖就不在.h中了，大大减少了编译时间。</p><p>一般来说，这个指针用unique_ptr。</p><p>但是，不能使用默认生成的移动函数和析构函数。因为，这二者都会调用unique_ptr的delete，但是他的delete由于是一个类型参数，因此会去判断删除的类型是不是一个不完整类型，很显然，是的。</p><p>因此，二者的定义就必须延迟到struct定义完后才行，因此要在.h中声明，在.cpp中定义。</p><p>而shared_ptr就没有这个问题，因为他的删除器并不是一个模板参数。</p><h3 id="std-move和std-forward"><a href="#std-move和std-forward" class="headerlink" title="std::move和std::forward"></a>std::move和std::forward</h3><p>实际上只是进行了类型转换。std::move是不管左值还是右值都转换为右值。</p><p>而std::forward是只有当传入为右值时才将这个左值的右值转换为右值。</p><p>然而，这种转换并没有对cv做任何操作。因此，如果原本是一个const对象，并调用了std::move并去初始化对象，调用的会是拷贝构造函数，因为const还在。</p><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>当带有类型推导的时候的&amp;&amp;，如auto&amp;&amp;和T&amp;&amp;都是通用引用，代表既有可能是左值也有可能是右值。</p><p>cv的出现也会让通用引用失效，如const auto&amp;&amp;就是烂的。</p><h3 id="对通用引用用forward，对右值引用用move"><a href="#对通用引用用forward，对右值引用用move" class="headerlink" title="对通用引用用forward，对右值引用用move"></a>对通用引用用forward，对右值引用用move</h3><p>如果在一个函数中，按值返回一个右值或者通用引用的形参，那么应该对这个返回值进行forward或者move，为了使他进行的是移动而非是拷贝。因为他是一个左值引用或者对右值的左值引用。</p><p>而如果返回的是非引用变量，就不应该这么做，因为有复制消除。</p><h3 id="不要对通用引用进行重载"><a href="#不要对通用引用进行重载" class="headerlink" title="不要对通用引用进行重载"></a>不要对通用引用进行重载</h3><p>有的时候，为了转发一个参数，我们使用了通用引用。然而我们对这个函数进行重载了一个版本，仅仅将这个通用引用换成了一个普通的类型，然而，调用这个函数的时候，仍然会匹配到通用引用的版本。并且，如果一个构造函数只用了通用引用的单参数函数，那么这甚至可能会抢夺拷贝构造函数的饭碗。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用const T&amp;</li><li>值传递，见倒数第二个点</li><li>concept限制类型来进行重载</li></ol><p>完美转发可以转发任意类型，因此，如果某种类型是非期待的，可能会由于完美转发导致到达很深的地方才产生错误，导致麻烦，因此可以在完美转发之前使用static_assert对这些情况进行更有效的错误汇报。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>只有&amp;&amp; &amp;&amp;是&amp;&amp;，其他都是&amp;。</p><h3 id="移动操作的缺点"><a href="#移动操作的缺点" class="headerlink" title="移动操作的缺点"></a>移动操作的缺点</h3><p>有的时候移动操作不一定会比普通的拷贝快多少，比如对一个数组的拷贝。</p><h3 id="完美转发不能起效的情况"><a href="#完美转发不能起效的情况" class="headerlink" title="完美转发不能起效的情况"></a>完美转发不能起效的情况</h3><ol><li><p>一个Args&amp;&amp;…的模板，传入一个{…}，会被认为无法推导。</p></li><li><p>在转发的时候想转给一个指针，但是传入了0或者NULL，此时被推导为int。</p></li><li><p>对于一个static const的类成员，它是没有地址的，如果对它转发，也会烂。</p></li><li><p>转发函数的时候如果是直接通过函数名来指定函数，那么，如果这个函数名能代表多个函数，就会推导失败，无法判断是哪一个函数。普通的通过函数名来判断是因为有形参类型作为依据。</p><p> 因此，要显式的指明这个函数名代表的函数对应的函数类型。</p></li><li><p>位域也不行。</p></li></ol><h3 id="不要使用默认捕获"><a href="#不要使用默认捕获" class="headerlink" title="不要使用默认捕获"></a>不要使用默认捕获</h3><p>捕获的变量可能为悬空。</p><p>捕获只会对自动存储器变量进行捕获。</p><ol><li>如果是引用捕获，那么，如果离开了这个作用域而使用这个lambda，那么就会悬空。</li><li>如果是值捕获，确实没有1中的问题，但如果捕获的是指针，那么也会产生悬空。</li></ol><p>如果在成员函数中使用lambda进行捕获，除了局部变量以外，并不会捕捉到成员，即便它是可见的。使用这些成员的方式是，捕获this指针。[this]代表按引用捕获，[*this]代表按值捕获。当使用&amp;默认捕获时，会捕获。但用&#x3D;时则不会捕获。</p><p>解决方法是，初始化捕获。[变量名&#x3D;初始化值或&amp;变量名&#x3D;初始化变量]，每个之间用,隔开，依然是引用或者值传递，但这样，就可以不限于只捕获局部变量了。</p><p>对于静态变量，是不被捕获的，如果在lambda所在作用域可见，那么在lambda中也可见，就像全局变量一样，外部的变化也会影响lambda。</p><p>这些依赖如果使用默认捕获不够明确，因此应该显式的捕获。</p><h3 id="使用初始化捕获"><a href="#使用初始化捕获" class="headerlink" title="使用初始化捕获"></a>使用初始化捕获</h3><p>如果是不支持初始化捕获的，那么可以使用类似bind的方法来实现移动。</p><h3 id="对auto-使用decltype和forward"><a href="#对auto-使用decltype和forward" class="headerlink" title="对auto&amp;&amp;使用decltype和forward"></a>对auto&amp;&amp;使用decltype和forward</h3><p>一个泛型lambda可以放进任何其实例化类型的function中，只不过放入后就类型确定了。</p><p>如果要对auto&amp;&amp;捕获所得变量进行转发，由于不存在T类型，但是forward必须要指定对应类型，因此此时可以使用decltype(变量)，如果是auto&amp;&amp;… param，那么可以std::forward&lt;decltype(param)&gt;(param)…</p><h3 id="优先用lambda而非std-bind"><a href="#优先用lambda而非std-bind" class="headerlink" title="优先用lambda而非std::bind"></a>优先用lambda而非std::bind</h3><h3 id="使用基于任务的而非线程的并行"><a href="#使用基于任务的而非线程的并行" class="headerlink" title="使用基于任务的而非线程的并行"></a>使用基于任务的而非线程的并行</h3><p>线程就是std::thread</p><p>而任务是std::async</p><p>std::thread不会去要求其返回值，然而std::async可以通过std::future去获取他的返回值。这样也能够捕获任务的异常，而std::thread就不能。</p><p>std::thread是手动开一个线程进行跑，线程的分配是我们自己进行掌管的，然而，当负载很大的时候，我们实际上并不能非常好的进行分配，从而产生性能上的问题，不如将这个任务交给标准库，让他进行管理，通过std::async就能实现，他不一定会开一个新的线程，而是根据情况来决定，而通过策略的改变也能进行调整。</p><p>除非<strong>需要访问非常基础的线程API或者需要且能够优化应用的线程使用</strong>。</p><h3 id="如果有异步的必要则要用std-thread-async"><a href="#如果有异步的必要则要用std-thread-async" class="headerlink" title="如果有异步的必要则要用std::thread::async"></a>如果有异步的必要则要用std::thread::async</h3><ul><li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li><li>这个灵活性导致访问<code>thread_local</code>s的不确定性，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li><li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li></ul><h3 id="保证所有线程在结束的时候是不可结合的"><a href="#保证所有线程在结束的时候是不可结合的" class="headerlink" title="保证所有线程在结束的时候是不可结合的"></a>保证所有线程在结束的时候是不可结合的</h3><p>不可结合的包括，thread中没有包含内容，或者已经join或detach的。</p><p>如果对于一个可结合的线程隐式join或者detach都是非常恐怖的，因此，标准中如果对可结合的线程析构将会直接抛出异常。</p><p>可以使用RAII。</p><p>而在一个类中存储一个thread的时候，将thread放在最后，保证析构的异常安全。</p><h3 id="条款38，待补充"><a href="#条款38，待补充" class="headerlink" title="条款38，待补充"></a>条款38，待补充</h3><h3 id="条款39，待补充"><a href="#条款39，待补充" class="headerlink" title="条款39，待补充"></a>条款39，待补充</h3><h3 id="volatile和atomic"><a href="#volatile和atomic" class="headerlink" title="volatile和atomic"></a>volatile和atomic</h3><p>atomic能保证操作的原子性和对代码重排顺序的限制(一种弱序关系)，而volatile不行。</p><p>volatile则用来保证对这一块内存的操作不被优化。一般来说，如果两句语句之间没什么关系，那么编译器就会进行重排优化，重排完后，可能出现很多连续对同一个变量进行冗余访问和存储，因此就会被优化。</p><p>但是对一些特殊内存，如IO接口，实际上内容一直是在变化的，那么此时这些“冗余”访问和存储就不一定是冗余的了，不能被优化。</p><h3 id="对移动成本低的且总是拷贝的形参使用值传递"><a href="#对移动成本低的且总是拷贝的形参使用值传递" class="headerlink" title="对移动成本低的且总是拷贝的形参使用值传递"></a>对移动成本低的且总是拷贝的形参使用值传递</h3><p>一般为了处理左值和右值且高效，要重载两个函数或者使用通用引用。</p><p>然而有的时候使用值传递可能更便捷且增加不了多少开销。</p><p>值传递进来，并移动进去。</p><ol><li>不可拷贝的值传递相当于进行了构造，不可接受</li><li>移动成本低，因为会增加一次移动成本</li><li>总是拷贝，因为如果不总是拷贝，那么按理来说就不会构造一个新的变量，引用确实没有构造，然而，值传递构造了。</li></ol><p>有的时候，赋值操作会重用内存空间，但移动会增加内存申请和销毁的费用，这时候也不应该值传递。</p><p>在需要高性能的情况下，也不应该使用，因为移动的成本是不好估计的。</p><h3 id="使用emplace"><a href="#使用emplace" class="headerlink" title="使用emplace"></a>使用emplace</h3><p>更快，但是要保证传入的实参是正确的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++代码规范 </title>
    <link href="/c++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/c++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="c-代码规范"><a href="#c-代码规范" class="headerlink" title="c++代码规范"></a>c++代码规范</h1><h3 id="文件后缀名"><a href="#文件后缀名" class="headerlink" title="文件后缀名"></a>文件后缀名</h3><p>实现：.cc</p><p>声明：.h（模板声明和定义都写在.h里）</p><p>内联：.inc（不允许有-inl.h，也就是声明和定义写在一起）或者用于插入文本</p><p>实现和声明一一对应，除非如单元测试和只包含main函数的可以只有.cc。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>一个.h文件应该自给自足，其自身就应该include所有其他依赖头文件，并不要求定义任何特别symbols。</p><p>除了为模板提供实例化的模板函数需要定义在实例化改模板的.cc文件里。</p><ol><li><p><strong>define</strong></p><ul><li><p>头文件应该有#define保护来防止被多重包含，名字的格式是<PROJECT><em><PATH></em><FILE>_H_，全部都要大写。</p><ul><li><p>22</p><p>  2</p></li></ul></li><li><p>1</p></li><li><p><strong>使用</strong>：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> 名字</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> 名字</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>前置声明</strong></p><ul><li><p>尽量避免使用前置声明。只在需要避免循环嵌套的时候使用。一般来说前置声明是用来定义一个指针，用于避免重复编译。</p><p>  <strong>不使用的原因</strong>：没声明关系，声明冗长，更改后跳过必要的重新编译，是不完全类型。</p></li></ul></li><li><p><strong>内联函数</strong></p><ul><li><p>只有函数少于10行且不是折构，不包含循环和switch才应该内联。虚函数一般也不内联。</p><p>  <strong>不使用的原因</strong>：内联大量的代码是更低效率的，折构往往实际上很长。</p></li></ul><blockquote><p>类内部的函数会自动内联。</p></blockquote></li><li><p><strong>include</strong></p><ul><li><p><strong>头文件顺序</strong>：相关头文件，C库，C++库，其他库的.h，本项目的.h。并按照字典序排序，每个大部分用空行隔开。</p><p>  此处本项目的.h是指为了预留扩展性和满足接口编程的需要而引入的？。</p><p>  <strong>原因</strong>：为了保证本模块的问题先暴露</p></li><li><p><strong>路径格式</strong>：项目完整路径</p><p>  以减少隐藏依赖</p></li><li><p><strong>包含的头文件</strong>：实现文件只需要包含.h，其他文件包含一切直接用到的名字的头文件，即便这个头文件被包含在其他头文件内，除非其他头文件明确表示会提供这个名字</p></li><li><p><strong>例外</strong>：需要特殊宏判断的可以放在最后面。</p></li></ul></li></ol><blockquote><p>YuleFox</p><p>标准化函数参数顺序可以提高可读性和易维护性(对函数参数的堆栈空间有轻微影响, 我以前大多<br>是相同类型放在一起);</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li><p><strong>命名空间</strong></p><ul><li><p>只在局部作用域中声明命名空间别名</p><p>  头文件的全局作用域中声明的命名空间别名会成为公开的，导致污染</p></li><li><p>禁止使用using指示</p><p>  污染空间</p></li><li><p>禁止使用内联命名空间</p><p>  内联命名空间一般用于大型版本控制，保持跨版本的ABI兼容性，也就是通过内联新版本的一些函数来代替旧版本的函数但是旧版本的函数仍然是可用的。</p></li><li><p>不再std中声明任何东西</p><p>  是未定义的行为，会导致不可移植性</p></li></ul><p> <strong>格式</strong>：</p><ul><li><p>除了gflags(谷歌的写的一个更方便在命令行给程序传入参数的库)，头文件和类的前置声明以外的所有部分都应该被包含于一个命名空间中。命名空间内部内容不因为命名空间而缩进。</p></li><li><p>在命名空间右大括号后注释上namespace name(会自动补全)</p><p>  在插入新函数时能更快确定作用域</p></li><li><p>命名空间的命名可以根据绝对或相对路径</p></li></ul></li><li><p><strong>匿名命名空间和静态变量</strong></p><ul><li><p>在.cc中定义不需要被外部引用的对象时，建议使用匿名命名空间或声明为static。但不要在.h中使用。</p><p>  这二者都能使对象具有内部连接性，也就是这个对象的名字只能在本文件被访问。</p></li></ul></li><li><p><strong>非成员函数、静态成员函数和全局函数</strong></p><ul><li><p>尽量不要用裸的全局函数，尽量单独形成编译单元</p><p>  污染命名空间</p></li><li><p>静态成员函数应该与静态数据成员高度相关，不要用来当做限定作用域的非成员函数</p></li><li><p>非成员函数，不依赖于外部变量，应该被放于命名空间中</p><p>  避免污染</p></li><li><p>当一个静态成员函数被超过一个编译单元(cpp文件)所使用，可以考虑将其提取到新类中。</p><p>  避免耦合和依赖。</p></li></ul></li><li><p><strong>局部变量</strong></p><ul><li><p>局部变量限定于最小可能的作用域内，并在变量声明时进行初始化。if，while，for语句中需要的变量就在语句中声明即可，并且会在语句的作用域内可用。</p><p>  更易于理解。</p></li><li><p>例外：如果变量是一个对象，并且每次进出作用域都要调用折构和构造函数，那么不如定义在外层。</p><p>  省时间</p></li></ul></li><li><p><strong>静态和全局变量</strong></p><ul><li><p>对于静态存储周期的变量，只允许定义POD变量，并且不允许用使用了静态存储周期变量的函数来初始化它，除非变量是constexpr的。</p><p>  静态存储周期是指程序或者多线程开始时生成，程序结束时销毁的变量。包括全局变量，静态变量，静态类成员变量和函数静态变量。</p><p>  POD是指plain old data，是指不使用构造和折构函数的变量。</p><p>  由于初始化过程的顺序是未定义的，所以在程序开始初始化和程序结束折构的时候会出问题。</p></li><li><p>如果一定想要用一个非POD类型的静态存储周期的变量，可以在main或者pthread_once中初始化一个指针并永不回收，且不能用智能指针，因为它也是非POD的。</p></li></ul></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li><p><strong>构造函数的职责</strong></p><ul><li><p>构造函数不允许调用虚函数。</p><p>  构造函数中的虚函数并不会真正的调用虚函数。</p></li><li><p>如果构造函数出错，那么建议直接终止程序。否则应该用init()或者工厂函数来构造。</p><p>  因为错误处理被禁用了。因此并没有一个好的处理构造函数出错的解决方法。构造函数一旦出错，如果不报错，那就很难检查出这个呗构造出的对象是否正常。</p></li></ul></li><li><p><strong>隐式类型转换</strong></p><ul><li><p>类型转换运算符和单参数构造函数都应当被标记为explicit。</p><p>  可能会在无意识中发生隐式类型转换。</p><p>  函数重载并不知道调用的是哪一个函数。</p></li><li><p>拷贝和移动构造函数不应该被标记为explicit。</p><p>  因为拷贝和移动构造函数本身就不进行类型转换。</p></li><li><p>不以一个参数进行调用的构造函数不应加explicit，如列表初始化？。</p></li></ul></li><li><p><strong>可拷贝类型和可移动类型</strong></p><ul><li><p>如果一个类型不是很显然要拷贝移动操作的，就不要设置为可拷贝移动的。</p><p>  因为拷贝构造函数是隐式调用的，调用容易被忽略。</p></li><li><p>如果定义了拷贝操作，那么就应该定义移动操作。</p><p>  移动操作拷贝临时的对象，那么也能拷贝非临时对象。并且效率更高。</p></li><li><p>如果不定义拷贝移动操作，那么就应该定义为删除(&#x3D;delete)的。</p><p>  避免使用时无意识的隐式调用。</p><p>  使用delete时，若是拷贝操作被delete了，那么编译器也不会自动合成移动操作。</p></li><li><p>一旦定义，那么就应该是两个为1组出现的。</p><p>  赋值与构造。</p></li><li><p>不要给可能有派生类的基类定义拷贝移动操作，如有需要，应提供一个clone来解决。</p><p>  给基类定义拷贝移动操作可能会产生切割。</p></li></ul></li><li><p><strong>结构体与类</strong></p><ul><li><p>当且仅当只有数据成员时用struct，其他都用class。</p><p>  一般struct都是直接访问位域的，也就是直接通过点运算符，而class则通过函数。如果提供了用于设定数据成员的函数外的函数，那么就应该用class。</p></li><li><p>仿函数可以用struct。</p><p>  与STL保持一致。</p></li></ul></li><li><p><strong>继承</strong></p><p> 组合&gt;实现继承&gt;接口继承&gt;私有继承</p><ul><li><p>所有继承都必须是public的。</p><p>  其他继承为什么不用组合来代替。</p></li><li><p>只有关系是is的时候使用继承，其他时候使用组合。</p><p>  只有is才是一种继承关系，has就是组合关系了。</p></li><li><p>如果类有虚函数，那么折构函数也应该是虚函数。</p><p>  显然，因为这个子类是虚的，得要避免基类指针只调用基类的折构函数。</p></li><li><p>对于所有的重载函数都要用override标注。</p><p>  显式表明这是虚函数。</p></li><li><p>只有对一定会被子类访问的成员函数设置为protected。</p><p>  封装。</p></li></ul></li><li><p><strong>多重继承</strong></p><ul><li><p>只允许在最多一个基类是非抽象类其他基类都是以Interface为后缀的纯接口类时使用多重继承。</p><p>  一般都有别的可以来替代多重继承的方法。</p></li></ul></li><li><p><strong>接口</strong></p><ul><li><p>接口类应该以Interface为后缀。</p><p>  用以提醒这是接口类。</p><p>  一个纯接口必须满足：</p><ol><li>只有纯虚函数和静态函数</li><li>没有非静态数据成员</li><li>没有定义任何构造函数</li><li>如果要继承，也只能从纯接口类继承</li><li>折构函数没必要是纯虚函数</li></ol></li></ul></li><li><p><strong>运算符重载</strong></p><ul><li><p>只有在符号意义明确与内建运算符行为一致时才重载。</p><p>  重载本身就可能会出问题。如果意义与通常的约定不符时会难以理解。</p></li><li><p>只对自己定义的类型进行重载运算符，并将其定义在同一个空间中。</p><p>  不去影响内建运算符的含义，并且在何处都能使用这个运算符而不出错，并且避免了多重定义。</p></li><li><p>当定义了一个运算符，就应该将相关的运算符都重载。</p><p>  保证语义一致，不冲突。</p></li><li><p>不要将不进行修改的二元运算符定义为成员函数。</p><p>  不然就会只对第二个参数进行隐式转换。</p></li><li><p>不要强行去重载。</p><p>  如当一个类型不具备自然顺序，但我们希望将其放入set中，那么应该自定义一个比较运算符，而不是重载我们常用的&lt;运算符。避免给它加上不必要的含义。</p></li><li><p>不要重载&amp;&amp;，||和一元运算符&amp;，也不要重载operator””。</p></li><li><p>更不要重载运算符模板。</p><p>  除非适配了所有可能性。</p></li></ul></li><li><p><strong>存取控制</strong></p><ul><li><p>所有数据成员都声明为private，除非是static const的。</p><p>  封装。</p></li><li><p>存取函数一般内联。</p><p>  存取函数就是存取这些私有数据成员的函数。</p></li></ul></li><li><p><strong>声明顺序</strong></p><ul><li><p>按public,protected,private的顺序，没有空行。</p></li><li><p>在每个部分中按类型，常量，工厂函数，构造函数，赋值运算符，折构函数，其他函数，数据成员的顺序排。</p></li><li><p>只将性能关键且短小的函数内联。</p></li></ul></li></ol><blockquote><p>函数体应短小且功能单一。</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p><strong>输入和输出</strong></p><ul><li><p>返回值和输出参数相比，返回值更好。</p><p>  输出参数就是通过引用的方式来在函数内部进行更改，进行“输出”。</p><p>  返回值更加直观，可读性更好且性能更好？</p></li><li><p>输入参数用值传递或者const引用，其中超出生命周期的要用值传递。</p><p>  对于超出生命周期的对象进行const引用会访问不存在的对象。</p></li><li><p>可选参数中值传递用std::optional，其他可选输入用const指针，可选输出用指针。</p><p>  std::optional就是使一个类型可以为空。</p><p>  其他使用指针是因为指针可以为空指针。</p></li><li><p>将所有输入参数放在输出参数之前。</p><p>  可读性。</p></li></ul></li><li><p><strong>编写简短函数</strong></p><ul><li><p>建议所有函数都不要超过40行，若超过40行，应将其分割为多个小函数。</p><p>  更加易于管理与调试。</p></li></ul></li><li><p><strong>引用参数</strong></p><ul><li><p>输入参数如果是引用必须是const的，(输出参数一般为指针)。</p><p>  防止更改。另外实际上我们要的输入都是值输入，而引用就是有着指针属性的值输入。</p></li><li><p>有的时候输入参数可以使const指针，除非const指针比const引用更明智。</p><p>  如在可能传递空指针或者传递的是地址的时候就应该使用const指针。</p></li></ul></li><li><p><strong>函数重载</strong></p><ul><li><p>除非使用者能很容易分辨重载函数调用的是哪一个重载函数，否则不要重载。</p><p>  在函数名中加上参数信息或者使用初始化列表来解决同一类型的多个参数。</p></li></ul></li><li><p><strong>缺省参数(默认参数)(尽可能避免使用)</strong></p><ul><li><p>虚函数不许用缺省参数。</p><p>  虚函数的缺省参数值取决于静态类型。</p></li><li><p>如果缺省参数的值在变化，也不要用缺省参数。</p><p>  不仅用户会疑惑，缺省参数的值在每个调用点都会展开一次声明，然后就导致代码臃肿。</p></li><li><p>如果要用函数指针，那么也不要用默认参数，去用重载函数。</p><p>  函数指针无法使用默认参数，且加上默认参数后地址也会变。</p></li><li><p>缺省参数实际上也是一种重载函数，全部都可以使用重载函数代替。</p></li><li><p>限制于局部文件的地方和构造函数可以使用。</p><p>  一般不会去获取地址。</p></li></ul></li><li><p><strong>后置返回语法</strong></p><ul><li>只在后置返回语法能大幅度提升可读性时或者在使用lambda的时候使用。</li></ul></li></ol><h2 id="Google的奇技"><a href="#Google的奇技" class="headerlink" title="Google的奇技"></a>Google的奇技</h2><ol><li><p><strong>所有权</strong></p><ul><li><p>如果用动态分配的内存，那么就应该使用unique_ptr来明确所有权和所有所有权的传递。</p><p>  明确所有权，方便释放。</p></li><li><p>当且仅当拷贝的开销很大并且操作的对象不可变的时候可以使用shared_ptr共享所有权。</p><p>  拷贝的开销实际上不是很大，所有权一旦共享，可能就搞不清所有权了，并且共享所有权的运行开销很大。</p></li></ul></li><li><p><strong>cpplint</strong></p><p> 用于检测风格错误的一个py文件。</p></li></ol><h2 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h2><ol><li><p><strong>右值引用</strong></p><ul><li><p>只在移动构造函数和移动拷贝函数时使用右值引用。</p><p>  可以很大提高效率。</p></li><li><p>不要使用std::forward。</p><p>  太新了？，虽然完美转发需要std::forward。</p></li></ul></li><li><p><strong>友元</strong></p><ul><li><p>一般友元定义在同一文件内，一般工厂类和单元测试会被声明为友元。</p><p>  仍然保持着封装性。</p></li></ul></li><li><p><strong>异常</strong></p><ul><li><p>异常肯定是优于错误码的，适当的<strong>正确的</strong>使用异常时可行的。</p><p>  但是google禁用异常，大概率是因为历史包袱。</p></li></ul></li><li><p><strong>RTTI</strong></p><ul><li><p>RTTI可以进行合理的使用，可以在单元测试中使用。一般都有替代方案，虚函数和dynamic_cast(能保证基类对象都是指向同一派生类)。</p><p>  使用RTTI本身就表明设计是有问题的，且难以维护。</p></li></ul></li><li><p><strong>类型转换</strong></p><ul><li><p>使用c++的类型转换。</p><p>  const_cast去const。</p><p>  static_cast：值转换或者类指针向上转为基类指针。</p><p>  reinterpret_cast进行不安全的相互转换。</p><p>  dynamic_cast见上。</p></li></ul></li><li><p><strong>流</strong></p><ul><li><p>只在日志的时候使用流，其他时候都使用printf和read&#x2F;write。</p><p>  流可读性差，格式化慢，并且在输出时不容易关注到输出类型，导致错误。</p></li></ul></li><li><p><strong>自增自减</strong></p><ul><li><p>使用前置自增自减</p><p>  后置自增自减会产生一次拷贝，运行效率低。</p></li></ul></li><li><p><strong>const</strong></p><ul><li><p>在任何可能用的地方用const，使用时前置加一个const即可，不需对于部分都加一个定语。</p><p>  提供一层保护，对程序员自己的保护。</p></li></ul></li><li><p><strong>constexpr</strong></p><ul><li><p>在定义真.常量(运行和编译时都保持不变)的时候使用，或者在给常量初始化时使用。</p><p>  提高效率。</p></li></ul></li><li><p><strong>整型</strong></p><ul><li><p>内建类型的整型只用int，并且只认为它至少32位，但不多于32位。</p><p>  int是最常用的。</p></li><li><p>其他应该使用如int16_t或者int64_t，而不应该使用long long或者short等。</p><p>  在不同的平台上位数可能不同。</p></li><li><p>只在位域的时候使用无符号整数，用断言来处理无符号整数。</p><p>  无符号整数会导致很多抽象的bug。</p></li><li><p>专门的类型就用专门的类型别名，如size_t和ptrdiff_t。</p><p>  在不同的环境下也会随之发生改变。</p></li><li><p>宁愿更大，不要更小。</p><p>  避免溢出。</p></li></ul></li><li><p><strong>64位下的可移植性</strong></p><p>评价是不懂</p></li><li><p><strong>预处理宏</strong></p><ul><li><p>尽量少用宏，可以用内联，枚举或常量取代。</p><p>  宏很复杂。</p></li><li><p>防止重包含是例外。</p></li><li><p>除非有的地方其他实现不了，只有宏能行。</p></li></ul></li><li><p><strong>零赋值</strong></p><ul><li><p>字符串用’\0’，指针用nullptr，整数用0，实数用0.0。</p><p>  sizeof(NULL)和sizeof(0)还是不一样的。</p></li></ul></li><li><p><strong>sizeof</strong></p><ul><li><p>尽可能使用sizeof(变量)而非sizeof(类型)。</p><p>  使得变量即便类型改变也不会出问题。</p></li></ul></li><li><p><strong>auto</strong></p><ul><li><p>只在局部变量和尾置返回一起使用。</p><p>  还是为了易读性。在文件作用域，命名空间作用域和类数据成员都不要用auto，要显式指明。</p></li></ul></li><li><p><strong>列表初始化</strong></p><ul><li>评价是非常好用，只不过不要用来给auto赋值，除非你想创建一个initializer_list。</li></ul></li><li><p><strong>Lambda</strong></p><ul><li><p>可以适度按格式使用lambda。</p><p>  很好用。</p></li><li><p>捕获列表要写完整，最好显式写出返回类型。</p><p>  可读性好。</p></li><li><p>lambda应该简短，不超过5行。</p><p>  否则不如创建一个函数。</p></li></ul></li><li><p><strong>模板编程</strong></p><ul><li><p>减小模板的复杂性，并减少暴露在外的模板。</p><p>  模板本身的维护成本可能就超过了模板使用的简便性。</p></li></ul></li><li><p><strong>Boost库</strong></p><p>里面很多库都很好，可以学习。</p></li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li><p><strong>通用命名规则</strong></p><ul><li>使用描述性的命名，少用缩写。</li></ul></li><li><p><strong>文件命名规则</strong></p><ul><li>使用下划线分割，详细。</li></ul></li><li><p><strong>类型命名规则</strong></p><ul><li>类型名称的每个单词的首字母要大写，不用下划线。</li></ul></li><li><p><strong>变量命名规则</strong></p><ul><li>普通变量和结构体成员变量全小写并用_隔开，而类的成员变量在结尾需要再加一个_。</li></ul></li><li><p><strong>常量命名规则</strong></p><ul><li><p>常量的每个单词的首字母大写，不用下划线，在最前面加上k。</p></li><li><p>全局变量和静态变量也应该遵循这个命名规则。</p></li></ul></li><li><p><strong>函数命名规则</strong></p><ul><li><p>对于取值和设值函数，一般是与变量名匹配，设值会加一个set_。</p></li><li><p>对于其他函数，每个单词首字母大写没下划线。</p></li></ul></li><li><p><strong>命名空间规则</strong></p><ul><li>全小写字母，无下划线，注意不要冲突。</li></ul></li><li><p><strong>枚举类型规则</strong></p><ul><li>类型名按照类型。其中每个元素的命名按照常量或者宏的方式。</li></ul></li><li><p><strong>宏命名规则</strong></p><ul><li>全部大写，用下划线分割。</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最小堆与最大堆 </title>
    <link href="/%E6%9C%80%E5%B0%8F%E5%A0%86%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
    <url>/%E6%9C%80%E5%B0%8F%E5%A0%86%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="最小堆与最大堆"><a href="#最小堆与最大堆" class="headerlink" title="最小堆与最大堆"></a>最小堆与最大堆</h1><p>priority_queue的底层是vector</p><p>queue的底层是deque</p><p>堆是完全二叉树。</p><p>最小堆就是父节点小于子节点。</p><p>插入时每次加到最后，再从底向上更新一次。</p><p>删除时删除根，并将最后一个元素取代掉根，从底向上更新一次。</p><p>更新时是对于每一个节点所对应的堆进行更新。</p><p>插入就是加到最后，向上更新</p><p>删除就是交换根和最后一个元素，然后删掉“根”，向下更新</p><p>priority_queue传入的比较函数实际上是一个类型，是一个仿函数。</p><p>当一次性通过n个元素建堆时应该从下往上down（）,这样的复杂度可以降到O(n)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cmake </title>
    <link href="/cmake/"/>
    <url>/cmake/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><ol><li><p>set的变量可以在程序中的宏中使用</p></li><li><p>add_library.</p><ol><li>shared：生成.so或.dll文件，不嵌入代码，在使用时会根据.h来进行查找</li><li>static：直接将相关代码嵌入任何需要的地方，非常冗余，但很完整</li><li>interface：接口库，不单独生成库，只是作为接口给其他库使用</li></ol><p> 后面只跟随相关源文件 </p></li><li><p>target_link_libraries，属性一般与target_include_directories保持一致</p><ol><li>如果是public，则这个库可以被该库和依赖于该库的其他所有的使用</li><li>如果是private，则只能被当前这个文件夹的其他文件所使用，在这种情况下也就不用提供头文件</li><li>如果是interface，则当前文件夹不使用，但可以被其他的使用，一般用于设定一些设置或者全是头文件的情况下，或者该文件夹下不互相调用</li></ol></li><li><p>target_include_directories(要被连接到的库 方式 库)（指定头文件）</p><ol><li>private：自身要include，依赖于该库的不需要include这些</li><li>public：自身要include，依赖于该库的需要include这些</li><li>interface：自身不要include，依赖于该库的需要include这些</li></ol></li><li><p>add_subdirectory(…)</p><p> 生成的时候会按这个顺序，但是编译的时候则不会，会根据依赖的关系</p><p> 添加子文件夹，并处理子文件夹中的cmakelists，但是cmake中的依赖关系并不是上依赖于下的，也可以下依赖于上，也就是library是可以被子文件夹所使用的，一切看target_link_library。</p></li><li><p>if(…)</p><p> elseif(…)</p><p> endif()</p><p> matches即&#x3D;</p></li><li><p>option(name description default)</p><p> 和set差不多，但是可以在cmake的option中直接调整</p></li><li><p>include(某个cmake文件)相当于将该文件中的内容复制过来</p></li><li><p>add_custom_command相当于用命令行运行某条命令</p><p> output</p><p> command</p><p> depends</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HeadFirst design Pattern </title>
    <link href="/HeadFirst%20design%20Pattern/"/>
    <url>/HeadFirst%20design%20Pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="HeadFirst-design-Pattern"><a href="#HeadFirst-design-Pattern" class="headerlink" title="HeadFirst design Pattern"></a>HeadFirst design Pattern</h1><p>面向接口编程，上对下要有抽象中间层，上面自己也需要抽象顶层。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>继承会导致在添加新的行为的时候不够灵活，要们需要在每个子类中实现，如果在基类中实现那么即便是不需要这个行为的子类也会继承这个行为。</p><p>此时我们可以使用策略模式。</p><p>实际上就是一种将继承改为组合的例子。</p><p>将拥有行为者和行为分开，总共包括四个类，通过让行为者使用不同的行为就达成了行为改变的结果。</p><ol><li>抽象拥有者：拥有着抽象行为，和使用抽象行为的成员函数</li><li>抽象行为：拥有行为成员函数，全虚</li><li>具体拥有者：构造时指定其基类的抽象行为的具体行为，在调用抽象拥有者的行为的时候就可以调用对应的具体行为了</li><li>具体行为：实现抽象行为的行为接口</li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>实际上就是广播一些消息，只不过，这里的广播是调用观察者的成员函数罢了。</p><p>主要就是两大接口：</p><ol><li>被观察者接口：提供一个notify和存储订阅了本被观察者的列表（要附带一个订阅和取消订阅的成员函数来操作），如果可以的话可以在更新数据的时候进行setchange，来判断时候需要真正的进行notify，来控制notify的更新频率。通过notify来调用订阅了本被观察者的所有观察者的update函数。</li><li>观察者接口：提供一个update函数来供被观察者进行广播。</li></ol><p>在使用update的时候有两种模式。</p><ol><li>推模式：被观察者在调用update的时候直接把本被观察者的所有获取的信息传给update来供给操作。</li><li>拉模式：被观察者在调用update的时候，不提供任何获取的数据（也不能说任何，也可以提供一些都需要的数据），而是通过设一些getter来供给观察者来使用（而为了让观察者能够使用这些getter，在调用update的时候得要把自身传入其中），在update中观察者直接根据需求来使用getter来获取想要的数据。</li></ol><p>一般来说，推模式优于拉模式。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>正如其名，装饰模式就是在一个类的外部进行装饰。装饰的方法是使这个类或者不止一个类和他(们)的装饰器有一个共同的基类。</p><p>装饰器其中会存储一个基类指针来表示其装饰的对象，并通过于这个基类指针来互动来重写基类的方法。</p><p>通过这样的方式，可以对一个类进行多次的装饰，而使用者对于一个接收到的东西即便使一个装饰器但也可以把它当成一个普通的产品。</p><p>装饰器的构造函数就是传入一个基类指针。</p><p>官方的讲：可以动态地讲责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>将构造和new和具体构造函数解耦，将构造函数的部分与对其的基础的构造后续的部分包装进工厂中，使用者只需要面对工厂提供的构造接口，通过传入字符串或者其他的能够决定的参数来获取一个指向实际产品的基类指针，工厂会根据参数来选择对的子类的构造器。</p><p>而上层也应该去依赖基类而非具体类，就解耦了。</p><p>不同的使用者可以使用不同工厂。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂抽象了工厂，工厂基类定义了一系列的方法来提供一组产品，而子类工厂分别定义这些具体提供什么样的产品，而这可以使用工厂模式来实现。最终使用者将会接收一个抽象工厂的指针来使用对应的工厂来创造要使用的产品。</p><p>实现上，所有的产品都各自有基类，工厂使用这些产品，使用者使用抽象工厂。</p><p>通过传入的抽象工厂的不同，达成获得不同的一组产品。</p><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><p>全局变量在一开始定义的时候就会创建，而单例模式则是能将其延迟到使用的时候。并且仍然会保持它的单一性。</p><p>实现上就是将构造函数实现为private并提供另一个“构造函数”来提供实例，并且在类中还有一个自身的静态指针来存储这个唯一的单例，并且“构造函数”会根据当前时候创建了来决定是返回当前还是创建。</p><p>如果多线程要使用单例模式，可能需要加上线程锁。</p><p>不仅使用的时候需要使用atomic类的或者线程锁之类的东西，在创建的时候也需要注意多线程可能会创建多个“单例”。</p><p>一种处理方式，加锁。第二种，在一开始static那个实际单例的时候就初始化。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>通过将请求分装成对象通过中介交与执行者，请求者就与执行者解耦了。</p><p>通过这样，可以实现线程调度，日志记录，遥控器等等类似的要求。</p><ol><li>抽象请求：有一个执行接口，如果要支持撤销操作，还需有一个undo接口。</li><li>具体请求：通过工厂或生成器或用户生成具体的请求，实现接口。</li><li>执行者：通过调用抽象请求的执行或undo来处理请求。</li></ol><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>对象的适配器：使适配器以要转变(适配)为的对象为基类，组合一个被适配者(传入被适配者)，重新实现基类的所有虚函数即完成了适配。</p><p>类的适配器：适配器多重继承适配者和被适配者的类，重写其中的函数即可。</p><p>对象的适配器可以对适配者的所有子类都有效，而类适配器则完全不需要一个被适配者。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>通过给一个外观对象组合其管理的对象简化管理的对象的接口。实际上就是封装。</p><p>通过这种方式让使用者和底层组件解耦。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>将一类子类的某一个虚函数的共同的部分抽象出来到基类中，不同的部分再分别在子类中实现(纯虚函数)。对于有些子类有，有些子类没有的部分，可以使用钩子(虚函数)，钩子本身在基类中为空实现或者有默认实现，子类可以重写钩子来在特定的地方添加一些行为。</p><p>（泛化函数）</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>iterator</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>对于所有可能作为一颗树的结构都可以使用组合模式。</p><p>组件基类：接口类，实现获取孩子，等接口</p><p>让非叶子节点和叶子节点都实现基层这个组件基类，而对于整体这颗树进行处理的时候就可以遍历过程的所有节点都当作使组件基类来调用他的方法。而无需区分叶节点和非叶节点，即用一样的方法来处理整体和部分。</p><p>对于叶节点来说实际上就是非叶节点但孩子&#x3D;0。</p><p>例如窗口就是一个很经典的可以使用组合模式的例子。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>使一个对象的行为全部取决于其状态。即，对象持有一个状态基类指针。指向各种具体状态派生类。对象的行为也会因为实际持有的状态不同而去使用不同状态的虚函数，也就实现了不同状态有不同的行为。</p><p>而基类状态中可以实现一些非常基本的所有状态所同有的行为。</p><p>而状态也应该持有对象的指针，来改变对象的状态，当然，对象自身也可以主动改变自身的状态。</p><h3 id="策略模式是用户主观改变其使用的行为，而状态模式则是被动地使其随着状态的改变而改变行为。"><a href="#策略模式是用户主观改变其使用的行为，而状态模式则是被动地使其随着状态的改变而改变行为。" class="headerlink" title="策略模式是用户主观改变其使用的行为，而状态模式则是被动地使其随着状态的改变而改变行为。"></a>策略模式是用户主观改变其使用的行为，而状态模式则是被动地使其随着状态的改变而改变行为。</h3><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理继承于被代理对象，实现被代理对象的所有功能，用于控制被代理对象的访问。</p><p>远程代理，控制访问远程的被代理对象。</p><p>虚拟代理，用于帮助创建时间久的对象有一个替身。</p><p>权限代理，用于控制访问者的权限。</p><p>代理并没有给被代理对象添加新的行为，仅仅只是替代其作为被访问对象而已。</p><h2 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h2><p>将各种模式一起使用。</p><h3 id="Model-View-Controller模式"><a href="#Model-View-Controller模式" class="headerlink" title="Model-View-Controller模式"></a>Model-View-Controller模式</h3><p>视图：用户所看到的界面，所能操控的东西，所有用户的行为都将会发送给控制器来处理。界面的改变由模型和控制器来notify。其显示的信息来源与模型。</p><p>控制器：将用户的操作转化为实际可以操控模型的行为，具体来控制到底如何控制模型。并且notify视图的改变。</p><p>模型：真正的底层。实现所有的内容，并将信息发送给视图。</p><p>三者都是解耦的，可以随意进行更换。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gcc_std </title>
    <link href="/gcc_std/"/>
    <url>/gcc_std/</url>
    
    <content type="html"><![CDATA[<h1 id="gcc-std"><a href="#gcc-std" class="headerlink" title="gcc_std"></a>gcc_std</h1><p><a href="https://lhish.github.io/hide/type_traits">type_traits</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git </title>
    <link href="/git/"/>
    <url>/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>保存的是基于上面一个节点变更的内容</p><p>每一个节点都是一个版本。</p><p>git commit：在原本的节点下添加一个新的节点，也就是更新版本，于HEAD所在的位置</p><p>git branch name: 新建一个分支，于HEAD所在的位置</p><p>git checkout name: 切换当前所在分支，但最好使用git switch name来切换</p><p>git checkout -b name: 新建分支并切换到这个分支上</p><p>git checkout -b name name1（name1是一个本地的远程分支，形式…&#x2F;…）: 建立一个分支并将其与name1相关联，即远程追踪</p><p>在一般情况下，建立一个本地分支后push会自动创建一个远程追踪。</p><p>每一个远程分支都只能被一个本地分支远程追踪，当我们设置了一个远程追踪，其原本对应的本地分支的远程追踪就消失了。</p><p>所有的push pull等等都是根据其远程追踪来的。可以将其看做原本对应的本地分支的替身。</p><p>另一种设置的方法是</p><p>git branch -u name1 name: 与前面相反，这里的name1是远程分支，name是本地分支。若当前在name分支下，可以省略name。但只能用于已存在的分支。而checkout版本可以新建分支。</p><p>在更改远程追踪后，原本的本地分支与远程同名分支就完全没有关系了。</p><p>如果一个节点没有远程追踪，那么它就不能pull和push。</p><p>git checkout nodehash: 将HEAD指针指向这个节点</p><p>HEAD可以当做是一个隐形的分支，在一般情况是指向当前所在分支所指向的节点。</p><p>当checkout一个nodehash的时候会把HEAD显式化，但是若是切回普通分支，其会隐式，并且回到当前分支所指向的节点。</p><p>当使用另一个分支commit的时候就会创建出第二条通路出来。</p><p>在分支名字后加修饰符可以表示将其移动几格的一个临时变量。</p><p>^：往父节点一个，几个^就是往会几个</p><p>如果在^后加数字，是在当前节点有多个父节点的情况下指定哪一个父节点（如果进行了合并操作），其顺序与合并的顺序相同</p><p>~num：往父节点num个节点</p><p>这两种操作运算符可以链式使用，如<del>2^^2</del></p><p>git reset 位置：将当前分支指向目标位置，但是这个位置必须是已经存在的节点（不能在分离HEAD使用）</p><p>这里的位置既可以是hashnode，也可以是相对位置，也可以是分支</p><p>git revert 位置：在当前节点（HEAD）后创建一个节点，这个节点所做的改变操作将会使得原本的节点变为“位置”节点。并将当前分支指向这个新的节点。</p><p>git merge name:在本分支（HEAD）后新建一个节点，其内容将会融合本分支和name分支，同时这原本的两个分支所指向的节点都会成为该节点的父节点，不再是两个分支了，虽然“分支”还是分支。被merge的分支仍然会指向原本的节点。</p><p>merge只能merge两个不同的分支（这里的分支是指两条路上的，而非我们所创建的“分支”指针）的，若是相同分支，这当前节点会指向自己和被merge分支中版本更新的那个。</p><p>git rebase name (name1): 找到当前分支（好像不能使HEAD）&#x2F;(name1)与name的共同父节点，将自身所进行的更改在name上重新操作一遍，也是一种merge，不过把原本并行的操作变成了线性的，name分支仍然将指向原本的节点。但是其后面会加上对应的另一个并行分支所进行改变的所有节点，当前分支将指向最后一个节点。</p><p>若处于同一分支下，则将进行与merge一样的操作。</p><p>git branch -f name 位置: 将name分支指向位置</p><p>git cherry-pick 位置：这里的位置可以有多个位置，用空格隔开，将这些位置节点所做的操作一一做到当前分支（实际上是HEAD）下。这里的位置不能是本分支（非指针）下的。如git cherry-pick C1 C2 …</p><p>git rebase -i 位置：将当前分支（HEAD）所在分支（非指针）中位置没有操作的版本变化会显示一个文本文档，依次排序，可以重新调整顺序，删减节点，将里面最终的内容，也就是节点内容按顺序rebase到位置节点后，提供一个将所有节点改变merge成一个新的节点的选项，指向最后的节点。</p><p>在这种情况下，可以位置可以是自己分支上的（因为可能重排顺序，即便并没有变化）</p><p>git commit —amend: 在当前节点（HEAD）的父节点创建一个新节点表示新的修改，并将当前分支指向这个新节点，相当于是修改上一次的更新</p><p>git tag name 位置:给某个节点加上一个永久性的tag，虽然可以删除，但不能被移动，一般用来记录重大的里程碑。</p><p>当不写位置时，会将位置默认为HEAD。</p><p>git describe:对于当前节点（HEAD）会在它所在的路径上往上寻找最近的有tag的节点。</p><p>输出tag_距离_g&lt;当前节点的hash&gt;</p><p>如果当前节点有tag，这只输出当前节点的tag。</p><p>git clone（同时会把HEAD也clone）: 将远程仓库拷贝到本地</p><p>但不能push HEAD，因为它不是一个分支。</p><p>在clone完后，会产生两张图，一张表示远程的，一张表示本地的，而在远程的每一个对应分支所对应的本地分支所指向的节点上，会产生一个新的远程分支，名字是repo name&#x2F;branch name，如origin&#x2F;main。由于这个分支是“远程”的，因此不能直接对它进行操作。当switch到某个远程分支的时候，会直接在那个远程分支处分离出HEAD，后续操作都是对HEAD进行的操作。另外，当在本地图上作操作时并不会在远程图上做操作。</p><p>git fetch:从远程仓库更新本地仓库。总共有两步操作，一个是补上所有缺失的节点，二是更新所有本地图上的远程分支，使其余远程仓库一致。</p><p>但git fetch并没有对本地图的分支作任何更改。</p><p>当本地图的节点多于远程库的节点，其本地图有的节点也仍然会在，而本地图中没有的，远程图中的也会复制过来（因为节点的名称是不同的）</p><p>git pull&#x3D;git fetch;git merge</p><p>git push:当没有参数时会与push.default中的配置相关</p><p>将本地图同步到远程图，并且更新远程图中分支节点与本地图中的远程分支节点。</p><p>当远程图中的版本与本地图中的不同（其他的所有分支，只允许当前push的分支与远程不同），会不允许git push，必须先git fetch完之后才能git push。</p><p>在fetch后可以通过rebase或者merge来将我们所做的操作做到最新的分支上。</p><p>git pull —rebase&#x3D;git pull;git rebase 当前分支对应的远程分支</p><p>对于某一个分支进行pull实际上是fetch其对应远程分支上的路径并merge。</p><p>但fetch是fetch所有分支。</p><p>push的时候好像并不会将废弃的分支进行上传，好像是实际上只push当前分支所在路径上所做的一切更改。</p><p>有的时候远程仓库可能会锁定某个分支，不允许对于这个分支进行push。这个时候我们可以将main reset与远程仓库相同，然后新建一个分支，指向我们所做的更改，让后基于这个分支进行push</p><p>当远程库中存在没有使用的版本，这个会不会fetch过来。好像远程仓库中不会存在没有使用的版本</p><p>关于rebase于merge。merge能够保存所有版本的历史，条理更加清晰。而rebase会使提交树更加干净。</p><p>git push <remote> <place>:remote是仓库名，而place是指本地分支的名字，若是省略，则默认为当前分支。其会根据place在remote中的远程追踪?来更新。</p><p>git push <remote> <place1>:<place2>:place1是本地分支，place2是远程图上的分支（不是本地图上的远程分支），意思是将本地分支中远程分支中没有的部分push到远程分支中。</p><p>git fetch <remote> <place1>:<place2>:place1是指远程分支，place2是本地图上的分支，意思是将远程分支中本地分支中没有的部分fetch到本地分支上。</p><p>以上两种操作都可以看作是嫁接。</p><p>当以上两种操作的place1为空时，push会删除远程图上的place2分支，本地对应的远程分支也会被删除，fetch会创建一个place2分支</p><p>git pull也有参数，与fetch相同，作用就是fetch然后merge。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关联容器 </title>
    <link href="/hide/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <url>/hide/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>元素按关键字来保存和访问。</p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled.png" alt="Untitled"></p><p>map类型通常被称为关联数组。以关键字作为下标。</p><p>set就是关键字的简单集合。</p><p>multi就是一个关键字可以对应多个值。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>当对一个map中还没有的关键字对应的元素进行操作时，mao会自动创建一个新元素，其值值初始化。</p><p>其内部是通过pair来存储键值对的。</p><p>map和set都支持容器操作。</p><p>关联容器的迭代器都是双向的。</p><p>有序容器的关键字必须是可比较大小的。通过其&lt;运算符。</p><p>通过定义比较函数，并将其传入构造关联容器的参数中，即可实现自定义&lt;。</p><p>$$<br>container&lt;type,decltype(function)^*&gt;\ name(function);<br>$$</p><p>pair在头文件utility，默认是值初始化。</p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%201.png" alt="Untitled"></p><p>关联容器内部定义了三个类型别名。</p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%202.png" alt="Untitled"></p><p>map的关键字值不能改变，但其值可以改变。</p><p>set虽然提供有非常量迭代器，但是其关键字使不能被更改的。</p><p>一个有序容器的通过迭代器的遍历时根据关键字升序来遍历的。</p><p>关联容器的专用find是极优于泛型的find的。</p><p>一般对于关联容器使用泛型算法时，要么将其作为源序列或者以inserter作为目标位置。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%203.png" alt="Untitled"></p><p>insert的返回值是一个pair。第一个元素是指向插入元素的迭代器。第二个元素是bool类型，表示是否插入成功。True表示插入成功。False表示关键字已存在，新的插入失败。</p><p>若是multi的，因为不会存在插入失败，因此不存在第二个元素。</p><h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%204.png" alt="Untitled"></p><h3 id="map的下标"><a href="#map的下标" class="headerlink" title="map的下标"></a>map的下标</h3><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%205.png" alt="Untitled"></p><p>由于下标可能会插入新元素，而at获取的引用也可能改变值，因此const的map不能使用。</p><p>下标运算符的返回是关键字对应的值。而迭代器是一整个pair。</p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%206.png" alt="Untitled"></p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%207.png" alt="Untitled"></p><p>find相当于const的at。</p><p>实际上可以将upperbound当做k的尾后指针。</p><p>若两个bound返回相同则不存在这个元素，且这这两个bound将返回该元素应该插入的位置。</p><p>equal_range(k)返回的是pair&lt;lower_bound(k), upper_bound(k)&gt;。</p><h3 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h3><p>一般哈希能获得更好的平均性能。</p><p><img src="/image/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8Untitled%208.png" alt="Untitled"></p><p>当load_factor大于某个值时，会自动rehash。</p><p>reserve是保证在未来容器保存n个元素而并不会进行rehash的操作而保证效率。</p><p>STL对于很多类型都定义了哈希操作。</p><p>但是对于自定义类，需要定义哈希操作与&#x3D;&#x3D;运算符。</p><p>$$<br>container&lt;type,decltype(hash_f)^*,decltype(&#x3D;_f)^*&gt;\ name(桶大小,f,f)<br>$$</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态内存 </title>
    <link href="/hide/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/hide/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>静态内存：用来存储static变量与全局变量。</p><p>栈内存：用来存储普通局部变量。</p><p>内存池（自由空间，堆）：用来存储动态分配的对象。这些动态对象的生存期由程序显式控制。</p><blockquote><p>管理动态内存很棘手。</p></blockquote><h3 id="使用动态内存的原因"><a href="#使用动态内存的原因" class="headerlink" title="使用动态内存的原因"></a>使用动态内存的原因</h3><ol><li>程序不知道自己需要使用多少对象(容器)</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间共享数据</li></ol><h3 id="创建与销毁"><a href="#创建与销毁" class="headerlink" title="创建与销毁"></a>创建与销毁</h3><p>new，为对象分配空间并返回指向该对象的指针，使用默认初始化或默认构造函数。</p><p>格式为new type，type后可接()或{}来调用构造函数或列表初始化。可以在有单一初始化器时使用auto。</p><p>当没有只有内存时，new会抛出bad_alloc，可以使用定位new——在new后增加(nothrow)来避免throw，此时会返回空指针，二者都定义于<new>中。</p><p>delete，接受一个动态对象的指针，销毁该对象，并释放其对应内存，但内存的地址仍然可能存在在其他指针中，此时要么删除该指针，要么重置nullptr使其不成为空悬指针。</p><p>对象必须是动态的或者空指针且未释放过，否则行为未定义。</p><p>若是没有释放一个已经不再使用的空间，并且已经没有指针指向它了(内存泄漏)，这会导致内存泄漏，也就是这一部分的内存将再也不能被释放，除非程序结束。</p><p>必须显式释放。</p><p>由于内置类型没有折构函数，所以一个内置类型的指针即便离开了作用域其内存空间并不会有什么变化。</p><p>因此需要及时delete，但是很难，最好使用智能指针自动释放。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>负责自动释放所指向的对象。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled.png" alt="Untitled"></p><p>shared_ptr是一个类。</p><p>一般使用make_shared来初始化一个shared_ptr，其参数与类型的某个构造函数相同。</p><p>虽然使用make_shared初始化时其自身返回的shared_ptr已经引用计数为1，但是初始化赋值给对象时引用计数并不会增加，可能是在返回时直接被删除了。</p><p>在拷贝和赋值，离开作用域或销毁时，其引用计数都会实时改变。</p><p>shared_ptr的实现方式实际上是让其指向一个真正存储信息的指针，引用计数内容也保存在其中。(chat)</p><p>当引用计数为0时，shared_ptr会自动调用折构函数，也就是销毁对象，释放内存。</p><p>对于shared_ptr，由于只要有一个指针不销毁，那么其占用的空间就会一直存在，因此要记得销毁不再需要的shared_ptr。</p><blockquote><p>作用域运算符{}是不依赖于任何其他的关键字存在的，可以随时使用。</p></blockquote><blockquote><p>列表初始化返回的实际是一个initializer_list，可以当做是常量数组。</p></blockquote><p>当希望一个类共用一个对象并且不因为一个类对象的销毁而使其他产生问题，即可使用shared_ptr。</p><p>在这里static与shared_ptr的区别在于static可能会存在某个类对象删除了该static元素而产生未定义，而shared_ptr即便删除了也没有问题。</p><h3 id="与new结合使用"><a href="#与new结合使用" class="headerlink" title="与new结合使用"></a>与new结合使用</h3><p>当希望使用new来赋值shared_ptr时，由于智能指针的构造函数是explicit的，因此不能将普通指针转为智能指针，必须显式转换，使用直接初始化。即name(new type)。当在return时使用也一样。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%201.png" alt="Untitled"></p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%202.png" alt="Untitled"></p><p>但最好不要混用智能指针与普通指针。</p><p>当一个普通指针被托管给shared_ptr后，不要再使用普通指针的方式访问它，因为它可能已经被shared_ptr释放了。</p><p>.get()函数会返回智能指针所指向的普通指针，用于在某些只能传递普通指针的地方，但是当shared_ptr销毁时，其也会销毁。</p><h3 id="智能指针与其他"><a href="#智能指针与其他" class="headerlink" title="智能指针与其他"></a>智能指针与其他</h3><p>当程序异常结束时，直接管理的内存并不会自动释放，造成内存泄漏，而shared_ptr则会由于作用域结束而自动释放，保证程序的正常运行。</p><p>当使用没有折构函数的类时，也可以用智能指针来保证内存的释放。</p><p>在其他情况下，如关闭连接时，也可以传入新定义的delete并使用智能指针来保证会关闭连接（在不需要的时候）。</p><p>注意最好不要使用相同的内置指针来初始化或reset多个智能指针，并注意get的使用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr拥有对象。定义时必须将其绑定到一个new返回的指针上，但是仍然需要使用直接初始化。另外，不能对其进行拷贝与赋值，但是可以通过release与reset来拷贝，且可以拷贝或赋值一个将要销毁的unique_ptr，通过return的方式。需要传入删除器的类型是因为其会影响其类型与构造方式等。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%203.png" alt="Untitled"></p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr也是一种shared_ptr，不过其自身并不计入引用计数。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%204.png" alt="Untitled"></p><p>由于weak_ptr可能指向为空，因此不能直接访问其指向对象，需要通过.lock()来间接访问shared_ptr来获取其访问对象。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>在使用时用new type[num]，可以将type[num] using 一下。返回的是一个指向第一个元素的指针。</p><p>动态数组并不是数组类型，因此不能for，不能begin，end，也不能使用下标运算符。</p><p>初始化的方式仍然可以使用()进行值初始化或列表初始化，不同的是这里不能使用auto。</p><p>有趣的是，动态数组的大小可以为0，此时将返回一个类似于数组尾后指针的指针，不能解引用。</p><p>释放时使用delete[] p。p指向动态数组的第一个元素，并倒序删除。若p是指向其他元素的，则将未定义。</p><p>可以使用unique_ptr来管理动态数组。由于是数组，因此其他运算符没有意义，但如release，reset等仍然可用，通过在类型后加[]来表示定义一个数组，此时它将可以用下标来访问元素。release时会自动调用delete[]。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%205.png" alt="Untitled"></p><p>shared_ptr不提供管理动态数组。但是通过传入删除器的方式仍然可以使其来管理，但很愚蠢，通过.get()来获取其首元素来访问数组，也就是原本传入shared_ptr时使用的指针。</p><h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>new与delete都是将内存操作与对对象的操作绑在一起，但则会造成不灵活，且可能会造成不必要的浪费。如定义了一个string，然后读入这个string，在这个过程中string被赋值了两次。</p><p>另外，更重要的是，如果一个类没有默认构造函数，那么就不能动态分配数组。</p><p>allocator定义于<memory>。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%206.png" alt="Untitled"></p><p>用allocate来分配内存，会返回指向内存块首的指针，deallocate来释放内存，p与n必须与allocate时完全一致。construct构造对象，destroy销毁对象，即调用折构函数。</p><p>必须先destroy再deallocate，因为deallocate之后对象仍然存在，如果此时进行destroy，那么其折构函数访问对象成员时就会出问题，因为已经释放了。</p><p>只对construct了的对象进行destroy，且只有对于已经construct了的内存对象才能进行普通的操作。</p><p><img src="/image/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98Untitled%207.png" alt="Untitled"></p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编 </title>
    <link href="/%E6%B1%87%E7%BC%96/"/>
    <url>/%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ol><li><p>编译</p><p> nasm -f elf 文件名</p><p> -f：指定输出文件格式，elf：linux格式下的可执行文件</p><p> ld -m elf_i386 -s -o 目标文件名 原可执行文件名</p><p> ld：调用ld链接器 -m：指定格式(elf_i386) -s：去除所有符号表和重定位信息,生成更小的可执行文件 -o：指定输出名</p></li><li><p>代码部分（section后面都有空格）</p><ol><li>section .data：常量</li><li>section .bss：变量</li><li>分号后是注释，如&#x2F;&#x2F;</li><li>section .text：代码，格式必须是</li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nasm">section.text<br>   global _start ;must be declared for linker (gcc)<br><br>_start:         ;tell linker entry point<br>   code<br></code></pre></td></tr></table></figure></li><li><p>每一句代码的格式：$[label]\ 操作码\ [目标对象地址]\ [源对象地址]$</p><p> INC：  1  加1</p><p> MOV：2  后赋值前</p><p> ADD： 2 后加到前</p><p> AND： 2 后与前</p></li><li><p>内存一般有三个部分：</p><ol><li>数据段</li><li>代码段</li><li>堆栈</li></ol></li><li><p>寄存器</p><ol><li><p>普通寄存器：EAX，EBX，ECX，EDX</p><p> 低16位：AX(accumualator，用于输入输出和算数)，BX(用于索引地址)，CX(记录循环次数)，DX(输入输出)</p><p> 低8位：AL，BL，CL，DL</p><p> 中低8位：AH，BH，CH，DH</p></li><li><p>指针寄存器(ESP，EBP)</p><p> SP：栈指针(函数调用就会下移，返回就上移)</p><p> BP：栈数据指针，指向函数的局部变量和参数</p><p> IP：记录下一条要执行语句的位置</p></li><li><p>索引寄存器(ESI，EDI）</p><p> SI：源对象地址</p><p> DI：目标对象地址</p></li><li><p>标志状态寄存器</p><p> OF：计算溢出</p><p> DF：表示字符串处理方向</p><p> IF：是否启用外部中断(如键盘)</p><p> TF：是否启用单步执行(调试)</p><p> SF：算数结果的符号</p><p> ZF：运算或比较的结果是否为0</p><p> AF：存储第3位到第四位的进位情况(有些运算需要)</p><p> PF：奇偶校验</p><p> CF：存储最高位进位</p></li><li><p>段寄存器</p><p> CS：代码段寄存器，记录代码段的起始处和最大大小</p><p> DS：数据段寄存器，记录全局变量和静态变量的首地址和最大大小</p><p> SS：堆栈段寄存器，记录栈的底部位置和最大可扩展深度</p><p> ES：额外段寄存器，可以临时被更改指向用于访问特定空间，用于字符串</p><p> FS&#x2F;GS：同ES</p><p> 由于指向的地址一般为16的整数倍，因此在16进制下，最右侧的一位0被省略</p></li></ol></li><li><p>系统调用</p><p> 系统的内核中有一些已经写好的汇编函数，可以用来使用当前系统进行一些操作，而不需要知道细节。</p><p> 方法：将syscall的代码mov入EAX，将参数mov入EBX，ECX等等，最后调用相关中断（int 0x80&#x2F;80h)。</p><p> syscall的代码能在&#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd.h中找到。</p><p> sys_exit 返回状态码</p><p> sys_read 输入状态码 address length</p><p> sys_write 输出状态码 address length（只能输出字符字符串）</p><p> sys_write null address length</p><p> sys_close(对文件) null 文件描述符（文件描述符在创建新文件或打开现有文件时会生成一个）</p><p> sys_open ？</p></li><li><p>寻址</p><ol><li>寄存器操作数：操作数为寄存器（<code>MOV EAX, EBX</code>）</li><li>立即操作数：操作数为立即数，一般为第二个操作数（<code>ADD BYTE_VALUE, 65</code>）</li><li>直接存储地址：使用变量名存储地址(偏移值)（<code>ADD BYTE_VALUE, DL</code>）(byte_value就是变量)</li><li>直接偏移寻址：就像数组一样，用数组名[n]或者数组名+n来获取</li><li>间接存储器寻址：对于一个变量，给它加上[]就是取地址，而给寄存器加上[]就是获取其存储的地址所指向的值。</li></ol><p>对于mov来说不能将memory移动到memory，一般来说都会通过寄存器来中转。</p><p>如果一开始定义变量没有定义类型，那么给它mov立即数时要在立即数前加上类型来避免歧义<code>mov[name],  dword &#39;Nuha&#39;</code>。</p></li><li><p>定义变量（变量实际上就是一个地址，指向内存中的一个位置）</p><ol><li><p>要初始化D(B&#x2F;E&#x2F;D&#x2F;Q&#x2F;T)</p><p> 变量名 类型 初始值（可以是各种类型的初始值，只是按照这种类型的方式存储了）</p><p> 可以一下子写很多初始值，相当于申请了一个数组，而对于字符串来说本身没有逗号也算是一个字符数组了</p></li><li><p>不初始化RES(B&#x2F;E&#x2F;D&#x2F;Q&#x2F;T)</p><p> 为未初始化的数据保留空间。</p></li><li><p>定义数组</p><p> 变量名 times 数组大小 类型 初始化值(给每一个元素都赋这样的初始值)</p></li></ol><p> 当连续进行定义的时候会连续分配空间？ </p></li><li><p>定义常量</p><ol><li><p>equ</p><p> 常量名 equ 表达式(如变量和变量✖️)</p></li><li><p>%assign</p><p> 常量名 assign 值(不知道可不可以表达式)</p><p> 可以被重复赋值，但是有限制，只能用这个定义表达式对已定义的进行修改。</p></li><li><p>%define(宏)</p><p> %define 被替换字符串 替换字符串</p></li></ol></li><li><p>算数运算</p><ol><li><p>inc&#x2F;dec(可以操作内存)，加减1</p></li><li><p>add&#x2F;sub，会影响溢出和进位状态位</p></li><li><p>mul(无符号)&#x2F;imul(有符号) 乘数</p><p> 被乘数必须是已经放在特定寄存器中了</p><p> 1字节相乘：放AL，结果在AX</p><p> 2字节相乘：放AX，结果在DX(高)和AX(低)</p><p> 4字节相乘：放EAX，结果在EDX和EAX</p></li><li><p>div&#x2F;idiv 除数（会影响状态标志位，OF,SF,ZF,AF,PF,CF）</p><p> 2字节&#x2F;1字节：放AX，AL为商，AH为余数</p><p> 4字节&#x2F;2字节：高位放DX，低位放AX，商在AX，余数在DX</p><p> 8字节&#x2F;4字节：高位放EDX，低位放EAX，商在EAX，余数在EDX</p></li></ol></li><li><p>逻辑运算</p><ol><li>and,or,xor,not，会更改第一个操作数，并改变标志状态位(CF,OF,PF,SF,ZF)</li><li>test，与and效果一致，但不会更改第一个操作数，但会改变标志状态位。</li></ol></li><li><p>汇编条件</p><ol><li><p>设定label，格式，一行label:</p></li><li><p>无条件跳转，jmp label。</p></li><li><p>有条件跳转，通过判断标志状态位来选择是否跳转。</p><p> 可以通过cmp来辅助跳转，判断两个是否相等。</p><table><thead><tr><th>条件跳转指令</th><th>检查的标志位</th><th>跳转条件</th></tr></thead><tbody><tr><td>JE&#x2F;JZ</td><td>ZF</td><td>相等&#x2F;为零时跳转</td></tr><tr><td>JNE&#x2F;JNZ</td><td>ZF</td><td>不相等&#x2F;不为零时跳转</td></tr><tr><td>JG&#x2F;JNLE</td><td>SF, ZF</td><td>大于&#x2F;不小于等于时跳转</td></tr><tr><td>JGE&#x2F;JNL</td><td>SF, OF</td><td>大于等于&#x2F;不小于时跳转</td></tr><tr><td>JL&#x2F;JNGE</td><td>SF, OF</td><td>小于&#x2F;不大于等于时跳转</td></tr><tr><td>JLE&#x2F;JNG</td><td>SF, ZF</td><td>小于等于&#x2F;不大于时跳转</td></tr><tr><td>JA&#x2F;JNBE</td><td>CF, ZF</td><td>高于&#x2F;不低于等于时跳转</td></tr><tr><td>JAE&#x2F;JNB</td><td>CF</td><td>高于等于&#x2F;不低于时跳转</td></tr><tr><td>JB&#x2F;JNAE</td><td>CF</td><td>低于&#x2F;不高于等于时跳转</td></tr><tr><td>JBE&#x2F;JNA</td><td>CF, AF</td><td>低于等于&#x2F;不高于时跳转</td></tr><tr><td>JCXZ</td><td></td><td>CX寄存器为零时跳转</td></tr><tr><td>JC</td><td>CF</td><td>有进位时跳转</td></tr><tr><td>JNC</td><td>CF</td><td>无进位时跳转</td></tr><tr><td>JO</td><td>OF</td><td>有溢出时跳转</td></tr><tr><td>JNO</td><td>OF</td><td>无溢出时跳转</td></tr><tr><td>JP&#x2F;JPE</td><td>PF</td><td>奇偶校验为偶数时跳转</td></tr><tr><td>JNP&#x2F;JPO</td><td>PF</td><td>奇偶校验为奇数时跳转</td></tr><tr><td>JS</td><td>SF</td><td>负值时跳转</td></tr><tr><td>JNS</td><td>SF</td><td>正值时跳转</td></tr></tbody></table></li></ol></li><li><p>汇编循环</p><p>虽然可以使用条件和跳转来实现循环，但也可以更加简便。</p><p>loop label</p><p>次数为ecx中存储的数字，ecx会递减，直到0。</p></li><li><p>汇编编号</p><p>汇编中输入，都会用ascii存储。如果要进行算数运算，就得先-’0’将其转为数字，运算后再转回去，效率低下。</p><p>在ascii(或者BCD)下进行三者运算后和除法前进行调整来在ascii下的运算也能是正确的，AA(A&#x2F;S&#x2F;M&#x2F;D)，并使用DA(A&#x2F;S)来调整小数加减。对于压缩的BCD(两位放在一个字节)不能乘除。</p></li><li><p>字符串</p><p>要获取一个字符串的长度，一种方式是显式定义长度，另一种是在字符串定义之后，立即计算$-字符串变量名，$代表现在能用的存储开头，而字符串变量名指的是字符串的首地址，相减得出的自然就是长度了。</p><ol><li>MOVS EDI ESI，将EDI指向的内存存储的字符串MOV到ESI指向的内存</li><li>LODS (E)A(X&#x2F;L) ESI，将ESI指向的内存存储的字符串MOV到寄存器中</li><li>STOS EDI (E)A(X&#x2F;L)，将寄存器存储的字符串MOV到ESI指向的内存存储中</li><li>CMPS ESI EDI，将两处字符串进行比较</li><li>SCAS EDI (E)A(X&#x2F;L)，将内存中的字符串与寄存器中的字符串进行比较</li></ol><p>更大的部分进行操作的时候在指令后加上对应的字母(B&#x2F;W&#x2F;D)</p><p>方向标志会决定进行的顺序，无方向则从小到大，否则从大到小</p><p>在操作前加上REP会使操作进行CX(随之变小)次，REPE&#x2F;Z和REPNE&#x2F;Z会根据0标志位来决定是否继续循环。</p></li><li><p>函数</p><p>对于一段代码，在前面加上label:，在结尾加上ret这一段程序就变成函数了。</p><p>在调用时，直接call label即可。</p></li><li><p>栈（用于形参等方面）</p><p>push memory&#x2F;reigiter&#x2F;imediate</p><p>pop memory&#x2F;reigiter</p></li><li><p>宏函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nasm">%macro name 参数个数<br>body;要用参数的时候直接按顺序形参名分别位%i<br>%endmacro<br><br>调用：name 参数1, 参数2....<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>差分约束 </title>
    <link href="/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <url>/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><p>一个差分约束问题是一个线性规划问题，只不过只有一个限制条件。</p><p>Ax$\le$B。</p><p>而在A矩阵中每一行只存在一个1和一个-1，其他全为0。</p><p>我们可以将这个问题转换为一个图论问题。</p><p>对于这样的问题，我们进行建图，如果存在一个$x_i-x_j\le a$，则建立一条从$x_j$到$x_i$的边，边的权重为a。</p><p>另外新建一个节点$x_0$，它指向所有的原有未知数节点，权重大小都为0。</p><p>这个图被称为约束图。</p><p>最终求$x_0$到其他所有节点的最短路，得出的最短路径的长度就是每个未知数的一个可行解。</p><p>当存在包含负环时，无解。</p><p>接下来用$w表示边的权重，\delta表示最短路$，由于$\delta(v_0,v_j)\le\delta(v_0,v_i)+w(v_i,v_j)$，这是由于右式是一条可行路径，因此最短路小于等于可行路径。因此，$\delta(v_0,v_j)-delta(v_0,v_i)\le\ w(v_i,v_j)$，符合差分约束条件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑树 </title>
    <link href="/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="https://files.catbox.moe/54xclr.png" alt="https://files.catbox.moe/54xclr.png"></p><p><img src="https://files.catbox.moe/krcb5i.png" alt="https://files.catbox.moe/krcb5i.png"></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="https://files.catbox.moe/rcl4yj.png" alt="https://files.catbox.moe/rcl4yj.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的新节点或者需要调整的节点必然是红色的</p><p>当该节点的父亲是红色的时候，就需要调整。</p><p>情况一：叔节点是红色，将爷节点的黑色下放</p><p><img src="https://files.catbox.moe/c62w8n.png" alt="https://files.catbox.moe/c62w8n.png"></p><p>情况二：叔节点是黑色，当父节点是左节点时，本节点是左节点就右旋，右节点就左旋，有节点则相反，当与叔节点是异边节点时调整颜色</p><p>操作完成之后要么循环结束，要么矛盾节点上移产生新的矛盾</p><p>仍然没有搞懂为啥左节点的时候就不能左旋，虽然确实会不平衡，但为什么这样就会不平衡呢</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>二叉搜索树的删除</strong></p><p>情况一：要删除的节点有一个子节点不存在，将子节点替换掉本节点即可</p><p>情况二：两个子节点都存在，在右子树上找到第一个没有左节点的节点，将它替换掉本节点，其右子树直接上升</p><p><img src="https://files.catbox.moe/3wbhvn.png" alt="https://files.catbox.moe/3wbhvn.png"></p><p>实现方法：tranplant函数，即用某节点替换某节点</p><p><strong>红黑树的删除</strong></p><p>无论是情况一还是情况二中，唯一会影响红黑树的正确性的就是y的移动，因此需要记录y的原始颜色。</p><p>情况一：y的原始颜色就是z的颜色。</p><p>情况二：y的原始颜色就是上图中y中的颜色。因为最后y的颜色会改为z的颜色，所有是y原本的颜色消失了。</p><p>而这一切的产生的违反性质的问题都将在x节点上反映出来，x为y的子节点。</p><blockquote><p>不知道为什么有x是根节点的情况</p></blockquote><p>当x为红色时，染黑即可。</p><p>当x不为红色为黑色时，将它变红。</p><blockquote><p>为什么2,3,4的父节点是红的，如果节点是黑的是否有问题</p></blockquote><p>情况一：如果兄节点是红的，将它转为黑的，变为情况2,3,4</p><p>情况二：如果兄节点的两个孩子都是黑的，可以将x一重黑与兄节点的黑色提到父节点，即可去除一重黑。</p><p>情况三：如果兄节点的左孩子是红的，右孩子是黑的，将其右孩子转为红色，转为情况4。</p><p>情况四：如果兄弟的右孩子是红的，直接解决。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>强联通分量 </title>
    <link href="/%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <url>/%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="强联通分量"><a href="#强联通分量" class="headerlink" title="强联通分量"></a>强联通分量</h1><p>强联通分量指的是一个有向图中的一部分节点，而任意两个其中的节点互相的路径是相通的，既能从一个节点到另一个节点，也可以从另一个节点到这个节点。</p><p>一个图必然能够被分为几个强联通分量的组合，而若是将这几个强联通分量的节点聚合为一个节点，就会得到一个有向无环图，称为分量图。</p><p>求出强联通分量的方法如下：</p><p>首先对图进行深搜，对于每一个节点记录到达顺序和离开顺序，离开顺序和到达顺序共用一个顺序。</p><p>根据这个离开顺序，倒序进行一次深搜，不过深搜的是原图的转置(所有的边的方向都变成原来的反向)。在这种情况下，所能搜索到的必然是一个强联通分量里的所有节点，将这一部分剥离出来后，继续选择剩下的中离开顺序最后的，进行相同的操作。</p><p>原理：</p><p>首先强联通分量之间的边上的那个节点(假设深搜树走了这条边，否则就选择离开顺序最后的那个节点），设其离开顺序为f1，其所连接的强联通分量也一样，设其离开顺序为f2。</p><p>则f1&gt;f2。</p><p>如果路径是从f1→f2的。</p><p>并且首先搜索了f1，那么肯定会由于这条连接边先去搜索f2的强联通分量的所有节点，后返回该强联通分量的节点并进行离开，所以离开顺序后于f2。</p><p>如果首先搜索了f2，那么f2就必然没有一条边能够来到f1强联通分量，否则这两个就是同一个强联通分量了。因此会先把f2搜索完成并离开完成才会去搜索f1，再离开，因此f1&gt;f2。</p><p>由于上述原因，当我们选择离开顺序最后的强联通分量，那么这个强联通分量的所有的与其他强联通分量的边都是由该强联通分量指向其他强联通分量的，因此在图的转置中，其将没有任何一条能够前往其他强联通分量的边，因此可以直接分离，并重复操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>散列(hash) </title>
    <link href="/%E6%95%A3%E5%88%97(hash)/"/>
    <url>/%E6%95%A3%E5%88%97(hash)/</url>
    
    <content type="html"><![CDATA[<h1 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h1><p>在一个域(一个集合)中，其中存在着一个实际域，包含着我们所实际用到的元素，如自然数是一个域，其中我们有一个实际域，比如说{1,2,3}。这些作为关键字指向元素，这里的关键字就是指数组的下标一样的东西，根据一个关键字，我们就可以得到它所指的元素。</p><p>当全域较小的时候，我们可以之间建立一个表，一一对应。</p><p>但是当全域较大但是实际域并不大的时候，这就过于浪费存储空间了，因为很多的关键字都对应着NIL(空)，因此，我们可以通过一个散列表来建立关系。</p><p>散列表是通过一个散列函数$h(x)$来建立对应关系的。</p><p>但是不管怎么样，只要我们散列表所</p><h3 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h3><p>将散列表做成一个链表的集合，在通过散列函数$h(x)$求得值后，在其所对应的链表中进行比对寻找。</p><p><img src="https://fastly.jsdelivr.net/gh/lhish/picture@main/16790580823151679058081587.png" alt="https://fastly.jsdelivr.net/gh/lhish/picture@main/16790580823151679058081587.png"></p><p>时间复杂度为$O(a+1)(a为链表长度)$</p><p>因为散列函数的时间复杂度是$O(1)$</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数就是一个很普通的数学公式，将一个数映射到另一个数，如通过$\bmod$，等等方式。</p><p>但是，由于散列函数存在冲突，所以当一个散列函数被确定的时候，可以通过制造一些特定的数据，来使得散列函数的时间复杂度最劣。</p><p>我们希望能够有一个散列函数对于任何数据都有着良好的时间复杂度，若专业来说就是如下。</p><p><img src="https://files.catbox.moe/2pec7u.png" alt="https://files.catbox.moe/2pec7u.png"></p><p>一个最简单的全域散列函数就是$h_{ab}(k)&#x3D;((ak+b)\bmod p)\bmod m a和b\le p-1且属于Z,p为全域,m为映射后的域$，通过一些数论的知识可以证明。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>每一个散列表的槽只能放一个元素，因此散列表的大小需要大于关键字的数量。插入的方法就是按照位置的一个排列的顺序去找空位，若有空位，则插入。</p><p>此处，为了保证这个排列是均匀散列，即探查序列的排列需要是等可能的所有排列中的任何一种，需要去设计探查的方法。</p><p>所有的探查方式的探查顺序都通过一个函数来实现， $i^{‘}&#x3D;h(k,i)$。</p><p><strong>线性探查</strong></p><p>$h(k,i)&#x3D;(h^{‘}(k)+i)\bmod m$</p><p><strong>二次探查</strong></p><p>$h(k,i)&#x3D;(h^{‘}(k)+c_1i+c_2i^2)\bmod m$</p><p><strong>双重散列</strong></p><p>$h(k,i)&#x3D;(h_1(k)+ih_2(k))\bmod m$</p><p><strong>优劣</strong></p><p>双重散列&gt;二次探查&gt;线性探查</p><p><strong>实际应用双重散列</strong></p><ol><li>取m为2的幂，并使h2总产生奇数</li><li>取m为素数，并使h2总是产生比m小的正整数</li></ol><p><strong>时间复杂度分析</strong></p><p>插入：$\frac{1}{1-a}$</p><p>查找：$\frac{1}{a}\mathrm{ln}\frac{1}{1-a}$</p><p>a为装载因数，即$\frac{插入的个数}{散列表的大小}$</p><h3 id="完全散列"><a href="#完全散列" class="headerlink" title="完全散列"></a>完全散列</h3><p>将链表法的链表改为一个散列表，使其大小$m_j&#x3D;n_j^2$，即放入该槽元素个数的平方。</p><p>可以证明，冲突的概率小于0.5**(定理1)**，因此可以多次随机散列函数，即可找到一个不冲突的散列函数。</p><p>当n比较大的时候，可以进行第三次散列。</p><aside>💡 我不确定是不是这个意思，下面是原话</aside><p><img src="https://files.catbox.moe/cp0gt1.png" alt="https://files.catbox.moe/cp0gt1.png"></p><p>还可以证明，总的空间复杂度为$O(n)$<strong>(定理2)。</strong></p><p>且，总存储空间大于4n的概率小于0.5。</p><p>因此得出的结论如上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>离散 </title>
    <link href="/%E7%A6%BB%E6%95%A3/"/>
    <url>/%E7%A6%BB%E6%95%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h1><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>无序对</p><p>无序积 &amp;</p><p>多重集</p><p>重复度</p><p>无向图G</p><p>顶点集V 无序积</p><p>边集E</p><p>有向图D 多重子集</p><p>n个定点的图被称为n阶图</p><p>无边为零图</p><p>平凡图： 1阶0图</p><p>空图：无顶点</p><p>环：两端点重合</p><p>关联，关联次数：与边相接的边数</p><p>相邻：共同点或共同边</p><p>有向图始点，终点</p><p>相邻也要遵从有向</p><p>孤立点：没边</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>度d：连接的边数，环算2</p><p>握手定理：度和为2*边</p><p>有向图出就是出度，如就是入度</p><p>悬挂顶点：度1，悬挂边</p><p>最大(小)(入&#x2F;出)度△&#x2F;δ</p><p>度数为奇数的顶点为偶数个</p><p>有向图入度&#x3D;出度&#x3D;边数</p><p>度数列：每个节点的度的数组</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>平行边：关联同一对顶点</p><p>重数：平行边的数量</p><p>有向平行边：简称平行边</p><p>多重图：有平行边</p><p>简单图：无环无平行边</p><p>无K$_n$(有)向完全图：m&#x3D;n(n-1)(&#x2F;2)</p><p>k-正则图：无向图且度都为k</p><p>无≥3(有≥2)向圈图，无向的简称圈图</p><p>轮图：≥4无向圈图加一点全连</p><p>n方体图：以2进制记录每一个点，只与其只有一位不同的点相连</p><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>(真)子图，母图：V和E都(或真)包含于</p><p>生成子图：只去边</p><p>导出子图G[V’&#x2F;E’]：根据选择的V’或E‘将相关的另一个集合中的元素全部保留</p><p>补图：对于无向图，补成完全图的边集所得图</p><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>同构：完全一致，可以通过调整边和点的位置来使其相同</p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>通路：a→b的一条路</p><p>长度：边的数量</p><p>回路：a&#x3D;b</p><p>简单通&#x2F;回路：边异</p><p>初级通&#x2F;回路(路径&#x2F;圈)：边异且点异</p><p>奇&#x2F;偶圈</p><p>复杂通&#x2F;回路：一条边多次出现</p><p>表示：$v_0e_0v_1\cdots v_{n-1}e_{n-1}v_n$</p><p>若u能到v，那么存在通路，那么必有≤n-1</p><p>若u存在简单回路，那么必有≤n</p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p>连通的：存在通路</p><p>连通图：平凡图&#x2F;任意两点都连通</p><p>连通分支：互相能到的一个部分，其R&#x3D;{&lt;x,y&gt;}为等价关系，即自反，对称，传递</p><p>p(G)：连通分支的数量，&#x3D;1时为连通图</p><p>短程线d(a,b)：最短路</p><p>距离：短程线长度</p><p>删除：G-V’或G-E’</p><p>点(边)割集：这些点(边)删除正好使连通分支增加</p><p>割点(边)(桥)：只有一个点(边)的点割集</p><p>完全图无点割集</p><p>0图都无</p><p>边割集最多增加1个，而点割集≥1</p><p>点(边)连通度κ(G)&#x2F;λ(G):最小的点(边)割集大小或者（或者让点数只剩1个）</p><p>平凡图，都0</p><p>完全图，点 n-1</p><p>κ≤λ≤δ</p><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>可达：a→b</p><p>相互可达：a→b，b→a</p><p>短程线d&lt;a,b&gt;</p><p>弱连通图：去掉方向为连通图</p><p>单向连通图：任意两个顶点一个可达另一个   存在经过每个点的一条通路</p><p>强联通：互相可达                                            存在经过每个点的一条回路</p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p>关联矩阵M(G)$_{n×m}$：点和边的关联次数</p><p>每列和2，每行和度，总和握手</p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>有向关联矩阵M(D)$_{n×m}$：始点1，终点-1</p><p>可算入度出度，列和0</p><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>有向邻接矩阵A(D)$_{n×n}$：i到j的边数</p><p>A$^l_{ij}$：i到j长度为l的通路数</p><p>B$^l_{ij}$：i到j长度≤l的通路数</p><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>有向可达矩阵P(D)$<em>{n×n}$：i能不能到j    iff B$^{n-1}</em>{ij}$&gt;0</p><p>无向图的可达和邻接类似</p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>二部图：将图中的顶点分为两个点集，任意一条边的两个端点各属于一个点集</p><p>完全二部图$K_{r,s}$：两个点集两两互联</p><p>两个点集被称为互补顶点子集</p><p>判定：无奇数长度回路</p><p>一般判定：直接分类标记</p><p>匹配：指二部图的一个子图，一个顶点的边数≤1</p><p>极大匹配：多一条边就不是匹配了</p><p>完备匹配：一个点集都配备了一条边</p><p>完美匹配：双方都完备匹配</p><p>hall定理(相异性条件)(充要)：v1中的任意k各顶点至少与v2中的任意k各顶点相邻</p><p>t条件(充分)：存在整数t，使v1中每个顶点的度≥t，且v2中每个顶点的度≤t</p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>欧拉通路：经过每条边&#x3D;1的通路</p><p>欧拉回路：是回路的欧拉通路</p><p>欧拉图：有欧拉回路</p><p>无向图判定条件：连通图且无奇度顶点</p><p>有向图判定条件：连通图且所有顶点入度&#x3D;出度</p><p>有向图欧拉通路非回路判定条件：连通图且有2个不满足，一个差值为1，一个为-1</p><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><p>哈密顿通路：经过每个点&#x3D;1的通路</p><p>哈密顿回路(必为初级)：是回路的哈密顿通路</p><p>哈密顿图：有哈密顿回路</p><p>删除v1个顶点，p≤v1</p><p>有割点的不是哈密顿图</p><p>因为是回路</p><p>(充分)：n≥3无向简单图，任意一对不相邻顶点度和≥n-1存在通路，≥n为哈密顿图</p><p>最小度≥$\frac{n}{2}$也是哈密顿图</p><p>n≥2有向图，略去方向存在K$_n$，则存在哈密顿通路</p><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><p>平面图仅讨论无向图</p><p>平面嵌入：画在平面上无交叉边</p><p>平面图：有平面嵌入的图</p><p>面R$_i$：平面图的一个区域</p><p>无限面：最外侧的无线区域</p><p>内部面：除无限面的其他面</p><p>边界：一个面的边界</p><p>次数deg(R$_i$)：边界的长度，即边界的边数</p><p>面的次数之和*2&#x3D;边数，即握手定理</p><p>极大平面图：加入一条边就不是平面图了</p><p>性质：连通且当n≥3时每个面的次数都为3</p><p>n-m+r&#x3D;k+1    k为连通分支数</p><p>若为连通平面图，且min次数≥l，则$m\le \frac{l}{l-2}(n-2)$</p><p>同胚：同构或反复插入或消去2度顶点后同构</p><p>收缩：重合两点，删除关联边，剩下保留</p><p>库拉图斯基定理(判定)：iff不含与k5或k33同胚的子图</p><pre><code class="hljs">                                   iff不含可收缩到k5或k33的子图</code></pre><p>对偶图：面作点，若有共边，则相连，经过这条边，为连通平面图</p><p>点面数互换，边数不变</p><p>对偶图vi的度&#x3D;ri的次数</p><p>点着色：对每个顶点涂色，要求相邻颜色不同</p><p>k-可着色的：能用k中颜色点着色</p><p>任何平面图都是4-可着色的</p><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><p>无向树(树)：连通不含回路的图</p><p>森林：每个连通分支都是树</p><p>平凡树：平凡图</p><p>树叶：d&#x3D;1</p><p>分支点：d≥2</p><p>非平凡树的叶子数≥2</p><p>不同度数列对应的树必不同构，但同度数列对应的树也可能不同构</p><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2"></a>1.2</h3><p>生成树：是树的生成子图</p><p>树枝：在生成树中的边</p><p>弦：非树枝</p><p>余树：弦的导出子图</p><p>无向连通图都存在生成树</p><p>权：边上的实数</p><p>带权图</p><p>kruskal(避圈法)</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>有向树：略去方向为树的有向图</p><p>根树：一个顶点入度&#x3D;0，其他入度&#x3D;1</p><p>树根</p><p>树叶</p><p>内点：除去树根和树叶的点</p><p>分支点：内点和树根</p><p>层数：树根到该点的通路长度，即树根为0层</p><p>树高：max层</p><p>根子树：其实就是子树</p><p>有序树：将每一层的顶点都规定次序</p><p>r元树：每个节点的孩子≤r</p><p>r元正则树：每个节点的孩子&#x3D;r</p><p>完全的：树叶的层数相同</p><p>最优二叉树(哈夫曼树)：选最小的合并</p><p>最佳前缀码：根据频率生成哈夫曼树</p><p>前中后遍历</p><p>周游&#x2F;行遍：每个顶点访问次数&#x3D;1</p><p>前缀表示法：从右到左每个运算符对后面紧挨的两个数运算</p><p>后缀：从左到右<del>对前面</del></p><h3 id="1-1-2"><a href="#1-1-2" class="headerlink" title="1.1"></a>1.1</h3><p>S上的二元运算：S运算S→S</p><p>封闭：S上的二元运算对S封闭</p><p>S上的一元运算：运算S→S</p><h3 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2"></a>1.2</h3><p>交换律</p><p>结合律</p><p>幂等律$x^2&#x3D;x$</p><p>分配律</p><p>吸收律：在交换律的基础上，x*(x+y)&#x3D;x且x+(x*y)&#x3D;x</p><p>代数常数：单位元，零元，可逆元，逆元</p><p>(左&#x2F;右)单位元：ex&#x3D;x</p><p>(左&#x2F;右)零元：θx&#x3D;θ</p><p>(左&#x2F;右)逆元：yx&#x3D;e</p><p>可逆：存在逆元</p><p>若存在左右单位元，则相等且为单位元</p><p>若存在左右逆元，则相等且为逆元</p><p>消去律</p><h3 id="2-1-1"><a href="#2-1-1" class="headerlink" title="2.1"></a>2.1</h3><p>代数系统(代数)V：非空集合S和其上的k个1&#x2F;2元运算，</p><p>&lt;S,f1,f2,…&gt;一般二元运算写在前，S被称为载体，还可写上代数常数</p><h3 id="2-2-1"><a href="#2-2-1" class="headerlink" title="2.2"></a>2.2</h3><p>同类型的代数系统：运算个数，对应的元数，代数常数个数都相同</p><p>同种的代数系统：对应运算性质相同的同类型的代数系统</p><h3 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2.3"></a>2.3</h3><p>(真)子代数(同种)：S中的一个(真)子集S‘，对所有运算封闭且代数常数相同</p><p>平凡子代数：V自身，其代数常数若封闭则为最小平凡子代数</p><p>积代数：两个同类型代数系统&lt;A,+&gt;,&lt;B,*&gt;，&lt;a1,b1&gt;- &lt;a2,b2&gt;&#x3D;&lt;a1+a2,b1*b2&gt;，则&lt;A×B,-&gt;为两代数系统的积代数，反之两者为其因子代数</p><p>特性：同类型，保留除消去律以外的所有运算性质，且保留代数常数</p><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><p>同态映射(同态)：f:V1→V2(同类型)，f(x+y)&#x3D;f(x)*f(y)</p><p>单同态：单射</p><p>满同态(同态像)：满射</p><p>同构≌：双射</p><p>自同态：到自身的同态</p><p>零同态：f(x)&#x3D;0x，x∈Z</p><p>同态：能够保留除消去律以外的大多性质和代数常数</p><p>同构：拥有完全相同的性质，被认为是同一代数系统</p><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1"></a>3.1</h3><p>半群：&lt;S,+&gt;，+可结合</p><p>含幺半群(独异点)：有单位元的半群</p><p>若可结合，$x^0&#x3D;e$</p><p>子半群，子独异点(要求e要保留)</p><p>独异点的同态要求$f(e_1)&#x3D;e_2$</p><h3 id="3-2-1"><a href="#3-2-1" class="headerlink" title="3.2"></a>3.2</h3><p>群：每个元素都有逆元的独异点</p><p>有限群：有限元素群</p><p>无限群：无限元素群</p><p>阶|G|：元素的个数</p><p>平凡群：只有单位元</p><p>交换群(阿贝尔群)：二元运算还是可交换的群</p><p>有负次方：即(-1)*n</p><p>元素的阶|a|：$min\ k,a^k&#x3D;e$</p><p>无限阶元：不存在阶</p><p>像矩阵一样,$(a_1\cdots a_n)^{-1}&#x3D;a_n^{-1}\cdots a_1^{-1}$</p><p>ax&#x3D;b和ya&#x3D;b都有唯一解，$a^{-1}b和ba^{-1}$</p><p>群可以使用消去律</p><p>iff k是阶的整数倍的时候时$a^k&#x3D;e$</p><p>逆元的阶相同</p><p>$|b^{-1}ab|&#x3D;|a|$</p><p>$|ab|&#x3D;|ba|$</p><p>(真)子群</p><p>平凡子群：G和{e}</p><p>判定定理1：ab∈G且$a^{-1}$∈G</p><p>判定定理2：ab$^{-1}$∈G</p><p>由a生成的子群：{a$^k|k是整数$}</p><p>群的中心：{a|对任意x，ax&#x3D;xa}</p><p>交换群的中心就是自身</p><p>子群格</p><p>零同态：G1→G2,$f(x)&#x3D;e_2$</p><p>内自同构：G→G,$f(x)&#x3D;axa^{-1}$</p><p>循环群<a></p><p>a为生成元</p><p>无限循环群，只有两个生成元，生成元和它的逆元</p><p>n阶循环群，与n互质的a^k</p><p>n元置换σ(i)</p><p><img src="/image/%E7%A6%BB%E6%95%A3Untitled.png" alt="Untitled"></p><p><img src="/image/%E7%A6%BB%E6%95%A3Untitled%201.png" alt="Untitled"></p><p><img src="/image/%E7%A6%BB%E6%95%A3Untitled%202.png" alt="Untitled"></p><p><img src="/image/%E7%A6%BB%E6%95%A3Untitled%203.png" alt="Untitled"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数学建模 </title>
    <link href="/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>问题假设（要全面）  </li><li>模型建立</li><li>模型求解</li><li>模型评价</li></ol><h3 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h3><ol><li><p>预测类</p><p> 用以往的数据来预测将来的数据</p></li><li><p>评价类</p><p> 通过建立评价指标体系来评价一个东西</p></li><li><p>机理分析</p></li><li><p>优化类</p><p> 最优化理论，目标函数，变量，约束</p></li></ol><h3 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h3><table><thead><tr><th>[]</th><th>矩阵，其中的数值可以是矩阵</th></tr></thead><tbody><tr><td>；</td><td>换行</td></tr><tr><td>，或者直接空格</td><td>分列</td></tr><tr><td>while condition</td><td></td></tr><tr><td>end</td><td>循环</td></tr><tr><td>if condition</td><td></td></tr><tr><td>end</td><td>条件</td></tr><tr><td>diag(行向量)</td><td>对角阵</td></tr><tr><td>zeros(x,y)</td><td>x行y列的0矩阵</td></tr><tr><td>ones(x,y)</td><td>同上</td></tr><tr><td>rand(x,y)</td><td>同上，不过数据是随机的</td></tr><tr><td>eye(x)</td><td>大小为x的单位矩阵</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>plot(x,y,点的图案样式)</td><td>画点</td></tr><tr><td>%</td><td>注释</td></tr><tr><td>，</td><td>，</td></tr><tr><td>function 返回值(如果是多个，则用一个矩阵返回)&#x3D;函数名(参数)</td><td>函数</td></tr><tr><td>&amp;&amp;</td><td></td></tr><tr><td>Inf</td><td>无穷大</td></tr><tr><td>pi,sin,cos</td><td></td></tr><tr><td>矩阵(m,n)</td><td>矩阵中的第m行n列的那个元素</td></tr><tr><td>矩阵(m:n,m1:n1)</td><td>矩阵中m行到n行其m1到n1列的元素，:前后可省略</td></tr><tr><td>find(矩阵判断条件)</td><td>对矩阵中的每一个元素进行这个判断条件，返回满足条件的元素的位置</td></tr><tr><td>isempty</td><td></td></tr><tr><td>nargin</td><td>函数的输入参数数量</td></tr><tr><td>disp(变量&#x2F;常量)</td><td>输出</td></tr><tr><td>size(矩阵)</td><td>返回一个1*2的矩阵，代表其行与列的阶数</td></tr><tr><td>eig(矩阵)</td><td>返回一个1*2的矩阵，第一个为特征向量的矩阵，第二个为特征值的矩阵，是对角阵，顺序一致</td></tr><tr><td>clc,clear</td><td>清空</td></tr><tr><td>repeat(矩阵,n,m)</td><td>将矩阵复制n行m列，返回一个矩阵</td></tr><tr><td>min&#x2F;max(矩阵)</td><td>找矩阵中最小&#x2F;大的</td></tr><tr><td>norm(矩阵)</td><td>平方和的根号，不知道是不是限制一行或一列</td></tr><tr><td>sort(矩阵,’descend’&#x2F;’ascend’)</td><td>返回一个1*2的矩阵，第一个为排好序的矩阵，第二个是排好序的原来的序号</td></tr><tr><td>cumsum(矩阵)</td><td>对矩阵的行一次累加</td></tr><tr><td>mean(矩阵，参数）</td><td>求平均，当参数为2时为每行求平均</td></tr><tr><td>figure</td><td>创建一个新的视图</td></tr></tbody></table><h3 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a>数学概念</h3><p>剩余变量：通过引入一个变量来将不等式约束转为等式约束，如$x_1+x_2\le10，则x_1+x_2+x_3&#x3D;10，x3\ge0$。</p><h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><p>目标函数是变量的线性表达式，变量有线性约束，使目标函数最优化。</p><p>线性规划标准式：</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled.png" alt="Untitled"></p><p>下面三个全是约束条件。A，Aeq都是矩阵，而剩下的全是列向量，当某一部分不存在约束的时候直接取空向量或者空矩阵即可。</p><p>求解命令：</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%201.png" alt="Untitled"></p><p>若要求最大值或者大于等于时通过取负来解决。</p><p><strong>转换</strong></p><ol><li><p>有时候式子并不是直接的线性表达式，此时可以通过转化来操作。</p><p> 如绝对值相加可以设$x_i&#x3D;u_i-v_i,\ |x_i|&#x3D;u_i+v_i$。</p></li><li><p>将多目标规划转化为线性规划，如将目标转换为约束（即枚举约束情况来看总体的变化来找总体的最优）或将多目标转换为单目标</p></li></ol><h3 id="linprog"><a href="#linprog" class="headerlink" title="linprog"></a>linprog</h3><p>实际上linprog还会返回第三个值，若为负，则表示不存在可行解。</p><p>linprog还可以传入一个参数，option来控制其迭代设置（linprog求解过程是一个迭代过程）。</p><p>option是一个optimset返回对象。</p><p>optimset(oldoption(可省略),’param1’,value1,’param2’,…..)。将oldoption中对应的param设置值。</p><table><thead><tr><th>Display</th><th>off不显示输出。iter每次迭代显示结果。final值显示最终结果。notify只在函数不收敛的时候显示结果</th></tr></thead><tbody><tr><td>MaxFunEvals</td><td>函数中求值运算的最高次数。(一次迭代可能多次求值？)</td></tr><tr><td>MaxIter</td><td>最大迭代次数</td></tr><tr><td>TolFun</td><td>函数迭代的终止误差</td></tr><tr><td>TolX</td><td>结束迭代的X值？</td></tr></tbody></table><h3 id="整数规划（可以直接使用intlinprog-第二个参数表示第几个x为整数）"><a href="#整数规划（可以直接使用intlinprog-第二个参数表示第几个x为整数）" class="headerlink" title="整数规划（可以直接使用intlinprog,第二个参数表示第几个x为整数）"></a>整数规划（可以直接使用intlinprog,第二个参数表示第几个x为整数）</h3><p>intlinprog好像在2014版的matlab就推出了。</p><p>当线性规划中的变量中部分（混合）或者全部（纯）被限制为整数时。</p><p>整数规划对应的线性规划被称为松弛规划。</p><ol><li><p>暴力所有可行整数解（当可行解较少时）</p></li><li><p>分支定界法（已实现）</p><p> 对于求出来的松弛规划的解，选择第一个非整数变量，通过增加其向上取整或向下取整的约束条件来缩小可行域，对于新算出来的解，同样选择第一个非整数变量（递归），直到所有解都是整数，以求出可行整数解。如对于求出来$x1&#x3D;2.3,则可添加x_1\le2或者x_1\ge3来$约束。如果求不出整数解，则换方法。</p><p> 实际上就是找边界周围的整数解进行暴力，并不断依此来缩小边界。</p></li><li><p>割平面法（好愚蠢的算法，感觉劣与分支定界法）</p><p> 只适用于存在不等式约束的时候？</p><p> 基本思想：将没有整数可行解的平面切掉</p><p> 原理：通过将不等式约束引入松弛变量化为等式约束，后通过将小数部分与整数部分分离，得出对于某一个$x_i$的切割约束条件。</p><p> 最后一步的右式由于$f_i&lt;1&amp;&amp;\sum[f_{ik}]x_k&gt;0,则右式\le0$。得出$x_i$的约束。</p><p> <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%202.png" alt="Untitled"></p><ol><li><p>匈牙利算法（用于0-1整数规划）</p><p> 除去普通的人员分配问题（通过等式约束）（对于非标准的指派问题通过增加虚拟人或物及设定代价为无穷大来处理），还可以处理约束冲突问题（即当有两个约束是二选一的时候），此时可以引入一个新的0-1变量，表示使用哪一个约束条件，通过在约束右侧增加一个yM和(1-y)M，M是一个大数，来使得其在一个约束条件不起作用的时候另一个约束条件起作用。</p><p> $$<br> A_1x\le b_1+(1-y)M\A_2x\le b_2+yM<br> $$</p><p> 这一点可以推广，对于p个约束条件中选取q个约束条件。</p><p> $$<br> A_ix\le b_i+My_i\\sum y_i&#x3D;p-q<br> $$</p><p> 基本原理：应该是贪心</p><p> 实现代码：复杂的一逼，傻逼匈牙利人（c++写完第二步就已经快100行了艹）</p><p> 实际实现代码：普通的进行约束进行普通的线性规划就可以了（好像并没有限定必须是整数，但是可能这样求出来的必然是整数吧？当然也可以直接使用intlinprog更保险）</p></li></ol></li></ol><h3 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h3><p>目标函数与约束条件中包含非线性函数。</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%203.png" alt="Untitled"></p><p>$c(x)与ceq(x)$是非线性函数的不等式约束与等式约束。$f(x)$可能是线性的也可能是非线性的。</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%204.png" alt="Untitled"></p><p>fun是一个字符串，为一个function的名字。这个function输入参数是x列向量，返回值是fv。</p><p>nonlcon也是一样是一个字符串，为一个function的名字。这个function返回的是[g,h]，g是不等式约束，h是等式约束。g与h都是矩阵，也就是说，当有多个不等式或等式约束的时候，g与h可能都是多行的。</p><p>例：</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%205.png" alt="Untitled"></p><p>x0是x的初值，这个rand就好了。</p><h3 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h3><p>目标函数为二次，但约束都是线性，H是一个实对称矩阵。在输入H的时候要注意前面的0.5系数。</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%206.png" alt="Untitled"></p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%207.png" alt="Untitled"></p><h3 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h3><p>将多目标转化为单目标</p><ol><li>目标转约束</li><li>加权相加</li><li>分层序列法（求出一个的最优质值，然后在这个最优质值的限定下求下一个，往复）</li><li>让最糟糕的目标最不糟糕</li></ol><p>goal就是在分别不管其他目标下的最优值，一个列向量。weight各个目标的权重。fun是列向量，表示目标函数。</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%208.png" alt="Untitled"></p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%209.png" alt="Untitled"></p><h3 id="层次分析法-主观赋权"><a href="#层次分析法-主观赋权" class="headerlink" title="层次分析法 (主观赋权)"></a>层次分析法 (主观赋权)</h3><p>一个选择有多个因素决定，但因素之间的重要程度难以比较。</p><p>层次分析法通过两两比较的方式来确定因素之间的相对重要性。</p><p>主要用于选择与评判标准的制定上。</p><p>具体过程：</p><ol><li><p>建立层次分析模型</p><p> 分为三层：目标层（要解决的问题），准则层（决定方案好坏的要素），方案层（所有可能的解决方案）</p></li><li><p>构造判断矩阵</p><p> 即因素两两之间的重要程度的相对比较，1-9表示从一样重要，到一个因素比另一个因素极端重要。而其在矩阵对称位置的元素与本元素相乘为1，也就是说所有元素的范围都在$\frac{1}{9}$-9。</p><p> 若是矩阵表示的这些相对关系连乘的结果与矩阵中的结果一致，则该矩阵为一致阵（有着如行列式等于1神奇的性质）。层次分析法允许不一致阵。</p></li><li><p>层次单排序及一致性检验</p><p> 假设判断矩阵为n阶方阵，λ为判断矩阵的最大特征值，我们以λ-n的大小来衡量判断矩阵的不一致程度。</p><p> 一致性指标：$CI&#x3D;\frac{\lambda-n}{n-1}$。越小越一致。</p><p> RI为随机一致性指标（可查）。</p><p> 当$CR&#x3D;\frac{CI}{RI}&lt;0.1$时，则通过一致性检验。</p><p> 特征值所对应特征向量的每个数字代表该因素对总体的重要程度。</p><p> 但实际计算非常麻烦，可以通过一些方法来简化计算，得出一个不是那么精确的值。</p><p> 将判断矩阵的每一列列向量归一化（使这一列加起来为1），将归一化后的矩阵行元素相加，得到和列向量，将此作为特征向量，进行计算得λ。</p></li><li><p>层次总排序及一致性检验</p><p> 将方案层对于每一个准则层的因素求一次单循环，假设第j个因素得出的$CI_j$，这每一个单循环的出来的CI都需要检验，而第三步得出的特征向量为$a_i$，也就是第i个因素的重要程度，得出总排序的CR。</p><p> $$<br> CR&#x3D;\frac{\sum a_iCI_i}{\sum a_iRI_i}<br> $$</p><p> 这一总排序的一致性比率也需要通过检验。</p></li></ol><p>而最终第k个方案的最终权重为$\sum a_iw_{ik}$，$w_{ik}$代表对于第i个因素第k个方案的权重，也就是对第i个因素求出的特征向量的第k个值。</p><p>实现上，很简单。也可以直接使用它给的AHP”软件”。</p><p>如果提供的数据不需要两两比较就存在一个整体的顺序，那么直接构建一个一致阵就可以了。</p><p><strong>优点</strong></p><ol><li>系统性。把所研究的问题看成一个系统，按照分解、比较判断、综合分析的思维方式进行决策分析，也是实际中继机理分析方法、统计分析方法之后发展起来的又一个重要的系统分析工具。</li><li>实用性。把定性与定量方法结合起来，能处理许多传统的优化方法无法处理的实际问题，应用范围广，而且将决策者和决策分析者联系起来，体现了决策者的主观意见，决策者可以直接应用它进行决策分析，增加了决策的有效性和实用性。</li><li>简洁性。具有中等文化程度的人都可以学习掌握层次分析法的基本原理和步骤，计算也比较简便，所得结果简单明确，容易被决策者了解和掌握。</li></ol><p><strong>局限性</strong></p><p>局限性是粗略、主观。首先是它的比较、判断及结果都是粗糙的，不适于精度要求很高的问题。</p><p>其次是从建立层次结构图到给出两两比较矩阵，人的主观因素作用很大，使决策结果较大程度地依赖于决策人的主观意志，可能难以为众人所接受。</p><h3 id="TOPSIS-理想解法-客观赋权"><a href="#TOPSIS-理想解法-客观赋权" class="headerlink" title="TOPSIS (理想解法) (客观赋权)"></a>TOPSIS (理想解法) (客观赋权)</h3><p>将数据标准化并得出最优点（每一个因素都取最优）与最劣点，并计算数据点与其的距离来判断优劣。</p><p>过程：</p><ol><li>数据标准化</li><li>将数据根据因素权重进行加权，也就是乘上因素权重</li><li>确定两点</li><li>计算距离（$s_优和s_劣$），以欧式距离作为距离</li><li>计算各个数据的综合评价指数，$f_i&#x3D;\frac{s_优}{s_劣+s_优}$</li></ol><p>数据标准化总共要处理三个问题：</p><ol><li>将效益型（越大越好），成本型（越小越好）与区间型统一。</li><li>去量纲</li><li>归一化（将所有数据变换到[0,1]上）</li></ol><p>标准化的方法总共有5种：</p><ol><li>线性 (不常用) ：$a^{‘}&#x3D;\frac{a}{a_{max}}$</li><li>标准0-1变换：$a^{‘}&#x3D;\frac{a-a_{min}}{a_{max}-a_{min}}$</li><li>区间型变换：分段函数，区间前与区间后各以成本型与效益型来处理，最终会分为五段，形状像梯形。</li><li>向量规范化 (topsis中常用) ：</li></ol><p>$$<br>a^{‘}&#x3D;\frac{a}{\sqrt{\sum a_i^2}}<br>$$</p><ol><li>标准化处理 (常用) ：</li></ol><p>$$<br>a^{‘}&#x3D;\frac{a-\overline{a}}{s_j}\ \ \ \ s_j&#x3D;\sqrt{\frac{\sum (a_i-\overline{a})^2}{m-1}}<br>$$</p><p>可以直接使用zscore(矩阵)。</p><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><p>将相似的分为一类，相似指的是关键值的差值很小。</p><ul><li><p>R型分类</p><p>  对指标进行分类，通过了解指标的相似程度，来一定程度上省略一些指标</p></li><li><p>Q型分类</p><p>  对样本进行分类，比传统的分类方法更细致，全面，合理</p></li></ul><ol><li><p>样本之间的距离度量</p><p> 欧式距离，$\sqrt{\sum(x_{ik}-x_{jk})^2}$，pdist(x)，x是矩阵。</p><p> 绝对距离，$\sum|x_{ik}-x_{jk}|$,pdist(x,’cityblock’)</p><p> 明式距离，$^m\sqrt{\sum(x_{ik}-x_{jk})^m}$，pdist(x,’minkowski’,m)。</p><p> 切式距离，$max|x_{ik}-x_{jk}|$</p><p> 方差加权距离，$\sqrt{\sum\frac{(x_{ik}-x_{jk})^2}{s_k^2}}$</p><p> 马氏距离，pdist(x,’mahal’)</p></li></ol><p>pdist返回的是一个行向量，要通过squareform(行向量)来获得实对称矩阵</p><p>并可以通过tril(矩阵)来获得上三角矩阵</p><ol><li><p>变量之间的相似度量——相似系数</p><p> 用余弦或者相关系数。</p><p> 余弦：也就是点乘除上两个向量的长度。</p><p> 先用normc(矩阵)将矩阵单位向量话，最后a’*a即可得到余弦。</p><p> 相关系数：向量变为从向量的平均向量指向这个向量，也就是所有的x_i减去x均。</p><p> corrcoef(矩阵)可直接求得相关系数。</p></li><li><p>类间距离，代表两个聚类之间的距离</p><p> 最长距离，最短距离，平均距离，重心距离</p></li><li><p>聚类方法</p><ul><li>谱系聚类法</li></ul><p> 计算得到距离矩阵。</p><p> 设定类间距离大小。</p><p> 所有的点一开始都是一个类。若两个类的类间距离小于设定的，那么就合并。</p><p> 通过linkage(距离矩阵,’类间距离定义’)</p><table><thead><tr><th>最短</th><th>空</th></tr></thead><tbody><tr><td>最长</td><td>complete</td></tr><tr><td>中间</td><td>centroid</td></tr><tr><td>重心</td><td>average</td></tr><tr><td>离差平方和</td><td>ward</td></tr></tbody></table><p> 其linkage将会做到直到只剩一个类。可以通过dendrogram(矩阵)来将linkage的过程可视化，linkage返回值作为输入。并可以通过cluster(矩阵，聚类几次）来输出聚类步骤。</p><ul><li>k-means</li></ul><p> 一开始定下聚类的个数。并随机这么多个数的随机聚类中心。</p><p> 将每一个点归类，并以这些归类的点计算出新的聚类中心。重复操作。</p><p> 可以直接使用kmeans(矩阵,个数)。</p></li></ol><h3 id="灰色关联分析（评价）"><a href="#灰色关联分析（评价）" class="headerlink" title="灰色关联分析（评价）"></a>灰色关联分析（评价）</h3><p>认为所有指标是等权重的。</p><p>对于一个选择，先量纲化处理所有方案的数据。</p><p>接着得出参考数列（一般取最优即可）</p><p>计算相差矩阵，也就是每一个元素改为其与最优值的差值的绝对值。</p><p>接着得出相差矩阵的元素最小值Xmin和元素最大值Xmax。</p><p>最终每一个选项在每一个指标的得分计算为$\frac{Xmin+p<em>Xmax}{Xnow+p</em>Xmax}$，p为分辨系数，一般取0.5。Xnow就是这个相差矩阵的这位元素的值。</p><p>最终将所有指标得分平均即为这个选项的得分。</p><p>如相差矩阵为</p><table><thead><tr><th>1</th><th>1</th></tr></thead><tbody><tr><td>2</td><td>0</td></tr></tbody></table><p>则Xmin为0，Xmax为2。</p><p>则为$\frac{0+2<em>0.5}{1+2</em>0.5}$。1为该位置元素的值。</p><h3 id="灰色预测模型（预测）"><a href="#灰色预测模型（预测）" class="headerlink" title="灰色预测模型（预测）"></a>灰色预测模型（预测）</h3><p>基本思想：现实数据存在随机性，通过累加、累减、加权累加等方式来消除随机性找到规律进行预测</p><p>步骤：</p><ol><li><p>进行检验与处理</p><p> 要使用灰色预测模型，必须首先经过级比检验</p><p> $$<br> 设原数据为x^{(0)}(i),i\le n,需保证\lambda(k)&#x3D;\frac{x^{(0)}(k-1)}{x^{(0)}(k)}\in(e^{\frac{-2}{n+1}},e^{\frac{2}{n+1}})对k\ge 2恒<br> $$</p><p> 若不符合，可以通过使$x^{(0)}(i)’&#x3D;x^{(0)}(i)+c$平移操作来使符合，但不要忘记预测时要逆操作。</p></li><li><p>建立GM(1,1)模型</p><p> $$<br> 灰微分方程为\ :\ x^{(0)}(k)+az^{(1)}(k)&#x3D;b<br> $$</p><p> $$<br> 其中x^{(1)}邻值生成数列z^{(1)}(k)&#x3D;ax^{(1)}(k)+(1-a)x^{(1)}(k-1),a一般取0.5<br> $$</p><p> $$<br> 其中一次累加生成数列x^{(1)}(k)&#x3D;\sum^k_{i&#x3D;1}x^{(0)}(i)<br> $$</p><p> $$<br> 设u&#x3D;\begin{bmatrix}a\b\end{bmatrix}&#x3D;(B^TB)^{-1}B^TY,其中B矩阵为\begin{bmatrix}-z^{(1)}(i)&amp;1\end{bmatrix}\Y矩阵为\begin{bmatrix}x^{(0)}(i)\end{bmatrix},i\ge2\<br> $$</p><p> $$<br> 解得后x^{(1)}(k+1)&#x3D;(x^{(0)}(1)-\frac{b}{a})e^{-ak}+\frac{b}{a}\预测值x^{(0)}(k+1)&#x3D;x^{(1)}(k+1)-x^{(1)}(k)<br> $$</p><ol><li><p>进行检验正确性</p><p> a. 残差检验</p><p> $$<br> \varepsilon(k)&#x3D;\frac{x^{(0)}(k)-x_预^{(0)}(k)}{x^{(0)}(k)}<br> $$</p><p> 若所有$|\varepsilon(k)|&lt;0.1$，这达到较高的要求。若所有$|\varepsilon(k)|&lt;0.2$，这达到一般要求。</p><p> b. 级比偏差值检验</p><p> $$<br> \rho(k)&#x3D;1-\frac{1-0.5a}{1+0.5a}\lambda(k),此处\lambda(k)为前面第一步中的,a一般取0.5<br> $$</p><p> 若所有$|\rho(k)|&lt;0.1$，这达到较高的要求。若所有$|\rho(k)|&lt;0.2$，这达到一般要求。</p><p> 二者中达成一个即可。</p></li></ol></li></ol><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>即便没有需要预处理的，也需要进行说明。</p><p>总共四种。</p><ol><li><p>数据清洗</p><ol><li><p>异常值</p><p> 一般直接视为缺失值或者用前后的两个数据平均作为数据</p><p> 重点在于如何判断是否是异常值。</p><ol><li><p>将正态分布中＞3σ的作为异常值</p></li><li><p>箱线图。假设Q1是第25%的数据的值，Q3为第75%的值，IQR&#x3D;Q3-Q1，将&gt;Q3+1.5IQR和&lt;Q1-1.5IQR的视为异常值</p><p> 使用boxplot绘制箱线图，用法boxplot(矩阵)，会为每一列绘制一个</p></li><li><p>通过散点图肉眼观察</p><p> 如果不用肉眼的话，可以设定一个特定的距离。如果对于某个点来说有超过n个点与它的距离大于这个设定的距离，那么这个点就是散点。距离和n都是要人为主观设定的。</p></li></ol></li><li><p>缺失值</p><ol><li>直接删除这一组数据</li><li>不处理，作为一种特别的数据</li><li>数据插补</li></ol><p> 其中，插补的方法有多种。</p><ol><li><p>直接将其取为均值，中位数，或众数</p></li><li><p>直接将其取为固定值</p></li><li><p>回归邻插补，找到“距离”最小的另一个数据点，直接用它的这一个数据</p></li><li><p>回归方法，通过其他的正常数据拟合模型来预测</p></li><li><p>插值法，使用合适的插值函数，依靠拉格朗日插值法或牛顿插值法</p><p> 实现方法：</p><p> ployinterp_column(有空缺的矩阵，’lagrange’或’newton’)返回一个插值完的矩阵</p><p> 这是由它写的函数实现的，matlab本身并没有直接的方法</p><p> python中倒是在scipy库中有可以直接使用的函数。</p><p> 可能不一定是下面这样用的？(chat写的）</p><p> <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2010.png" alt="Untitled"></p></li></ol></li></ol></li><li><p>数据集成</p><p> 将多个数据库的数据集成为一个统一的数据库</p></li><li><p>数据消减</p><p> 在很多情况下，有一些数据是完全与结果无关的或者与另一个因素是有非常强的关联的时候可以将这一部分数据给去除，减少数据量，提高效率，而不降低正确性</p><ol><li>研究特征之间的关系</li><li>暴力枚举选取因素，选取预测最好的</li></ol><p> 两个因素的相关性可以用斜方差来表示</p><p> $$<br> cov(x,y)&#x3D;\frac{\sum^n_{i&#x3D;1}(x_i-\overline{x})(y_i-\overline{y})}{n-1}<br> $$</p><p> 可以通过这个来生成一个斜方差矩阵，再通过主成分分析法来降维。</p><p> 可通过corrcoef(矩阵)，返回斜方差矩阵</p><p> 并通过pcacov(斜方差矩阵）进行主成分分析法，返回[矩阵,~,矩阵]，第一个矩阵代表主成分分析法新造出的几个主成分的原因素系数，最后一个矩阵代表每一个成分的贡献度，只需要从前往后进行累加，当累计贡献率＞85%时，剩下的就都可以被抛弃了。</p><p> 当我们得出几个新的因素由原因素线性表示的时候，我们不仅要写出表达式，也需要对此进行实际意义上的阐释。 </p></li><li><p>数据变换</p><ol><li><p>归一化</p><p> 保证量纲一致</p></li><li><p>函数变换</p><p> 当存在偏态分布而非正态分布时，可以通过指数函数与对数函数分别将左偏与右偏数据调整为正态分布，这样能够当我们用某几个指标衡量的时候得出的结果会相同，或者可以使用某些对数据要求很严格的检验</p></li></ol></li></ol><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ol><li><p>拉格朗日插值法</p><p> 对于n个$(x_i,y_i)$的点，我可以生成n个$f_i(x)$使得它在$x_i$的值为1，而其他的x点上都为0。</p><p> 此时$f(x)&#x3D;\sum_{i&#x3D;1}^ny_if_i(x)$必然会经过所有点。</p><p> 而$f_i(x)&#x3D;\prod_{j&#x3D;1}^n\frac{x-x_j}{x_i-x_j}$。</p><p> 用的较少好像</p></li><li><p>Runge现象</p><p> 当多项式的次数变高，插值函数的边缘处会出现非常大的震荡，因此一般不建议次数超过7。</p><p> 这可以通过分段插值来解决，也就是很多个点几个连续的分为一段，对他们分别进行低次插值。</p><p> 因为我们想进行的仅仅是插值而非拟合，所以不用管分段对于整体的问题。</p></li><li><p>一维插值</p><p> interp1(x,y,x_i,’method’)，x_i可以是一个矩阵，返回的y_i大小与x_i相同</p><p> method有</p><table><thead><tr><th>nearest</th><th>最邻近插值</th><th></th></tr></thead><tbody><tr><td>linear</td><td>线性插值</td><td></td></tr><tr><td>spline</td><td>三次样条插值</td><td>一维用，看起来是最好的</td></tr><tr><td>cubic</td><td>立方插值</td><td>二维用</td></tr></tbody></table></li><li><p>二维插值</p><p> interp2(x,y,z,x_i,y_i,’method’)</p><p> method与一维的一致，只不过linear和cubic的中文名都加上一个双</p></li><li><p>散点插值</p><p> 上述的都是已有的数据点都是大量的，但常常有那种只有零星几个点的，此时就应该用散点插值</p><p> griddata(x,y,z,x_i,y_i,’method’)，其他与二维插值差不多</p></li></ol><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><ol><li><p>一元线性回归</p><ol><li><p>求出方程的系数</p><p> 设预测值为$y’$，则将$\sum(y-y’)^2$作为评估误差大小，将$y&#x3D;\beta_0+\beta_1x$代入，会得到一个关于$\beta_0$和$\beta_1$的二次函数，通过导数求其最小值，得</p><p> $$<br> \begin{cases}\beta_0&#x3D;\overline{y}-\beta_1\overline{x}\ \beta_1&#x3D;\frac{\sum (x_i-\overline{x})(y_i-\overline{y})}{\sum (x_i-\overline{x})^2}\end{cases}<br> $$</p></li><li><p>对求出的系数进行假设检验，$1-\alpha$为置信度，$\alpha$一般取0.05。</p><ol><li><p>F检验法</p><p> $$<br> F&#x3D;\frac{U(n-2)}{Q_e},Q_e&#x3D;\sum (y_i-y_i’)^2,U&#x3D;\sum(y_i’-\overline{y})^2<br> $$</p><p> 此处的$\overline{y}$应该是原y的平均值。</p><p> 当$F&gt;F_{1-\alpha}(1,n-2)$时，则方程通过检验。后面的值可依靠查表得。</p></li><li><p>t检验法</p><p> $$<br> T&#x3D;\frac{\sqrt{L_{xx}}\beta_1}{\sigma_e},L_{xx}&#x3D;\sum(x_i-\overline{x})^2,\sigma_e^2&#x3D;\frac{Q_e}{n-2}<br> $$</p><p> 其中$\overline{x}$也应该是原x的平均值。</p><p> 当$|T|&gt;t_{1-\frac{\alpha}{2}}(n-2)$时，则方程通过检验。后面的值可依靠查表得。</p></li><li><p>r检测法 ?为什么公式里一个预测值都没出现</p><p> $$<br> r&#x3D;\frac{\sum(x_i-\overline{x})(y_i-\overline{y})}{\sqrt{\sum(x_i-\overline{x})^2\sum(y_i-\overline{y})^2}}<br> $$</p><p> 当$|r|&gt;r_{1-\alpha}$时，则方程通过检验。后面的值可依靠查表得。</p></li></ol><p> 算出来的$\beta_0$和$\beta_1$也是有一个不确定度的。</p><p> $$<br> \beta_0&#x3D;\beta_0\pm t_{1-\frac{\alpha}{2}}(n-2)\sigma_e\sqrt{\frac{1}{n}+\frac{\overline{x}^2}{L_{xx}}}<br> $$ </p></li><li><p>对x0做预测或对y做区间估计</p><ol><li><p>预测</p><p> 预测得的$y’$也有一个不确定度。</p><p> $$<br> y’&#x3D;y’\pm\delta(x_0),\delta(x_0)&#x3D;\sigma_et_{1-\frac{\alpha}{2}}(n-2)\sqrt{1+\frac{1}{n}+\frac{(x_0-\overline{x})^2}{L_{xx}}}<br> $$</p></li><li><p>区间估计</p><p> 当我们希望y有$1-\alpha$的概率落在$(y’,y’’)$上时。</p><p> 假设最终的区间为$(x’,x’’)$。</p><p> 其分别为$y-\delta(x)&#x3D;y’和y+\delta(x)&#x3D;y’’$的解。</p></li></ol></li></ol></li><li><p>可化为一元线性回归的非线性回归</p><ul><li><p>非线性回归的实现</p><p>  [beta,r,J]&#x3D;nlinfit(x,y,’model’,beta0)</p><p>  或者nlinttool(x,y,’model’,beta0,alpha)</p><p>  r为残差。</p><p>  J为雅可比矩阵。</p><p>  model是一个定义的函数。</p><p>  beta0为系数初值，随意设即可。</p><p>  预测使用[y,$\delta$]&#x3D;nlpredci(’model’,x,beta,r,J)</p></li></ul><p> 通过$\begin{cases}v&#x3D;v(y)\u&#x3D;u(x)\end{cases}$，使得u与v是线性相关的，找到u和v的关系后通过逆函数再还原为y和x即可。</p><p> 常用的非线性函数。</p><p> $$<br> y&#x3D;a+\frac{b}{x},\frac{1}{y}&#x3D;a+\frac{b}{x},y&#x3D;ax^b,y&#x3D;ae^{bx}\y&#x3D;ae^{b&#x2F;x},y&#x3D;a+blnx,S型\ y&#x3D;\frac{1}{a+be^{-x}}<br> $$ </p></li><li><p>多元线性回归</p><ol><li><p>计算</p><p> $$<br> Y&#x3D;X\beta,Y&#x3D;\begin{bmatrix}y_i\end{bmatrix},X&#x3D;\begin{bmatrix}1\ x_{i1}\ x_{i2}\ \dots\ x_{ik}\end{bmatrix},\beta&#x3D;\begin{bmatrix}\beta_{0,1,\dots,k}\end{bmatrix}<br> $$</p><p> $$<br> 通过最小二乘解得,\beta&#x3D;(X^TX)^{-1}(X^{-1}Y)<br> $$</p><p> 当碰到多项式回归时，只需要使$x_i&#x3D;x^i$即可，化为多元线性回归。</p><ul><li><p>对于多项式回归的实现</p><p>  [p,S]&#x3D;polyfit(x,y,m),m为最高次次数。</p><p>  $p&#x3D;(a_1,a_2,\dots,a_{m+1}),a_i为x^{m-i+1}的系数。$</p><p>  通过y&#x3D;polyval(p,x)来进行预测。</p><p>  通过[y,$\delta$]&#x3D;polyconf(p,x,S,alpha)。</p><p>  得到其在x处的预测值及估计区间。</p></li><li><p>多元二项式回归</p><p>  或者直接将其转化为多元线性</p><p>  rstool(x,y,’model’,alpha)</p><p>  窗口左边会显示y与置信区间</p><p>  最后将结果export出来，会获得beta和rmse，只要rmse&lt;10就不错了。</p><p>  <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2011.png" alt="Untitled"></p></li></ul></li><li><p>检验</p><p> F检验</p><p> $$<br> F&#x3D;\frac{U(n-k-1)}{Q_ek}&gt;F_{1-\alpha}(k,n-k-1),其他与一元一致<br> $$</p></li><li><p>实现</p><p> [b,bint,r,rint,stats]&#x3D;regress(Y,X,(alpha)),对于一元和多元是一样的。</p><p> bint为b的区间估计。</p><p> r为残差，也就是每一个y’与y的差值,rint为它的置信空间。</p><p> stats&#x3D;[$r^2$,F,F对应的概率p]。</p><p> $r^2$越接近1越好，F越大越好。</p><p> 可以通过rcoplot(r,rint)来画出残差与置信区间。</p></li></ol></li><li><p>逐步回归</p><p> 一些变量可能实际与y无关，此时通过暴力枚举的方式，选选去去变量，来找到那个最好的方案。</p><ul><li><p>实现</p><p>  stepwise(x,y,inmodel(一般空缺),alpha)<br>  会出来一个图形窗口，一般直接next step即可，matlab会自动进行逐步回归。</p><p>  如果希望手动操作的话，点击左边窗口内的条条即可去掉或选择变量。</p><p>  尽量使R.square接近1，且F增大。当变化不大时尽可能保留更多的变量。</p></li></ul></li></ol><h3 id="拟合（预测）"><a href="#拟合（预测）" class="headerlink" title="拟合（预测）"></a>拟合（预测）</h3><p>小样本。</p><p>当需要预测提供数据范围之外的数据的时候，应使用拟合。插值对于数据范围之外的数据会因为runge0现象而波动较大。</p><p>拟合更重要的是求函数关系，而插值是更关注函数值。</p><p>而插值必是过所有已知点的，而拟合不一定。</p><p>线性一般使用最小二乘，而非线性一般使用牛顿。</p><ol><li><p>多项式拟合</p><p> 见回归.3</p></li><li><p>非线性拟合</p><p> 见回归.2</p></li><li><p>可视化拟合（拟合工具箱）</p><p> 通过命令cftool启动。</p><p> 其中输入x data与y data，可以直接导入存储在工作区中的变量</p><p> 通过右上角的更改可以更改想要拟合的函数类型，函数类型如下。</p><p> 或者直接在下方直接输入想要拟合的函数</p><p> <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2012.png" alt="Untitled"></p><p> 左侧的result就是拟合的结果。使SSE体验RMSE趋向0，r-square趋向1。</p></li></ol><h3 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h3><p>评价类一般有几种，分类，排序与打分。</p><p>多个指标进行评价。</p><p>最终的权重函数一般有三种。</p><ol><li>线性加权（指标间没有较强关联性）</li></ol><p>$$<br>y&#x3D;\sum w_ix_i<br>$$</p><ol><li>非线性加权（指标间有较强关联性）</li></ol><p>$$<br>y&#x3D;\prod x_j^{w_j}<br>$$</p><ol><li>topsis</li></ol><h3 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h3><p>对于一个事物，有多个指标，而对于一个指标，评价是多种的，且是模糊的，没有明确分界线的，如{好，中，差}。但是我们知道评价的比例。’</p><p>实际上，这里只是将评价的比例作为隶属度而已。隶属度才是真正通用的模糊综合的指标。而隶属度就表示对于这个指标来说对于某一个模糊评价的隶属度。</p><p>而通过将指标的权重（通过层次分析法(主观)或者变异系数法(客观)求得）（列向量）与评价矩阵（每一行是一个指标的隶属度）模糊相乘，得到的新的矩阵就是对于这一个事物整体的评价比例，对其进行归一化即可。</p><p>模糊相乘：原理与矩阵相乘一致，但是相加变为取最大值，相乘变为取最小值。</p><p>实际上模糊相乘有很多种，每一种被称为一种算子，上面的这种就是一种算子，各有各不同的优点。</p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2013.png" alt="Untitled"></p><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2014.png" alt="Untitled"></p><p>若一个指标是由多个二级指标决定的，那么，将这个指标当做事物，进行一次模糊综合评价即可。</p><p>除去算子有很多种，隶属度的得出也有很多方法。下述的两种方法（与灰色关联分析相似）算子一般都是用第4种。</p><ol><li><p>相对偏差评价法</p><p> $$<br> u_i&#x3D;\begin{cases}max(x_i)\ 效益型\min(x_i)\ 成本型\end{cases}\r_{ij}&#x3D;\frac{|x_{ij}-u_i|}{max(x_i)-min(x_i)}(一列列进行处理)<br> $$</p><p> 越小越小</p></li><li><p>相对优属度评价法</p><p> $$<br> r_{ij}&#x3D;\begin{cases}x_{ij}&#x2F;max(x_i)\ 效益型\min(x_i)&#x2F;x_{ij}\ 成本型\min|x_{ij}-X_j|&#x2F;|x_{ij}-X_j|\ 固定性\end{cases}\X_j是第j个指标的适度值。<br> $$</p><p> 越大越好</p></li></ol><p>这两种与灰色关联分析法可以综合使用（得出的结果可能不同）</p><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><p>作用：数据的降维；数据的解释</p><p>主成分得出的综合指标数量与原指标数量一致，但是我们只取其中的一部分。</p><p>因子分析法得出的综合指标数量是被指定的。</p><p>主成分最终得出的指标的系数就是斜方差矩阵的特征向量。特征值除以特征值的总和就是贡献度。而这是由于当取特征向量的时候方差会最大，而这是我们所希望的。</p><p>一般选取主成分时有两种方式。</p><ol><li>累计贡献大于85%</li><li>特征根&gt;1</li></ol><p>使用主成分分析必须保证其成分之间是有关联的。</p><p>为了保证有关联，需要进行检验，一般有两种检验方式。</p><ol><li><p>kmo检验</p><p> 若&gt;0.5，则非常适合。</p><p> 若&gt;0.3，则可以，但不推荐。</p><p> 若&lt;0.3，则不要。</p></li><li><p>bartlett’s检验</p><p> 若&lt;0.05，则适合。</p><p> 若&gt;0.05，则不适合。</p></li></ol><p>上述的两个检验满足任意一个即可。</p><p>（好像spss中会自动检验，如果勾选的话？）</p><p>实现：</p><p>SPSS中：</p><p>使用因子分析法，描述中勾选初始解，与检验，提取中勾选选择主成分，斜方差，可以调整特征值，旋转不用管，得分要选择回归，且显示得分。</p><p>直接观察总方差解释，其中总计就表示特征根。</p><p>而后成分矩阵即为实际的系数。</p><p>都使用重新标注的（经过处理后的）。</p><p>但这里的系数是因子分析法的，而主成分分析法的因子就是因子分析法的因子&#x2F;开根号的特征根。</p><h3 id="变异系数法"><a href="#变异系数法" class="headerlink" title="变异系数法"></a>变异系数法</h3><p>由于如果数据的区别非常大，那么更容易来区分，给予它一个更大的权重。</p><p>变异系数法以标准差&#x2F;均值作为$v_i$权重，最后对$v_i$归一化，作为最终的权重$w_i$。</p><p>但这必须保证重要性相当的情况。</p><h3 id="四种基本变量"><a href="#四种基本变量" class="headerlink" title="四种基本变量"></a>四种基本变量</h3><ol><li>定类变量（其中的种类是平等的，没有高低之分的）</li><li>定序变量（其中的种类是有一个序的，但是不能定量）</li><li>定距变量（其中的种类是有一个序的，但是能定量）</li><li>定比变量（其中的种类是有一个序的，能定量，且存在0(没有)的概念，可以作乘除）</li></ol><p>方法使用分类：</p><table><thead><tr><th></th><th>定类</th><th>定序</th><th>定距</th></tr></thead><tbody><tr><td>定类</td><td>卡方类检验</td><td>卡方类检验</td><td>Eta</td></tr><tr><td>定序</td><td></td><td>spearman</td><td>spearman</td></tr><tr><td>定距</td><td></td><td></td><td>pearson</td></tr></tbody></table><ol><li><p>pearson</p><p> 适用条件。测量的连续变量。正态分布数据。成对数据。线性关系。</p><p> $$<br> r&#x3D;\frac{\sum(x_i-\overline{x})(y_i-\overline{y})}{\sqrt{\sum(x_i-\overline{x})^2\sum(y_i-\overline{y})^2}}\t&#x3D;\frac{r}{\sqrt{(1-r^2)&#x2F;(n-2)}}<br> $$</p><p> r即为相关度，而t则需要t检验。当|t|&gt;$t_\frac{a}{2}$时，则显著，若小于等于，则不显著。</p><p> r的取值与相关程度。取正为正相关，取负则负相关。</p><table><thead><tr><th>0.00-0.19</th><th>极低相关</th></tr></thead><tbody><tr><td>0.20-0.39</td><td>低度相关</td></tr><tr><td>0.40-0.69</td><td>中度相关8</td></tr><tr><td>0.70-0.89</td><td>高度相关</td></tr><tr><td>0.90-1.00</td><td>极高相关</td></tr></tbody></table></li><li><p>spearman</p><p> $$<br> r_s&#x3D;1-\frac{6\sum (x_i-y_i)^2}{n(n^2-1)}\t&#x3D;r_s\sqrt{\frac{n-2}{1-r_s^2}}<br> $$</p><p> 其中，xi与yi为其等级。n为样本量，当超过20时，要t检验。而检验基本与pearson一致。</p></li></ol><p>上述两种的实现在spss中分析-相关-双变量中直接调用即可解决，可以在样式中更改输出内容。</p><ol><li><p>卡方检验</p><p> 实现：SPSS中分析-描述统计-交叉表，在统计中选择方法（卡方）。行是因变量，列是自变量。</p><p> 当皮尔逊卡方的渐进显著性&lt;0.05时，则相关。</p><p> 如果数据是频数的，可以使用数据-个案加权来处理。</p></li><li><p>Eta</p><p> 实现：SPSS中分析-描述统计-交叉表，在统计中选择方法（相关性）。行是因变量，列是自变量。</p><p> Phi&gt;0.5，则相关。若Phi&gt;皮尔逊R，则关系更有可能为非线性。</p></li><li><p>偏相关</p><p> 一个因素可能与多个因素相关，若是我们只想研究二者之间的相关性，那么就需要控制其他变量。</p><p> 实现：spss中分析-相关-偏相关，变量中放入研究的几个变量，控制中放入需要控制的变量即可。（用的皮尔森？）</p><p> 检验也是t检验，直接看表中的显著性即可。</p></li></ol><h3 id="神经网络：大数据"><a href="#神经网络：大数据" class="headerlink" title="神经网络：大数据"></a>神经网络：大数据</h3><h3 id="元胞自动机：模拟"><a href="#元胞自动机：模拟" class="headerlink" title="元胞自动机：模拟"></a>元胞自动机：模拟</h3><h3 id="马尔科夫：概率转移，我的建议是直接暴力😀"><a href="#马尔科夫：概率转移，我的建议是直接暴力😀" class="headerlink" title="马尔科夫：概率转移，我的建议是直接暴力😀"></a>马尔科夫：概率转移，我的建议是直接暴力😀</h3><h3 id="国赛：颜色与物质浓度的辨识问题（回归-层次分析）"><a href="#国赛：颜色与物质浓度的辨识问题（回归-层次分析）" class="headerlink" title="国赛：颜色与物质浓度的辨识问题（回归+层次分析）"></a>国赛：颜色与物质浓度的辨识问题（回归+层次分析）</h3><p>通过线性回归的置信区间，残差分析来确定数据的优劣，F,R^2,P,S^2，以及剔除点数量。</p><p>解释模型与代码，一一分析。</p><p>给出残差图，残差值，与四个指标，并给出原数据，在过程中如果有异常点，则剔除后再做一次，最后给出该回归模型。</p><p>通过分别尝试线性回归和二次回归来建立模型，比较优劣。</p><p>给出残差，显著性四个指标，并进行检验。</p><p>通过层次分析来确定非定量指标对于最终的影响因子。</p><p>层次分析图</p><h3 id="国赛：校园供水系统智能管理（回归-神经网络）"><a href="#国赛：校园供水系统智能管理（回归-神经网络）" class="headerlink" title="国赛：校园供水系统智能管理（回归+神经网络）"></a>国赛：校园供水系统智能管理（回归+神经网络）</h3><p>对于找特征，需要涉及特征指标变量。在统计与计算过程中，可以列出，均值，方差，标准差，置信区间<strong>？</strong>(自由度&#x3D;6&#x2F;11)</p><p>并且要给出特诊指标变量的意义。</p><p>用图表表示给定数据。</p><p>回归过程中检验可以用SSE，SSR等更加专业的表示。</p><p>回归图中画出理论，实际与置信区间</p><p>神经网络写出模型建立，以及训练过程的图，与最终的结果。</p><h3 id="国赛：葡萄酒质量的评价（回归，聚类，双因子可重复方差分析？）"><a href="#国赛：葡萄酒质量的评价（回归，聚类，双因子可重复方差分析？）" class="headerlink" title="国赛：葡萄酒质量的评价（回归，聚类，双因子可重复方差分析？）"></a>国赛：葡萄酒质量的评价（回归，聚类，双因子可重复方差分析？）</h3><p>回归前可以使用皮尔森或其他相关性分析去掉几个变量。</p><h3 id="国赛：风电场运行状况分析及优化研究"><a href="#国赛：风电场运行状况分析及优化研究" class="headerlink" title="国赛：风电场运行状况分析及优化研究"></a>国赛：风电场运行状况分析及优化研究</h3><p>在优化时考虑实际。</p><h3 id="国赛：葡萄酒质量的评价"><a href="#国赛：葡萄酒质量的评价" class="headerlink" title="国赛：葡萄酒质量的评价"></a>国赛：葡萄酒质量的评价</h3><p>用正态分布检验来看统计结果</p><h3 id="遗传算法解决非线性规划与多目标规划"><a href="#遗传算法解决非线性规划与多目标规划" class="headerlink" title="遗传算法解决非线性规划与多目标规划"></a>遗传算法解决非线性规划与多目标规划</h3><h3 id="信息不完全、不充分的预测系统——灰色预测"><a href="#信息不完全、不充分的预测系统——灰色预测" class="headerlink" title="信息不完全、不充分的预测系统——灰色预测"></a>信息不完全、不充分的预测系统——灰色预测</h3><h3 id="校赛："><a href="#校赛：" class="headerlink" title="校赛："></a>校赛：</h3><ol><li>战争<ol><li><p>兰彻斯特</p></li><li><p>仿真模拟</p><p> <a href="%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%20093740f9344540a5b780855aa3d048d3/System_Dynamics_and_Multi-Agent_Simulation_Research_on_Ground_CombatPersonnel_Attrition.pdf">System Dynamics and Multi-Agent Simulation Research on Ground CombatPersonnel Attrition.pdf</a></p></li><li><p>神经网络&#x2F;回归预测</p></li><li><p>蒙特卡罗试验？</p></li><li><p>系统动力学</p></li></ol></li><li>共享单车<ol><li><p>（违规区域的划分与罚款金额的制定）</p></li><li><p>根据人的流量来进行投放（多商品流网络流(线性规划)，还要在最小成本的情况下，根据堵塞情况来决定流量大小，或者直接不要流量限制，直接最小成本）</p><p> <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2015.png" alt="Untitled"></p><p> <img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1Untitled%2016.png" alt="Untitled"></p></li><li><p>对于各品牌的投放策略的改变（因为常常有有蓝车没绿车，有绿车没蓝车的情况）(博弈?)</p></li><li><p>预测使用需求（各种预测模型，小样本灰色）</p></li><li><p>马尔科夫来预测车辆损坏情况来确定维修策略</p></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理 </title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p><a href="https://lhish.github.io/hide/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA">计算机系统概论</a></p><p><a href="https://lhish.github.io/hide/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8">运算方法和运算器</a></p><p><a href="https://lhish.github.io/hide/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">指令系统</a></p><p><a href="https://lhish.github.io/hide/CPU">CPU</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法 </title>
    <link href="/%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://lhish.github.io/hide/%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F">内省排序</a></p><p><a href="https://lhish.github.io/hide/%E4%B8%89%E8%B7%AF%E6%8E%92%E5%BA%8F">三路排序</a></p><p><a href="https://lhish.github.io/hide/nth_element">nth_element</a></p><p><a href="https://lhish.github.io/hide/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></p><p><a href="https://lhish.github.io/hide/timsort">timsort</a></p><p><a href="https://lhish.github.io/hide/A">A*</a></p><p><a href="https://lhish.github.io/hide/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3">字符串哈希相关</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 </title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式相当于是一种抽象的思路，为解决问题而生的固定化的套路思路。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>抽象：将具体事物抽象</p><p>封装：隐藏接口实现</p><p>继承：提取相同部分</p><p>多态：用相同的代码调用不同但类似的对象</p><h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><ol><li>依赖：类A中存在类B相关的东西</li><li>关联：类A中有类B</li><li>聚合：类A与类B是包含的关系但是非单一</li><li>组合：类A完全由类B等类组成</li><li>实现：类A实现接口类B</li><li>继承：类A继承B的接口与实现，并可以拓展</li></ol><p>面向对象最重要的两个设计要点就是：</p><ol><li>复用代码</li><li>扩展性</li></ol><p>而一个好的设计最重要的事：不要依赖于具体类或它的实现，而是要依赖于一个接口。</p><p>这个接口可以由对方来实现，也可以通过一个抽象类（接口类）作为中间层，而这个接口类表示我们所想要依赖的最本质的特性，如吃的依赖是食物等等。</p><p>另外，抽象类不要特化，特化交给继承来做，来实现接口。</p><p>且，有时组合是由于继承的。继承在枚举其下属属性的所有可能性，而组合就是将乘法变为加法，将无关的属性抽离出原本的类，作为一个新的类来实现，再通过对各自属性的继承来实现总体属性的枚举。</p><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>将一个复杂职责的类切分为多个单职责的类，使得对于每一个类仅需关注其本身而对于整体的组合也无需关注细节实现。这一点并不仅仅是为了模块化，还是为了方便我们更加掌控代码，调整整体逻辑。</p><p>但一般在实现上就是将实现归类，放在更关联的类中。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>闭：不修改类本身与实现。保证原本的依赖类的对象仍能正常工作。</p><p>开：通过继承的方式扩展其功能或进行修改，如需要重构某一个类，通过一个子类继承后重写对应方法即可。</p><p>不要动屎山，而是在屎山上添砖加瓦。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>在扩展类，也就是在进行子类继承时，必须保证子类对象能够作为父类对象而进行使用。</p><p>在对于其他的要求上，子类必须相同或更加宽泛（在函数参数与依赖对象的要求上）。</p><p>在他类对自己的要求上，子类必须相同或更加狭窄（在函数返回值与抛出异常和对他类的保证上）。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>当继承时，不希望继承许多无用的声明，可以将其中一起的一部分抽象为一个接口类。而对于接口类，也可以通过组合的方式将其拆分为多个更小的接口类来防止无用的继承实现。</p><p>可以使用多重继承来实现多个接口类。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>当高层次的类直接依赖于低层次的类时，但我们不希望高层次的类关注低层次的实现，应该将低层次的类抽象为一个抽象类，使高层次的类依赖于它（同样高层次），但此时低层次的类就使依赖***(?)***于该抽象类了。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>提供代码灵活性和复用性的创建对象的模式。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>将多种具体产品抽象为一个抽象的产品，并以一个抽象类“工厂”来创建产品，返回一个抽象产品指针，其通过继承来实现对于不同产品的创建。</p><p>优点：</p><p>这样可以使创建与对象本身相分离，使得更加具有扩展性。</p><p>不用构造函数而使用其他的函数简介创建对象能够实现更加复杂的功能，如使其变为单例。</p><p><img src="/image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FUntitled.png" alt="Untitled"></p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂实际是工厂模式的上位。工厂模式中是只有一个工厂，而抽象工厂将工厂也抽象出来，很多具体工厂继承抽象工厂，返回对应产品的抽象产品。不同的工厂生产的产品抽象为不同的抽象产品。</p><p>一般用于二维的种类情况下，多个不同系列的相关产品。</p><blockquote><p>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。</p></blockquote><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>当一个类的种类维度很大的时候，若是通过工厂的方式，需要建立很多子类，使代码变复杂。这个时候就应该使用生成器。</p><p>生成器拥有一个建造者抽象类来负责具体某一维度的创建（通过多个建造者可以来实现不同情景下的类似的结构，如windows和mac），另外一个主管类来负责决定到底让建造者抽象类来创建哪一部分。最终通过主管类来获取最终产品。</p><p>实现上，一般使用一个容器来装维度。另外，每一个建造者类需要创建一个获取最终产品的函数，这是由于产品可能接口不同，因此不能再基类中使用抽象接口返回。另外，在创建交付完后，需要重置建造者的产品以为下一次建造做准备。</p><p>可以用于构造组合树和其他复杂对象。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>由于类的有一部分成员是私有的，所以很难完全进行复制。为了能够进行复制，因此使用原型的方式。</p><p>原型实际就是通过复制一个具体的类的实例来“复制”。将需要复制的原型归于一个抽象原型类，其提供一个返回指向自身的指针。另外需要一个注册表类来对应类名和类的实例，一般使用map存储即可。这个类的实例里的属性可以是任意的初值，根据情况而定。</p><p>优点：</p><p>一般复制使用拷贝构造或拷贝赋值，但这会和具体类的实现相关联，原型可以使复制代码独立于具体类。</p><p>对于常用的一些特定的类实例，可以通过原型来去掉初始化时使用的时间，也可以使更加方便。</p><p>并可以通过继承以外的方式来处理复杂对象的不同配置。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>正如其名，就是永远只有一个实例。而这是构造函数所不能实现的。</p><p>使用单例不但是为了让某个对象共享，更是为其提供了全局变量不能提供的安全性(不懂是什么样的安全性)。</p><p>实现时在单例类中创建一个该单例类的静态指针，指向实际有意义的那个实例。另外通过一个新的函数来代替构造函数来间接构造。该函数来判断是调用构造函数创建实例或者返回已有实例。</p><p>若是在多线程中，需要使用线程锁来保证安全，否则可能最后因为多线程而创造了多个实例。</p><p>优点：</p><p>可以用作一个全局变量（用函数来调用获得）</p><h1 id="下面都得重写"><a href="#下面都得重写" class="headerlink" title="下面都得重写"></a>下面都得重写</h1><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>有时程序库提供的接口并不符合我们的希望，如数据类型不同等等，此时我们可以通过更改程序库来支持这样的一个接口。但是一般来说能不改原来已有完成的类是不好的，有的时候甚至我们并没有程序库的源代码，无法进行更改，因此，我们可以使用适配器来提供一个间接的接口。</p><p>适配器实际上很简单，就是一个类，类的构造函数传入一个要被适配的对象(调用函数库者)，继承程序库，并重写接口，使接口符合我们希望的样子。</p><p>或者也可以使用多重继承，就无需传入被适配的对象。</p><p>一般用于使某个接口可以使用，或者当一个继承体系下某一些类共有一些方法可以通过适配器来实现（如何实现?）。</p><p>适配器一般用于更改已有接口使其适配各种各样的。</p><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>对于一个非常复杂的类，我们可以通过将其转化为一个多层的层级结构（每一个节点都是一个类）来简化它。</p><p>在这种情况下，下级的具体类将作为上级抽象类的一个对象而存在，这可以使上级抽象类不用管下级具体类的实现，自己直接调用接口即可。</p><p>每一层的类的修改都不影响其他类的情况，易于更改，维护。</p><p>另外由于下层类仅仅是上层的一个对象，因此可以通过传入各种不同的底层实现具体类对象来轻松更改下层实现方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>当对于当个对象和复合对象都有着很多很多类似的操作时，可以使用组合，如军队，窗口等等。</p><p>实现上：用一个类实现所有相同的操作，再分别用叶节点和组合体继承这个类。整体实现一个树的结构。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数 </title>
    <link href="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><p>当对一个线性空间进行线性变换的时候，可以将i和j变换看做整个空间的变换，因为线性的等式在变换后仍然保持不变。</p><p>另外，假如说i和j变换为了i’和j’，那么对于一个向量的变换就相当于左乘[i’ j’]，这是一个n阶方阵。</p><p>另外，如果对一个空间连续做几次变换，将这些变换方阵相乘实际上就是总的变换，但后变换的永远都是左乘。</p><p>矩阵乘积实际就是变换相加，假设后面一个矩阵是基的i和j，然后前面的矩阵分别对这两个基向量进行变换得到新的i’和j’。</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>行列式的值就代表一个变换对于原线性空间里的任意面积在变换后也就是新的线性空间内的面积的比值，比如说行列式为6就代表变换后面积会变为原来的6倍。因此，如果说行列式等于零，就说明变换后面积等于0，也就是维度降低了，也就是这个变换矩阵线性相关了。</p><p>当行列式的值为负数的时候，就说明空间整个被翻转了，比如二维平面就是另一个面朝上了。或者说，基向量的相对方向已经变了。</p><p>而在三维空间就是体积了。而三维中负值就是原本是右手定则，现在变成左手定则了。</p><h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><p>就是一个未知向量乘上一个变换矩阵得到一个特定的向量，那么一般情况下我们求这个未知向量就是将这个变换矩阵的逆左乘这个特定的向量。这个变换矩阵的逆就是逆变换，也就是反着变换，也因此正变换一次，反变换一次，就相当于没变换，也就是单位矩阵，也就是 恒等矩阵。</p><p>整一个线性方程组就是未知向量能由正变换变为已知向量，那么要求未知向量就是将已知向量逆变换一下就得到了。</p><p>当行列式不为0时，变换后仍然是一整个线性空间，因此有且仅有一个解。</p><p>当行列式为0的时候，线性空间的维度就降低了，当且仅当我们的已知向量在这个被降低的新的线性空间上的时候，它才有可能有解。</p><p>而若是当行列式为0，但是已知向量不在这个被降低的新的线性空间的时候，就会导致逆变换的时候一个输入对应多个输出的情况，这是不可能的。</p><h3 id="秩与列空间"><a href="#秩与列空间" class="headerlink" title="秩与列空间"></a>秩与列空间</h3><p>秩代表了在经过这个变换矩阵的变换后线性空间的维数，比如秩为1就是变换后事一根直线。</p><p>实际上，变换矩阵本身假设作为一个线性空间的基，那么它能伸展出的维数和别的线性空间通过它来变换延展出的维数时相同的，这很显然。</p><p>因此，列空间就代表变换矩阵的每一个列作为一个向量所组成的基延展出的线性空间。</p><p>而秩实际上是这个列空间的维数。</p><p>而零空间就是指在经过这个变换后会落在0向量上的点所组成的线性空间，而这组成的空间也必然是一个线性空间。</p><h3 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h3><p>一个非方阵代表底维向高维的变换或者高维向底维的变换。</p><p>底维向高维的变换实际上是变换到高维中的一个底维空间中。</p><p>而高维到底维就是会产生1对多的情况。</p><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><p>点积是两个向量之间相乘。</p><p>但假如说，我们将其中一个向量看做是一个变换矩阵，那么代表了一个高维到一维的转换，实际上，就是一种投影。假设这个变换矩阵是单位长的，那么这个投影就是垂直的，然后在乘上这个变换矩阵的模，就是实际的投影的。</p><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>评价是挺有道理的，但是没完全理解，但不是那么的重要。</p><h3 id="空间变换"><a href="#空间变换" class="headerlink" title="空间变换"></a>空间变换</h3><p>如果我们想对别的空间进行变换，那么首先先将别人的基向量换为我们的空间中的语言，对变换的基向量进行变换，然后再转回为他们空间的语言。这得出来的变换矩阵就是在对方空间实际的变换矩阵。用数学表示就是$A^{-1}MA$，A为变换为我们空间的矩阵，M为我们希望的变换矩阵。</p><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><p>特征向量就是在一个空间中经过变换后方向仍然不会变，但是可能长度会变的向量的集合。</p><p>特征值就是这个长度变化的比例。</p><p>$Av&#x3D;\lambda v$实际上就是说v经过A的变换还是v的倍数。</p><p>而这一点很重要，比如在三维中，特征向量的方向实际上就是旋转轴。</p><p>当将其转为$(A-\lambda I)v&#x3D;0$时，由于前面线性方程组已经说了，当且仅当降为的时候，才有非0向量变为0向量，因此$A-\lambda I$的行列式必须等于0。</p><p>如果说，解出来$\lambda$是一个复数，那么就涉及到了旋转，在这里不赘述。</p><p>对于一个方阵来说，我们希望求以它为变换矩阵变换了n次的结果，那么首先获得它的特征向量，假如说它的特征向量能延展到整个空间，就可以继续，那么首先将这个变换矩阵变换为以它的特征向量作为基向量的变换矩阵，在以它的特征向量为基向量的空间中，这个变换并没有进行旋转，只进行了缩放操作，因为在原空间中，这两个基向量所在的方向上并没有旋转，因此在那个空间里也是。因此就很容易计算了。最后再变换回来就好了</p><h3 id="抽象向量"><a href="#抽象向量" class="headerlink" title="抽象向量"></a>抽象向量</h3><p>向量是指一切满足线性也就是可加性和数乘的抽象概念。比如可以扩展到函数啊，各种其他的上面。这些“向量”也必然满足线性得出来的一些结论。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络流 </title>
    <link href="/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><p>网络流是一张模拟运输或流动的图。其边的权重代表边的容量。一般我们将其看做一个水流系统。有一个源节点和一个汇点（流出点）。每一条边上的流量不能超过容量，而每一个节点也不能存储任何水量。另外，这张图不存在自循环，且不存在反平行边(一对边(u,v)与(v,u))。</p><p>而对于任意一个节点，流入量等于流出量。</p><p>如果遇到反平行边，可以将其中一条边中加入一个新的节点来避免反平行边。</p><p>而若是有多个源节点和多个汇点，则可以建一个超级源节点和超级汇点，其分别指向源节点和被汇点指向，边权为无限即可。</p><h2 id="Ford-Fulkerson"><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h2><p>一个流是一个从源节点到汇点的一条路径。并且这条路径有一个大小，也就是水流的大小，水流的大小必须小于路径上最小的容量。</p><h3 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h3><p>对于一个网络流，它所有的边都是单向的。我们将其补全为双向的，顺其方向的路径上的权重表示这条路径上流的大小，而逆其方向的路径(不存在于网络流中的)权重表示这条路径上还能通过的流的大小，也就是容量减去流的大小。</p><p>这样形成的图被称为残存网络。</p><h3 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h3><p>残存网络中的一个流就是原网络流中的一个增加流。</p><p>$(f↑f’)(u,v)&#x3D;f(u,v)+f’(u,v)-f’(v,u)$，因为残存网络中的逆向流就是减少流，正向流就是增加流。</p><p>另外，由于该流是在残存网络中的一个流，所以最终肯定是汇入汇点的，因此汇点的流量大小是增加的，这样的流被称为增广路径。</p><p>只要不断地在残存网络中找这样的增广路径并将其增加到原网络流中，汇点的流就是不断增加的，直到找不到这样的增广路径，此时就是最大流了。</p><h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><p>一个割就是将所有的节点分为两个部分，源节点和汇点必须属于任意一个部分。</p><p>假设源节点所在的部分为S，汇点所在的部分为T。净流量的大小就等于S→T的流量减去T→S的流量。由于流量在路上是没有损失的，也就是说S和T的内部流量都是这么多，因此净流量的大小对于任何割都是一样的(这很显然)。因此净流量的大小就是网络流中流的大小。</p><p>我们假定对于一个割来说，它的容量为S→T的容量和，因此它肯定是大于割的净流量的，因为净流量&lt;S→T的流量&lt;S→T的容量和，因此最大流的大小受最小割的容量限制，也就是最大流的值等于最小割的容量。</p><p>这一点与不存在增广路径是等价的。这一点对于线性规划来解网络流非常关键。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一般使用深搜的方法来寻找增广路径，因为只需要找到任意一个路径就可以了。不断寻找并更新网络流和残存网络，直到增广路径不存在。</p><p>由于每次增广路径为整体流的贡献至少为一个单位，因此整体增广路径的次数为$O(|f^*|)$，$f^*$为最大流。而每一次寻找增广路径并更新的复杂度为$O(E)$，总体的复杂度就是$O(E|f^*|)$，这复杂度非常玄学。</p><h2 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h2><p>选择增广路径选择从源节点到汇点的最短路，这里的最短路是指假设所有的边的权重都为1的情况下。</p><p>可以证明源节点到任意节点的最短路径必然是随着操作的进行而单调递增的(算法导论引理26.7，证明没懂）。</p><p>我们称一条边为关键边当且仅当这条边在增广路径上且容量最小。</p><p>如果流量增加了一次，那么必然至少有一条边成为了关键边。因此流量增加次数小于等于所有边成为关键边的次数。</p><p>当我们假设一条边成为了关键边，那么它残存网络上这条边就会成为0。如果希望它第二次成为关键边，那么反向边必须已经在增广路径上出现过一次。因为只有这样它的权重才不会为0了。</p><p>由上述的引理26.7可知，每个循环所有节点的最短路径都不会减小。另外，假设某一条路径是源节点到汇点的最短路，那么这条路径也必然是源节点到这个节点的最短路，假设某条关键边的两边节点分别为u和v，那么第一次成为关键边时$\delta(u)+1&#x3D;\delta(v)$，而为了保证它第二次成为关键边，那么，在反向路出现在增广路径中时$\delta’(v)+1&#x3D;\delta’(u)$，而$\delta(v)’\ge\delta(v)$，因此一次成为关键边u的最短路至少增加2，但最短路径必然是少于整体节点数的（最短路径对于每一个节点最多经过一次），因此一条边最多进行节点数&#x2F;2个循环。而总共有E条边，因此最多总共$O(VE)$次循环。总体就是$O(VE^2)$。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性规划 </title>
    <link href="/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <url>/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p>线性规划有两种形式：</p><ol><li><p>标准型：</p><p> $$<br> maxmize\ \sum_{j&#x3D;1}^nc_jx_j\\sum^n_{j&#x3D;1}a_{ij}x_j\le b_i\ ,\ i&#x3D;1,2,\dots,m\\ \ \ \ \ \ \ \ \ \ \ x_j\ge0\ ,\ j&#x3D;1,2,\dots,n<br> $$</p></li></ol><p>$$<br>maxmize\ c^Tx\Ax\le b\\ \ \ x\ge0<br>$$</p><pre><code class="hljs">   要化为标准型，要克服一下困难。</code></pre><ol><li><p>目标函数不是最大化，而是最小化。</p><p> 将所有的都取负。</p></li><li><p>变量不具有非负约束。</p><p> 将$x_j$转为$x_j’-x_j’’$，这两个引入的变量有非负约束。</p></li><li><p>有等式约束</p><p> 将其转为一个$\le和一个\ge。$</p></li><li><p>松弛型</p><p> $$<br> maxmize\ z&#x3D;v+\sum_{j\in N}c_jx_j\ \ \ \ \ \ \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x_i&#x3D;b_i-\sum_{j\in N}a_{ij}x_j,i\in B<br> $$</p></li></ol><p>松弛型就是对于每一个标准型中的约束引入一个有非负约束的松弛变量来将其改写为等式约束，并且依此改写目标函数。其中，等式左侧的松弛变量是基本变量，而右边的则为非基本变量，最终目标函数中只允许出现非基本变量。其中，B为基本变量的下标集合，而N为非基本变量的下标集合。</p><p>实际上所有的变量都是非负约束的。</p><p>后续中用（N, B, A, b, c, v)来表示一个松弛型。</p><h3 id="一些问题用线性规划解决"><a href="#一些问题用线性规划解决" class="headerlink" title="一些问题用线性规划解决"></a>一些问题用线性规划解决</h3><ol><li><p>最小费用流 </p><p> 是对于最大流的一个推广。不再是求最大流，而是在汇点要求一定流的情况下，要求成本最小，这是由于现在每条路径上都存在一个单位流成本。</p></li><li><p>多商品流</p><p> 对于最小费用流的一个推广。现在有多种流，但每种流的源节点和汇点不一定相同，但流共享容量。不再需要最小化成本，只需给出一个方案即可。看起来这个并没有目标函数，但实际上，只不过它的目标函数是一个用0替代的常数罢了，所以仍然是一个线性规划。</p></li></ol><h3 id="单纯形算法"><a href="#单纯形算法" class="headerlink" title="单纯形算法"></a>单纯形算法</h3><p>对于一个松弛型的线性规划来说，基本解是非基本变量都为0，而基本变量根据非基本变量求出。如果这个基本解是一个可行解，那么称之为可行基本解。</p><p>单纯形算法由一个可行基本解出发，不断将松弛型更改为一个等价的松弛型来缩小可行域的范围(我是这么理解的)。</p><p>而更改松弛型的方式就是转动。将一个基本变量替入其中(变为非基本变量，放到等式右侧)，将一个非基本变量换出（变为非基本变量，放到等式左侧)。</p><p>这个过程的实质就是缩小范围。对于目标函数中系数为正的变量，我们希望其越大越好。而系数为负的变量，我们希望其越小越好，实际上取0即可，因为非负约束。而对于一个系数为正的变量，我们将其增大，而唯一的限制就是所有基本变量的非负约束，我们取对该非基本变量限制最严格的基本变量替入，也就是让该非基本变量变为部分取决于限制最严格的基本变量，其范围也就自然而然被缩小了，缩小为当前限制体现出来不可能的部分。</p><p>当在目标函数中所有自变量的系数都为负数时，其就是最优解了，因为存在一个非负约束，导致最大值就是v。</p><p><strong>无界的情况：当对于某一个系数为正的非基本变量寻找对于它最严格的基本变量的约束时，若发现没有约束或者负相关时，也就是这个非基本变量能够无限增大，也就是说，目标函数可以无限增大，此时无界。</strong></p><p>按理来说，由于松弛型最多只有$C_{n+m}^m$种，n为非基本变量数量，m为基本变量数量，因此循环最多就进行松弛型的种类数。但是有时会出现循环的情况，此时我们可以通过每次都选择具有最小下标的非基本变量这一策略，这一策略能保证不会出现无限循环的情况，在此不做证明。</p><h3 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h3><p>对于一个规划问题，原问题是求最大值。则其对偶问题就是求其最小值，且其最优值就是原问题的最大值。对偶问题不唯一，因为实际上要求很少。但是我们针对一个规划问题，去找他的对偶问题实际上是为了简化，并且实际上对偶问题本身也很难找，在我们本身并不知道最优值是多少的情况下。</p><p>常用的有拉格朗日对偶。</p><p>在此处，算法导论使用的对偶比较特殊，是专门针对线性规划问题的。</p><p>$$<br>minmize\ \sum_{i&#x3D;1}^mb_iy_i\\sum^m_{i&#x3D;1}a_{ij}y_i\ge c_j\ ,\ j&#x3D;1,2,\dots,m\\ \ \ \ \ \ \ \ \ \ \ y_i\ge0\ ,\ i&#x3D;1,2,\dots,n<br>$$</p><p>这就是标准型的对偶问题。</p><p>首先很轻松可以证明，原问题的目标函数必然小于等于该对偶问题的目标函数。证明见附录图1。</p><p>此时，只要我们能够证明其最大值与最小值是相等的，我们就可以证明这个最大值和最小值是最优解。因为互相限制。</p><p>为了证明这一点，我们首先需要求出对偶问题的解。</p><p>假设$c_j’$是最后松弛型的系数，那么$\overline{y_i}&#x3D;\begin{cases}-c_{n+i}’\ \ \ \ 若(n+i)\in N\0\ \ \ \ \ \ \ \ \ \ \ \ 其他 \end{cases}$。</p><p>经过数学证明，可以证明两个最优值相等，且对偶问题的解是可行的。证明见附录图2。</p><h3 id="可行初始解"><a href="#可行初始解" class="headerlink" title="可行初始解"></a>可行初始解</h3><p>到目前为止，还差最后一块拼图，那就是最初的可行初始解怎么确定，因为当非基本变量全取0的时候可能并不是一个可行初始解。</p><p>但实际上，这样的一个可行初始解相当难找，因此我们构造一个“没有目标”的线性规划来找到任意一组可行初始解。</p><p>$$<br>maxmize\ \ \ \ -x_0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\sum^n_{j&#x3D;1}a_{ij}x_j-x_0\le b_i\ ,\ i&#x3D;1,2,\dots,m\ \ \ \ \ \ \ \ \ \ \ \ \ \\ \ \ \ \ \ \ \ \ \ \ x_j\ge0\ ,\ j&#x3D;0,1,2,\dots,n<br>$$</p><p>由于限制了$x_0\ge0$，因此若是达到最大化，$x_0$&#x3D;0。而此时求出的其他x也是满足约束条件的，因此是一个可行解。若是最优值不能达到0，那么就是没有可行解的。</p><p>流程：</p><ol><li>是否所有b都$\ge$0，如果是，则非基本变量全0是一组可行解。</li><li>否则构造上述线性规划问题。</li><li>用$x_0$替入替换$x_l,l&#x3D;n+k,k为最小的b的下标$，此时基本变量$x_l$将是最小的基本变量，初始解为全0。</li><li>可以证明，在第三步结束所得的解将会变为一个对于该问题的可行解。证明见附录图3。</li><li>求出辅助线性规划的最优值，判断是否是0</li><li>若是0，则通过转动将$x_0$变为非基本变量。</li><li>否则无解。</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr><p><img src="/image/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92Untitled.png" alt="图1"></p><p>图1</p><hr><p><img src="/image/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92Untitled%201.png" alt="图2"></p><p>图2</p><hr><p><img src="/image/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92Untitled%202.png" alt="图3"></p><p>图3</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
